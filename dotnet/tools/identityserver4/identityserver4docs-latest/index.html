

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>IdentityServer4 1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  
  

  
    <link rel="canonical" href="https://identityserver4docs.readthedocs.io/zh_CN/latest/index.html" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> IdentityServer4
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption" role="heading"><span class="caption-text">介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/big_picture">大图</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">验证</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#api">API 访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#openid-connect-oauth-2-0">OpenID Connect 和 OAuth 2.0 – 更好地结合在一起</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver4">IdentityServer4 如何提供帮助</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/terminology">术语</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver">IdentityServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#user">User</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#client">Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identity-token">Identity Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#access-token">Access Token</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/specs">支持的规范</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#openid-connect">OpenID Connect</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#oauth-2-0">OAuth 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/packaging">打包和构建</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver4">IdentityServer4 主仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">快速入门用户界面</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">访问令牌验证处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">模板</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">开发版本</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/support">支持和咨询选项</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">免费支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">商业支持</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/test">演示服务器</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro/contributing">贡献</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">如何贡献？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">一般反馈和讨论？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bugs">Bugs和功能请求？</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">贡献代码和内容</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">贡献项目</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">快速入门</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/0_overview">概述</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">准备工作</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/1_client_credentials">使用客户端凭据保护 API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">源代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">准备工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#asp-net-core">设置 ASP.NET Core 应用程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#api-scope">定义 API Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">定义客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver">配置 IdentityServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">添加 API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id8">控制器</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#nuget">添加 Nuget 依赖项</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">创建客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id12">调用 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id13">API 授权</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id14">进一步的实验</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/2_interactive_aspnetcore">使用 ASP.NET Core 的交互式应用程序</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">添加用户界面</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mvc">创建 MVC 客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#openid-connect">添加对 OpenID Connect 身份范围的支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">添加测试用户</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mvc-identityserver">将 MVC 客户端添加到 IdentityServer 配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">测试客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">添加注销</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#userinfo">从 UserInfo 端点获取声明</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">进一步的实验</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">添加对外部身份验证的支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#google">添加 Google 支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id13">进一步的实验</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/3_aspnetcore_and_apis">ASP.NET Core 和 API 访问</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">修改客户端配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mvc">修改MVC客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">使用访问令牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">管理访问令牌</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/4_javascript_client">添加 JavaScript 客户端</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">新的 JavaScript 客户端项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">修改托管</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">添加静态文件中间件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#oidc-client">引用 oidc-client</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#html-javascript">添加您的 HTML 和 JavaScript 文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#javascript-identityserver">为 JavaScript 客户端向 IdentityServer 添加客户端注册</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cors-ajax-web-api">使用 CORS 允许 Ajax 调用 Web API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">运行 JavaScript 应用程序</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/5_entityframework">使用 EntityFramework Core 获取配置和操作数据</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver4-entityframework">IdentityServer4.EntityFramework</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sqlserver">使用 SqlServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ef">数据库架构更改和使用 EF 迁移</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">配置存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">添加迁移</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">初始化数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">运行客户端应用程序</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstarts/6_aspnet_identity">使用 ASP.NET Core Identity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">新的 ASP.NET Core Identity 项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">检查新项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#identityserveraspnetidentity-csproj">IdentityServerAspNetIdentity.csproj</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#startup-cs">Startup.cs</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#config-cs">Config.cs</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#program-cs-seeddata-cs">Program.cs 和 SeedData.cs</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#accountcontroller">AccountController</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mvc">使用 MVC 客户端登录</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">缺少了什么？</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">主题</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/startup">Startup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">配置服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">密钥材料</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">内存配置存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">测试存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">额外服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">缓存</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">配置管道</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/resources">定义资源</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">身份资源</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#apis">APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#scopes">Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">基于 Scopes 的授权</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">参数化 Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#api-resources">API Resources</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#v4">迁移到 v4 的步骤</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/clients">定义客户端</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">定义服务器到服务器通信的客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#api">定义用于使用身份验证和委托 API 访问的交互式应用程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#appsettings-json">在 appsettings.json 中定义客户端</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/signin">登录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#cookie">Cookie 认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">覆盖 cookie 处理程序配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">登录用户界面和身份管理系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">登录工作流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">登录上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">颁发 cookie 和声明</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/signin_external_providers">使用外部身份提供商登录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">为外部提供商添加身份验证处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cookie">Cookie 的作用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">触发身份验证处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">处理回调并登录用户</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#url-isecuredataformat">状态、URL 长度和 ISecureDataFormat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/windows">Windows 身份验证</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#iis-windows">在使用 IIS 托管的 Windows 上</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/signout">注销</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#cookie">删除身份验证 cookie</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">通知客户端用户已注销</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">由客户端应用程序发起的注销</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/signout_external_providers">注销外部身份提供商</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/signout_federated">联合注销</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/federation_gateway">联合网关</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">执行</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/consent">同意</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">同意页面</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">授权上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver">将同意结果通知 IdentityServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">将用户返回到授权端点</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/apis">保护 API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">验证引用令牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">支持 JWT 和引用令牌</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/deployment">部署</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">典型架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">配置数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">密钥材料</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">操作数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#asp-net-core">ASP.NET Core 数据保护</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">ASP.NET Core 分布式缓存</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/logging">日志</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#serilog">Serilog 的设置</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/events">事件</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">发出事件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sinks">自定义 sinks</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">内置事件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">自定义事件</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/crypto">密码学、密钥和 HTTPS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">令牌签名和验证</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">签名密钥滚动更新</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">数据保护</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">HTTPS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/grant_types">授权类型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">机器到机器通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">交互式客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">没有浏览器或输入设备受限的交互式客户端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">自定义场景</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/client_authentication">客户端认证</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">创建共享密钥</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">使用共享密钥进行身份验证</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">使用非对称密钥进行身份验证</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/extension_grants">扩展授权</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">示例：使用扩展授权的简单委托</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/resource_owner">资源所有者密码验证</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/refresh_tokens">刷新令牌</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">其他客户端设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">请求刷新令牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">使用刷新令牌请求访问令牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">自定义刷新令牌行为</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/reference_tokens">引用令牌</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/persisted_grants">持久授权</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">持久授权</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">授权消费</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">持久授权服务</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/pop">访问令牌所有权证明</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/mtls">Mutual TLS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">服务器设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#asp-net-core">ASP.NET Core 设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver-setup">IdentityServer setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">客户端认证</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#identityserver">使用客户端证书对 IdentityServer 进行身份验证</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">发送方受限访问令牌</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">确认声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#api">在 API 中验证和接受客户端证书</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">自省和确认声明</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">临时客户端证书</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">使用临时证书请求令牌</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/request_object">授权请求对象</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#jwts">通过引用传递请求 JWTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">访问请求对象数据</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/custom_token_request_validation">自定义令牌请求验证和颁发</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/cors">CORS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">基于客户端的 CORS 配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">自定义 Cors 策略服务</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver-cors-asp-net-cores-cors">将 IdentityServer CORS 策略与 ASP.NET Cores CORS 策略混合使用</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/discovery">发现</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">扩展发现</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/add_apis">添加更多 API 端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">发现</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">高级</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">声明转换</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/add_protocols">添加新协议</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">典型的身份验证工作流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#identityserver">有用的 IdentityServer 服务</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topics/tools">工具</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">端点</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/discovery">发现端点</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/authorize">授权端点</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/token">令牌端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">例子</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/userinfo">用户信息端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">例子</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/device_authorization">设备授权端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">例子</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/introspection">自省端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">例子</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/revocation">撤销端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">例子</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-endpoints/endsession">结束会话端点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">例子</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/options">IdentityServer Options</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#endpoints">Endpoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#discovery">Discovery</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#authentication">Authentication</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inputlengthrestrictions">InputLengthRestrictions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#userinteraction">UserInteraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#caching">Caching</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cors">CORS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#csp">CSP (内容安全政策)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#device-flow">Device Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mutual-tls">Mutual TLS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/identity_resource">Identity Resource</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/api_scope">API Scope</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#defining-api-scope-in-appsettings-json">Defining API scope in appsettings.json</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/api_resource">API Resource</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#defining-api-resources-in-appsettings-json">Defining API resources in appsettings.json</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/client">Client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#basics">Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#authentication-logout">Authentication/Logout</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#token">Token</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#consent-screen">Consent Screen</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#device-flow">Device flow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/grant_validation_result">GrantValidationResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/profileservice">Profile Service</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#iprofileservice-apis">IProfileService APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#profiledatarequestcontext">ProfileDataRequestContext</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">请求的范围和声明映射</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#isactivecontext">IsActiveContext</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/interactionservice">IdentityServer Interaction Service</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#iidentityserverinteractionservice-apis">IIdentityServerInteractionService APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#authorizationrequest">AuthorizationRequest</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#resourcevalidationresult">ResourceValidationResult</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#errormessage">ErrorMessage</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#logoutrequest">LogoutRequest</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#consentresponse">ConsentResponse</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#grant">Grant</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/deviceflow_interactionservice">Device Flow Interaction Service</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ideviceflowinteractionservice-apis">IDeviceFlowInteractionService APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#deviceflowauthorizationrequest">DeviceFlowAuthorizationRequest</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#deviceflowinteractionresult">DeviceFlowInteractionResult</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/ef">Entity Framework Support</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#configuration-store-support-for-clients-resources-and-cors-settings">Configuration Store support for Clients, Resources, and CORS settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#configurationstoreoptions">ConfigurationStoreOptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#operational-store-support-for-persisted-grants">Operational Store support for persisted grants</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#operationalstoreoptions">OperationalStoreOptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#database-creation-and-schema-changes-across-different-versions-of-identityserver">Database creation and schema changes across different versions of IdentityServer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/aspnet_identity">ASP.NET Identity Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">杂项</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-misc/training">Training</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#identity-access-control-for-modern-applications-using-asp-net-core-2-and-identityserver4">Identity &amp; Access Control for modern Applications (using ASP.NET Core 2 and IdentityServer4)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pluralsight-courses">PluralSight courses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-misc/blogs">Blog posts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#team-posts">Team posts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">2020</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">2019</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">2018</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">2017</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#community-posts">Community posts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-misc/videos">Videos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">2020</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">2019</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">2018</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">2017</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">2016</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">2015</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">2014</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">IdentityServer4</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>IdentityServer4 1.0.0 文档</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/devenliu/IdentityServer4Docs/blob/main/zh-CN/docs/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="identityserver4">
<h1>欢迎使用 IdentityServer4（最新）<a class="headerlink" href="#identityserver4" title="永久链接至标题">¶</a></h1>
<img alt="_images/logo.png" class="align-center" src="_images/logo.png" />
<p>IdentityServer4 是用于 ASP.NET Core 的 OpenID Connect 和 OAuth 2.0 框架。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>从2020年10月1日起，我们成立了一家新的 <a class="reference external" href="https://duendesoftware.com/">公司</a> 。
所有新的主要功能工作都将在我们新的 <a class="reference external" href="https://github.com/duendesoftware">组织</a> 中进行。
新的 Duende IdentityServer 可在 FOSS (RPL) 和商业许可下使用。
开发和测试始终免费。
<a class="reference external" href="https://duendesoftware.com/contact">联系</a> 了解更多信息。</p>
<p>IdentityServer4将在2022年11月之前进行错误修复和安全更新。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本文档涵盖了主分支上的最新版本。这可能尚未发布。使用左下角的版本选择器选择特定版本的文档。</p>
</div>
<p>它在您的应用程序中启用以下功能：</p>
<div class="line-block">
<div class="line"><strong>身份验证即服务</strong></div>
<div class="line">所有应用程序（Web、原生、移动、服务）的集中登录逻辑和工作流。</div>
<div class="line">IdentityServer 是 OpenID Connect 的官方 <a class="reference external" href="https://openid.net/certification/">认证</a> 实现。</div>
</div>
<div class="line-block">
<div class="line"><strong>单点登录/注销</strong></div>
<div class="line">通过多种应用程序类型进行单点登录（和注销）。</div>
</div>
<div class="line-block">
<div class="line"><strong>API访问控制</strong></div>
<div class="line">为各种类型的客户端发布 API 的访问令牌，例如 服务器到服务器、Web 应用程序、SPA 和原生/移动应用程序。</div>
</div>
<div class="line-block">
<div class="line"><strong>联合网关</strong></div>
<div class="line">支持外部身份提供商，如 Azure Active Directory、Google、Facebook 等。</div>
<div class="line">这使您的应用程序免受如何连接到这些外部提供商的详细信息的影响。</div>
</div>
<div class="line-block">
<div class="line"><strong>专注于定制</strong></div>
<div class="line">最重要的部分 - IdentityServer 的许多方面都可以定制以满足 <strong>您</strong> 的需求。由于 IdentityServer 是一个框架，而不是盒装产品或 SaaS，您可以编写代码来调整系统，使其适合您的场景。</div>
</div>
<div class="line-block">
<div class="line"><strong>成熟的开源</strong></div>
<div class="line">IdentityServer 使用许可的 <a class="reference external" href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2</a> 许可证，允许在其上构建商业产品。</div>
<div class="line">它也是 <a class="reference external" href="https://dotnetfoundation.org/">.NET 基金会</a> 的一部分，提供治理和法律支持。</div>
</div>
<div class="line-block">
<div class="line"><strong>免费和商业支持</strong></div>
<div class="line">如果您需要帮助构建或运行您的身份平台，<a class="reference internal" href="index.html#refsupport"><span class="std std-ref">请告诉我们</span></a> 。我们可以通过多种方式帮助您。</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-intro/big_picture"></span><div class="section" id="id1">
<h2>大图<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>大多数现代应用程序看起来或多或少是这样的：</p>
<img alt="_images/appArch.png" src="_images/appArch.png" />
<p>最常见的交互是：</p>
<ul class="simple">
<li><p>浏览器与 Web 应用程序通信</p></li>
<li><p>Web 应用程序与 Web API 通信（有时是自己通信，有时是代表用户通信）</p></li>
<li><p>基于浏览器的应用程序与 Web API 通信</p></li>
<li><p>原生应用程序与 Web API 通信</p></li>
<li><p>基于服务器的应用程序与 Web API 通信</p></li>
<li><p>Web API 与 Web API 通信（有时是自己通信，有时是代表用户通信）</p></li>
</ul>
<p>通常，每一层（前端、中间层和后端）都必须保护资源并实施身份验证和/或授权 —— 通常针对同一个用户存储。</p>
<p>将这些基本的安全功能外包给安全令牌服务可以防止在这些应用程序和端点之间复制该功能。</p>
<p>重构应用程序以支持安全令牌服务会导致以下架构和协议：</p>
<img alt="_images/protocols.png" src="_images/protocols.png" />
<p>这样的设计将安全问题分为两部分：</p>
<div class="section" id="id2">
<h3>验证<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>当应用程序需要知道当前用户的身份时，就需要进行身份验证。
通常，这些应用程序代表该用户管理数据，并且需要确保该用户只能访问他被允许访问的数据。
最常见的例子是（典型的）Web 应用程序 – 但是原生和基于 JS 的应用程序也需要身份验证。</p>
<p>最常见的身份验证协议是 SAML2p、WS-Federation 和 OpenID Connect —— SAML2p 是最流行和最广泛部署的。</p>
<p>OpenID Connect 是三者中最新的，但被认为是未来，因为它在现代应用程序中最有潜力。它从一开始就是为移动应用场景而构建的，旨在对 API 友好。</p>
</div>
<div class="section" id="api">
<h3>API 访问<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h3>
<p>应用程序有两种与 API 通信的基本方式 – 使用应用程序标识，
或委托用户的身份。有时需要将这两种方法结合起来。</p>
<p>OAuth2 是一种允许应用程序从安全令牌服务请求访问令牌并使用它们与 API 通信的协议。这种委托降低了客户端应用程序和 API 的复杂性，因为身份验证和授权可以集中。</p>
</div>
<div class="section" id="openid-connect-oauth-2-0">
<h3>OpenID Connect 和 OAuth 2.0 – 更好地结合在一起<a class="headerlink" href="#openid-connect-oauth-2-0" title="永久链接至标题">¶</a></h3>
<p>OpenID Connect 和 OAuth 2.0 非常相似 – 事实上，OpenID Connect 是 OAuth 2.0 之上的扩展。
两个基本的安全问题，身份验证和 API 访问，被组合成一个单一的协议 - 通常与安全令牌服务的单次往返。</p>
<p>我们相信 OpenID Connect 和 OAuth 2.0 的结合是在可预见的未来保护现代应用程序的最佳方法。IdentityServer4 是这两种协议的一个实现，并且经过高度优化，可以解决当今移动、原生和 Web 应用程序的典型安全问题。</p>
</div>
<div class="section" id="identityserver4">
<h3>IdentityServer4 如何提供帮助<a class="headerlink" href="#identityserver4" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 是将符合规范的 OpenID Connect 和 OAuth 2.0 端点添加到任意 ASP.NET Core 应用程序的中间件。</p>
<p>通常，您构建（或重用）一个包含登录和注销页面的应用程序（可能还包含同意页面 - 取决于您的需求），并且 IdentityServer 中间件向其中添加了必要的协议头，以便客户端应用程序可以使用那些标准协议与之对话。</p>
<img alt="_images/middleware.png" src="_images/middleware.png" />
<p>托管应用程序可以任意复杂，但我们通常建议通过仅包含与身份验证相关的 UI 来尽可能地减少攻击面。</p>
</div>
</div>
<span id="document-intro/terminology"></span><div class="section" id="id1">
<h2>术语<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>规范、文档和对象模型使用了一些您应该了解的术语。</p>
<img alt="_images/terminology.png" src="_images/terminology.png" />
<div class="section" id="identityserver">
<h3>IdentityServer<a class="headerlink" href="#identityserver" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 是一个 OpenID Connect 提供者 —— 它实现了 OpenID Connect 和 OAuth 2.0 协议。</p>
<p>不同的文献对同一角色使用不同的术语 —— 您可能还会发现安全令牌服务、身份提供者、授权服务器、IP-STS 等。</p>
<p>但简而言之，它们是一个向客户端发行安全令牌的软件。</p>
<p>IdentityServer 有许多作业和功能 —— 包括：</p>
<ul class="simple">
<li><p>保护您的资源</p></li>
<li><p>使用本地帐户存储或通过外部身份提供商对用户进行身份验证</p></li>
<li><p>提供会话管理和单点登录</p></li>
<li><p>管理和验证客户端</p></li>
<li><p>向客户端颁发身份和访问令牌</p></li>
<li><p>验证令牌</p></li>
</ul>
</div>
<div class="section" id="user">
<h3>User<a class="headerlink" href="#user" title="永久链接至标题">¶</a></h3>
<p>用户是使用已注册客户端访问资源的人。</p>
</div>
<div class="section" id="client">
<h3>Client<a class="headerlink" href="#client" title="永久链接至标题">¶</a></h3>
<p>客户端是一个从 IdentityServer 请求令牌的软件 —— 用于验证用户（请求身份令牌）或访问资源（请求访问令牌）。客户端必须先向 IdentityServer 注册，然后才能请求令牌。</p>
<p>客户端示例包括 Web 应用程序、原生移动或桌面应用程序、SPA、服务器进程等。</p>
</div>
<div class="section" id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="永久链接至标题">¶</a></h3>
<p>资源是您想要使用 IdentityServer 保护的东西 —— 您的用户的身份数据或 API。</p>
<p>每个资源都有一个唯一的名称 —— 客户端使用这个名称来指定他们想要访问哪些资源。</p>
<p><strong>Identity data</strong>
关于用户的身份信息（又名 claim 声明），例如 姓名或电子邮件地址。</p>
<p><strong>APIs</strong>
APIs 资源代表客户端想要调用的功能 —— 通常建模为 Web API，但不一定。</p>
</div>
<div class="section" id="identity-token">
<h3>Identity Token<a class="headerlink" href="#identity-token" title="永久链接至标题">¶</a></h3>
<p>身份令牌代表身份验证过程的结果。
它至少包含用户的标识符（称为“sub”，又名 subject claim 主题声明）以及有关用户如何以及何时进行身份验证的信息。
它可以包含额外的身份数据。</p>
</div>
<div class="section" id="access-token">
<h3>Access Token<a class="headerlink" href="#access-token" title="永久链接至标题">¶</a></h3>
<p>访问令牌允许访问 API 资源。
客户端请求访问令牌并将它们转发到 API。
访问令牌包含有关客户端和用户（如果存在）的信息。
API 使用该信息来授权对其数据的访问。</p>
</div>
</div>
<span id="document-intro/specs"></span><div class="section" id="id1">
<h2>支持的规范<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 实现了以下规范：</p>
<div class="section" id="openid-connect">
<h3>OpenID Connect<a class="headerlink" href="#openid-connect" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>OpenID Connect Core 1.0 (<a class="reference external" href="http://openid.net/specs/openid-connect-core-1_0.html">spec</a>)</p></li>
<li><p>OpenID Connect Discovery 1.0 (<a class="reference external" href="http://openid.net/specs/openid-connect-discovery-1_0.html">spec</a>)</p></li>
<li><p>OpenID Connect RP-Initiated Logout 1.0 - draft 01 (<a class="reference external" href="https://openid.net/specs/openid-connect-rpinitiated-1_0.html">spec</a>)</p></li>
<li><p>OpenID Connect Session Management 1.0 - draft 30 (<a class="reference external" href="http://openid.net/specs/openid-connect-session-1_0.html">spec</a>)</p></li>
<li><p>OpenID Connect Front-Channel Logout 1.0 - draft 04 (<a class="reference external" href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">spec</a>)</p></li>
<li><p>OpenID Connect Back-Channel Logout 1.0 - draft 06 (<a class="reference external" href="https://openid.net/specs/openid-connect-backchannel-1_0.html">spec</a>)</p></li>
</ul>
</div>
<div class="section" id="oauth-2-0">
<h3>OAuth 2.0<a class="headerlink" href="#oauth-2-0" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>OAuth 2.0 (<a class="reference external" href="http://tools.ietf.org/html/rfc6749">RFC 6749</a>)</p></li>
<li><p>OAuth 2.0 Bearer Token Usage (<a class="reference external" href="http://tools.ietf.org/html/rfc6750">RFC 6750</a>)</p></li>
<li><p>OAuth 2.0 Multiple Response Types (<a class="reference external" href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">spec</a>)</p></li>
<li><p>OAuth 2.0 Form Post Response Mode (<a class="reference external" href="http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html">spec</a>)</p></li>
<li><p>OAuth 2.0 Token Revocation (<a class="reference external" href="https://tools.ietf.org/html/rfc7009">RFC 7009</a>)</p></li>
<li><p>OAuth 2.0 Token Introspection (<a class="reference external" href="https://tools.ietf.org/html/rfc7662">RFC 7662</a>)</p></li>
<li><p>Proof Key for Code Exchange (<a class="reference external" href="https://tools.ietf.org/html/rfc7636">RFC 7636</a>)</p></li>
<li><p>JSON Web Tokens for Client Authentication (<a class="reference external" href="https://tools.ietf.org/html/rfc7523">RFC 7523</a>)</p></li>
<li><p>OAuth 2.0 Device Authorization Grant (<a class="reference external" href="https://tools.ietf.org/html/rfc8628">RFC 8628</a>)</p></li>
<li><p>OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens (<a class="reference external" href="https://tools.ietf.org/html/rfc8705">RFC 8705</a>)</p></li>
<li><p>JWT Secured Authorization Request (<a class="reference external" href="https://tools.ietf.org/html/draft-ietf-oauth-jwsreq">draft</a>)</p></li>
</ul>
</div>
</div>
<span id="document-intro/packaging"></span><div class="section" id="id1">
<h2>打包和构建<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 由许多 nuget 包组成。</p>
<div class="section" id="identityserver4">
<h3>IdentityServer4 主仓库<a class="headerlink" href="#identityserver4" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://github.com/identityserver/IdentityServer4">github</a></p>
<p>包含核心 IdentityServer 对象模型、服务和中间件以及 EntityFramework 和 ASP.NET Identity 集成。</p>
<p>nugets:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.nuget.org/packages/IdentityServer4/">IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.EntityFramework">IdentityServer4.EntityFramework</a></p></li>
<li><p><a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.AspNetIdentity">IdentityServer4.AspNetIdentity</a></p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>快速入门用户界面<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">github</a></p>
<p>包含一个简单的入门 UI，包括登录、注销和同意页面。</p>
</div>
<div class="section" id="id5">
<h3>访问令牌验证处理程序<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.AccessTokenValidation">nuget</a> | <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.AccessTokenValidation">github</a></p>
<p>用于验证 API 中的令牌的 ASP.NET Core 身份验证处理程序。处理程序允许在同一 API 中同时支持 JWT 和引用令牌。</p>
</div>
<div class="section" id="id7">
<h3>模板<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.Templates">nuget</a> | <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Templates">github</a></p>
<p>包含 dotnet CLI 的模板。</p>
</div>
<div class="section" id="id10">
<h3>开发版本<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>此外，我们将 CI 构建发布到我们的包存储库。
将以下 <code class="docutils literal notranslate"><span class="pre">nuget.config</span></code> 添加到您的项目中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;?</span><span class="n">xml</span> <span class="n">version</span><span class="p">=</span><span class="s">&quot;1.0&quot;</span> <span class="n">encoding</span><span class="p">=</span><span class="s">&quot;utf-8&quot;</span><span class="p">?&gt;</span>
    <span class="p">&lt;</span><span class="n">configuration</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">packageSources</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="n">clear</span> <span class="p">/&gt;</span>
            <span class="p">&lt;</span><span class="k">add</span> <span class="n">key</span><span class="p">=</span><span class="s">&quot;IdentityServer CI&quot;</span> <span class="k">value</span><span class="p">=</span><span class="s">&quot;https://www.myget.org/F/identity/api/v3/index.json&quot;</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="n">packageSources</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">configuration</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-intro/support"></span><div class="section" id="id1">
<h2>支持和咨询选项<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>我们为 IdentityServer 提供了多种免费和商业支持和咨询选项。</p>
<div class="section" id="id2">
<h3>免费支持<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>免费支持基于社区并使用公共论坛。</p>
<p><strong>StackOverflow</strong></p>
<p>越来越多的人使用 IdentityServer 来监控 StackOverflow 上的问题。
如果时间允许，我们也会尽量回答问题。</p>
<p>您可以使用此订阅源订阅所有与 IdentityServer4 相关的问题：</p>
<p><a class="reference external" href="https://stackoverflow.com/questions/tagged/?tagnames=identityserver4&amp;sort=newest">https://stackoverflow.com/questions/tagged/?tagnames=identityserver4&amp;sort=newest</a></p>
<p>提出新问题时请使用“IdentityServer4”标签。</p>
<p><strong>Gitter</strong></p>
<p>您可以在我们的 Gitter 聊天室中与其他 IdentityServer4 用户聊天：</p>
<p><a class="reference external" href="https://gitter.im/IdentityServer/IdentityServer4">https://gitter.im/IdentityServer/IdentityServer4</a></p>
<p><strong>报告Bug</strong></p>
<p>如果您认为您发现了bug或意外行为，请在 Github <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/issues">问题跟踪器</a> 上打开一个问题(issue)。
我们会尽快回复您。请理解我们也有日常工作，可能太忙而无法立即回复。</p>
<p>在发布之前，还需检查 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/dev/CONTRIBUTING.md">贡献</a> 指南。</p>
</div>
<div class="section" id="id5">
<h3>商业支持<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>我们正在围绕身份和访问控制架构进行咨询、指导和定制软件开发，特别是 IdentityServer。
请 <a class="reference external" href="mailto:contact&#37;&#52;&#48;identityserver&#46;io">与我们联系</a>，讨论可能的选择。</p>
<p><strong>训练</strong></p>
<p>我们定期举办有关现代应用程序的身份和访问控制的研讨会。
在 <a class="reference external" href="https://identityserver.io/training">这里</a> 查看议程和即将到来的公开日期。
我们也可以在贵公司私下进行培训。
<a class="reference external" href="mailto:contact&#37;&#52;&#48;identityserver&#46;io">联系我们</a> 请求现场培训。</p>
<p><strong>AdminUI、WS-Federation、SAML2p 和 FIDO2 支持</strong></p>
<p>我们的合作伙伴 Rock Solid Knowledge 在 <a class="reference external" href="https://www.identityserver.com/products">identityserver.com</a> 上提供了商业附加产品。</p>
</div>
</div>
<span id="document-intro/test"></span><div class="section" id="id1">
<h2>演示服务器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>您可以使用自己喜欢的客户端库尝试 IdentityServer4。 我们在 <a class="reference external" href="https://demo.identityserver.io">demo.identityserver.io</a> 有一个测试实例。
在主页上，您可以找到有关如何配置客户端以及如何调用 API 的说明。</p>
</div>
<span id="document-intro/contributing"></span><div class="section" id="id1">
<h2>贡献<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>我们对社区贡献非常开放，但是您应该遵循一些指导方针，这样我们就可以毫不费力地处理这个问题。</p>
<div class="section" id="id2">
<h3>如何贡献？<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>最简单的贡献方式是打开一个问题(issue)并开始讨论。
然后我们可以决定是否以及如何实现功能或更改。
如果您应该提交带有代码更改的拉取请求(pull request)，请从描述开始，只进行最小的更改并提供涵盖这些更改的测试。</p>
<p>另请先阅读：<a class="reference external" href="https://hackernoon.com/being-a-good-open-source-citizen-9060d0ab9732#.x3hocgw85">成为一个优秀的开源公民</a></p>
</div>
<div class="section" id="id4">
<h3>一般反馈和讨论？<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>请在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/issues">核心仓库问题跟踪器</a> 上开始讨论。</p>
</div>
<div class="section" id="bugs">
<h3>Bugs和功能请求？<a class="headerlink" href="#bugs" title="永久链接至标题">¶</a></h3>
<p>请在相应的 GitHub 存储库中记录新问题：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/IdentityServer/IdentityServer4">Core</a></p></li>
<li><p><a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.AccessTokenValidation">AccessTokenValidation</a></p></li>
</ul>
</div>
<div class="section" id="id6">
<h3>贡献代码和内容<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>您需要先签署贡献者许可协议，然后才能贡献任何代码或内容。
这是一个自动化过程，将在您打开拉取请求后开始。</p>
</div>
<div class="section" id="id7">
<h3>贡献项目<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>如果您开始贡献项目（例如支持数据库 X 或配置存储 Y），我们将非常感谢。
将它告诉我们，以便我们可以在我们的文档中发布和链接它。</p>
<p>我们通常不想拥有这些贡献库的所有权，我们已经非常忙于支持核心项目。</p>
<p><strong>命名约定</strong></p>
<p>截至 2017 年 10 月，IdentityServer4.* nuget 命名空间已为我们的包保留。请使用以下命名约定：</p>
<p><code class="docutils literal notranslate"><span class="pre">YourProjectName.IdentityServer4</span></code></p>
<p>或者</p>
<p><code class="docutils literal notranslate"><span class="pre">IdentityServer4.Contrib.YourProjectName</span></code></p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-quickstarts/0_overview"></span><div class="section" id="id1">
<h2>概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>快速入门为各种常见的 IdentityServer 场景提供了分步说明。
他们从绝对的基础开始，然后变得更加复杂 ——
建议您按顺序进行。</p>
<ul class="simple">
<li><p>将 IdentityServer 添加到 ASP.NET Core 应用程序</p></li>
<li><p>配置 IdentityServer</p></li>
<li><p>为各种客户端颁发令牌</p></li>
<li><p>保护 Web 应用程序和 API</p></li>
<li><p>添加对基于 EntityFramework 的配置的支持</p></li>
<li><p>添加对 ASP.NET Identity 的支持</p></li>
</ul>
<p>每个快速入门都有一个参考解决方案 —— 您可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/samples/Quickstarts">samples</a> 文件夹中找到代码。</p>
<div class="section" id="id2">
<h3>准备工作<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>您应该做的第一件事是安装我们的模板:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">new</span> <span class="p">-</span><span class="n">i</span> <span class="n">IdentityServer4</span><span class="p">.</span><span class="n">Templates</span>
</pre></div>
</div>
<p>它们将用作各种教程的起点。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您使用私有 NuGet 源，请不要忘记添加 –nuget-source 参数: –nuget-source <a class="reference external" href="https://api.nuget.org/v3/index.json">https://api.nuget.org/v3/index.json</a></p>
</div>
<p>OK —— 让我们开始吧！</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>快速入门针对 IdentityServer 4.x and ASP.NET Core 3.1.x —— 还有 <a class="reference external" href="http://docs.identityserver.io/en/aspnetcore2/quickstarts/0_overview.html">ASP.NET Core 2</a> 和 <a class="reference external" href="http://docs.identityserver.io/en/aspnetcore1/quickstarts/0_overview.html">ASP.NET Core 1</a> 的快速入门.</p>
</div>
</div>
</div>
<span id="document-quickstarts/1_client_credentials"></span><div class="section" id="api">
<h2>使用客户端凭据保护 API<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h2>
<p>以下 Identity Server 4 快速入门提供了各种常见 IdentityServer 方案的分步说明。
这些从绝对的基础开始，随着它们的进展变得更加复杂。 我们建议您按顺序进行操作。</p>
<p>要查看完整列表，请转到 <a class="reference external" href="https://identityserver4.readthedocs.io/en/latest/quickstarts/0_overview.html">IdentityServer4 快速入门概述</a> 。</p>
<p>第一个快速入门是使用 IdentityServer 保护 API 的最基本场景。
在本快速入门中，您将定义一个 API 和一个用于访问它的客户端。
客户端将使用其客户端 ID 和密钥从身份服务器请求访问令牌，然后使用该令牌获得对 API 的访问权限。</p>
<div class="section" id="id1">
<h3>源代码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>与所有这些快速入门一样，您可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/samples">IdentityServer4</a> 存储库中找到它的源代码。 本快速入门的项目是 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/samples/Quickstarts/1_ClientCredentials">快速入门 #1: 使用客户端凭据保护 API</a> 。</p>
</div>
<div class="section" id="id4">
<h3>准备工作<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>dotnet CLI 的 IdentityServer 模板是快速入门的良好起点。
要安装模板，请打开控制台窗口并键入以下命令:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">new</span> <span class="p">-</span><span class="n">i</span> <span class="n">IdentityServer4</span><span class="p">.</span><span class="n">Templates</span>
</pre></div>
</div>
<p>它们将用作各种教程的起点。</p>
</div>
<div class="section" id="asp-net-core">
<h3>设置 ASP.NET Core 应用程序<a class="headerlink" href="#asp-net-core" title="永久链接至标题">¶</a></h3>
<p>首先为应用程序创建一个目录 —— 然后使用我们的模板创建一个包含基本 IdentityServer 设置的 ASP.NET Core 应用程序，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">md</span> <span class="n">quickstart</span>
<span class="n">cd</span> <span class="n">quickstart</span>

<span class="n">md</span> <span class="n">src</span>
<span class="n">cd</span> <span class="n">src</span>

<span class="n">dotnet</span> <span class="k">new</span> <span class="n">is4empty</span> <span class="p">-</span><span class="n">n</span> <span class="n">IdentityServer</span>
</pre></div>
</div>
<p>这将创建以下文件:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IdentityServer.csproj</span></code> —— 项目文件和 <code class="docutils literal notranslate"><span class="pre">Properties\launchSettings.json</span></code> 文件</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Program.cs</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Startup.cs</span></code> —— 主应用程序入口点</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Config.cs</span></code> —— IdentityServer 资源和客户端配置文件</p></li>
</ul>
<p>您现在可以使用您喜欢的文本编辑器来编辑或查看文件。 如果你想有 Visual Studio 支持，你可以添加这样的解决方案文件:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">..</span>
<span class="n">dotnet</span> <span class="k">new</span> <span class="n">sln</span> <span class="p">-</span><span class="n">n</span> <span class="n">Quickstart</span>
</pre></div>
</div>
<p>并让它添加您的 IdentityServer 项目（记住这个命令，因为我们将在下面创建其他项目）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>dotnet sln add .\src\IdentityServer\IdentityServer.csproj
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>此模板中使用的协议是 <code class="docutils literal notranslate"><span class="pre">https</span></code>，在 Kestrel 上运行时端口设置为 5001 或在 IISExpress 上运行时设置为随机端口。 您可以在 <code class="docutils literal notranslate"><span class="pre">Properties\launchSettings.json</span></code> 文件中更改它。 对于生产场景，您应该始终使用 <code class="docutils literal notranslate"><span class="pre">https</span></code>。</p>
</div>
</div>
<div class="section" id="api-scope">
<h3>定义 API Scope<a class="headerlink" href="#api-scope" title="永久链接至标题">¶</a></h3>
<p>API 是系统中要保护的资源。
资源定义可以通过多种方式加载，您用于创建上述项目的模板显示了如何使用“代码即配置”方法。</p>
<p>已经为您创建了 Config.cs。 打开它，更新代码看起来像这样:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Config</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span> <span class="n">ApiScopes</span> <span class="p">=&gt;</span>
        <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;My API&quot;</span><span class="p">)</span>
        <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/samples/Quickstarts/1_ClientCredentials/src/IdentityServer/Config.cs">这里</a> 查看完整的文件).</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您将在生产中使用它，那么为您的 API 提供一个逻辑名称很重要。 开发人员将使用它通过您的身份服务器连接到您的 api。 它应该用简单的术语向开发人员和用户描述您的 api。</p>
</div>
</div>
<div class="section" id="id6">
<h3>定义客户端<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>下一步是定义一个客户端应用程序，我们将使用它来访问我们的新 API。</p>
<p>对于这种情况，客户端将没有交互式用户，而是使用 IdentityServer 的所谓的客户端密钥进行身份验证。</p>
<p>为此，添加客户端定义:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span> <span class="n">Clients</span> <span class="p">=&gt;</span>
    <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="n">Client</span>
        <span class="p">{</span>
            <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>

            <span class="c1">// 没有交互式用户，使用 clientid/secret 进行身份验证</span>
            <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>

            <span class="c1">// 用于身份验证的密钥</span>
            <span class="n">ClientSecrets</span> <span class="p">=</span>
            <span class="p">{</span>
                <span class="k">new</span> <span class="nf">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span>
            <span class="p">},</span>

            <span class="c1">// 客户端有权访问的范围</span>
            <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
</pre></div>
</div>
<p>您可以将 ClientId 和 ClientSecret 视为应用程序本身的登录名和密码。
向身份服务器标识您的应用程序，以便它知道哪个应用程序正在尝试连接到它。</p>
</div>
<div class="section" id="identityserver">
<h3>配置 IdentityServer<a class="headerlink" href="#identityserver" title="永久链接至标题">¶</a></h3>
<p>加载资源和客户端定义发生在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/samples/Quickstarts/1_ClientCredentials/src/IdentityServer/Startup.cs">Startup.cs</a> 中 —— 将代码更新为如下所示:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
        <span class="p">.</span><span class="n">AddDeveloperSigningCredential</span><span class="p">()</span>        <span class="c1">//这仅适用于没有证书可以使用的开发场景。</span>
        <span class="p">.</span><span class="n">AddInMemoryApiScopes</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">)</span>
        <span class="p">.</span><span class="n">AddInMemoryClients</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">Clients</span><span class="p">);</span>

    <span class="c1">// 为简洁起见省略</span>
<span class="p">}</span>
</pre></div>
</div>
<p>就是这样 —— 现在应该配置您的身份服务器。 如果您运行服务器并将浏览器导航到 <code class="docutils literal notranslate"><span class="pre">https://localhost:5001/.well-known/openid-configuration</span></code> ，您应该会看到所谓的发现文档。
发现文档是身份服务器中的标准端点。  您的客户端和 API 将使用发现文档来下载必要的配置数据。</p>
<img alt="_images/1_discovery.png" src="_images/1_discovery.png" />
<p>在第一次启动时，IdentityServer 会为你创建一个开发者签名密钥，它是一个名为 <code class="docutils literal notranslate"><span class="pre">tempkey.jwk</span></code> 的文件。
您不必将该文件签入您的源代码管理，如果它不存在，它将被重新创建。</p>
</div>
<div class="section" id="id7">
<h3>添加 API<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>接下来，向您的解决方案添加 API。</p>
<p>您可以使用 Visual Studio 中的 ASP.NET Core Web API 模板，也可以使用 .NET CLI 来创建 API 项目，就像我们在此处所做的那样。
从 <code class="docutils literal notranslate"><span class="pre">src</span></code> 文件夹中运行以下命令:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">new</span> <span class="n">webapi</span> <span class="p">-</span><span class="n">n</span> <span class="n">Api</span>
</pre></div>
</div>
<p>然后通过运行以下命令将其添加到解决方案中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>cd ..
dotnet sln add .\src\Api\Api.csproj
</pre></div>
</div>
<p>将 API 应用程序配置为仅在 <code class="docutils literal notranslate"><span class="pre">https://localhost:6001</span></code> 上运行。 您可以通过编辑 Properties 文件夹中的 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/samples/Quickstarts/1_ClientCredentials/src/Api/Properties/launchSettings.json">launchSettings.json</a> 文件来完成此操作。 将应用程序 URL 设置更改为:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;applicationUrl&quot;</span><span class="p">:</span> <span class="s">&quot;https://localhost:6001&quot;</span>
</pre></div>
</div>
<div class="section" id="id8">
<h4>控制器<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>添加一个名为 <code class="docutils literal notranslate"><span class="pre">IdentityController</span></code> 的新类:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Route(&quot;identity&quot;)]</span>
<span class="na">[Authorize]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">IdentityController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
<span class="p">{</span>
<span class="na">    [HttpGet]</span>
    <span class="k">public</span> <span class="n">IActionResult</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">JsonResult</span><span class="p">(</span><span class="k">from</span> <span class="n">c</span> <span class="k">in</span> <span class="n">User</span><span class="p">.</span><span class="n">Claims</span> <span class="k">select</span> <span class="k">new</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">Type</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Value</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此控制器稍后将用于测试授权需求，以及通过 API 的眼睛可视化声明身份。</p>
</div>
<div class="section" id="nuget">
<h4>添加 Nuget 依赖项<a class="headerlink" href="#nuget" title="永久链接至标题">¶</a></h4>
<p>为了使配置步骤工作，必须添加 nuget 包依赖项，在根目录中运行此命令:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>dotnet add .\\src\\api\\Api.csproj package Microsoft.AspNetCore.Authentication.JwtBearer
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>配置<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>最后一步是将身份验证服务添加到 DI（依赖注入）并将身份验证中间件添加到管道中。
这些将:</p>
<ul class="simple">
<li><p>验证传入的令牌以确保它来自受信任的发行者</p></li>
<li><p>验证令牌是否有效与此 API 一起使用（又名 audience 受众）</p></li>
</ul>
<p>将 <cite>Startup</cite> 更新为如下所示:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">AddControllers</span><span class="p">();</span>

        <span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="s">&quot;Bearer&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">AddJwtBearer</span><span class="p">(</span><span class="s">&quot;Bearer&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://localhost:5001&quot;</span><span class="p">;</span>

                <span class="n">options</span><span class="p">.</span><span class="n">TokenValidationParameters</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TokenValidationParameters</span>
                <span class="p">{</span>
                    <span class="n">ValidateAudience</span> <span class="p">=</span> <span class="k">false</span>
                <span class="p">};</span>
            <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">app</span><span class="p">.</span><span class="n">UseRouting</span><span class="p">();</span>

        <span class="n">app</span><span class="p">.</span><span class="n">UseAuthentication</span><span class="p">();</span>
        <span class="n">app</span><span class="p">.</span><span class="n">UseAuthorization</span><span class="p">();</span>

        <span class="n">app</span><span class="p">.</span><span class="n">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">endpoints</span><span class="p">.</span><span class="n">MapControllers</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AddAuthentication</span></code> 将身份验证服务添加到 DI 并将 <code class="docutils literal notranslate"><span class="pre">Bearer</span></code> 配置为默认方案。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseAuthentication</span></code> 将身份验证中间件添加到管道中，因此每次调用主机时都会自动执行身份验证。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseAuthorization</span></code> 添加授权中间件以确保匿名客户端无法访问我们的 API 端点。</p></li>
</ul>
<p>在浏览器上导航到控制器 <code class="docutils literal notranslate"><span class="pre">https://localhost:6001/identity</span></code> 应该返回 401 状态代码。
这意味着您的 API 需要凭证并且现在受 IdentityServer 保护。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您想知道为什么上面的代码禁用了受众验证，请查看 <a class="reference internal" href="index.html#refresources"><span class="std std-ref">这里</span></a> 以获得更深入的讨论。</p>
</div>
</div>
</div>
<div class="section" id="id10">
<h3>创建客户端<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>最后一步是编写一个请求访问令牌的客户端，然后使用此令牌访问 API。 为此，在您的解决方案中添加一个控制台项目，记住在 <code class="docutils literal notranslate"><span class="pre">src</span></code> 中创建它:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">new</span> <span class="n">console</span> <span class="p">-</span><span class="n">n</span> <span class="n">Client</span>
</pre></div>
</div>
<p>然后和以前一样，使用:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>cd ..
dotnet sln add .\src\Client\Client.csproj
</pre></div>
</div>
<p>IdentityServer 上的令牌端点实现了 OAuth 2.0 协议，您可以使用原始 HTTP 来访问它。
但是，我们有一个名为 IdentityModel 的客户端库，它将协议交互封装在一个易于使用的 API 中。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">IdentityModel</span></code> NuGet 包添加到您的客户端。
这可以通过 Visual Studio 的 Nuget 包管理器或 dotnet CLI 完成:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">src</span>
<span class="n">cd</span> <span class="n">client</span>
<span class="n">dotnet</span> <span class="k">add</span> <span class="n">package</span> <span class="n">IdentityModel</span>
</pre></div>
</div>
<p>IdentityModel 包括一个与发现端点一起使用的客户端库。 这样你只需要知道 IdentityServer 的基地址 - 可以从元数据中读取实际的端点地址:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 从元数据中发现端点</span>
<span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">disco</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetDiscoveryDocumentAsync</span><span class="p">(</span><span class="s">&quot;https://localhost:5001&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您在连接时遇到错误，则可能是您正在运行 <cite>https</cite> 并且 <code class="docutils literal notranslate"><span class="pre">localhost</span></code> 的开发证书不受信任。 您可以运行 <code class="docutils literal notranslate"><span class="pre">dotnet</span> <span class="pre">dev-certs</span> <span class="pre">https</span> <span class="pre">--trust</span></code> 以信任开发证书。 这只需要做一次。</p>
</div>
<p>接下来，您可以使用发现文档中的信息向 IdentityServer 请求令牌以访问 <code class="docutils literal notranslate"><span class="pre">api1</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 请求令牌</span>
<span class="kt">var</span> <span class="n">tokenResponse</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">RequestClientCredentialsTokenAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">ClientCredentialsTokenRequest</span>
<span class="p">{</span>
    <span class="n">Address</span> <span class="p">=</span> <span class="n">disco</span><span class="p">.</span><span class="n">TokenEndpoint</span><span class="p">,</span>

    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
    <span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">,</span>
    <span class="n">Scope</span> <span class="p">=</span> <span class="s">&quot;api1&quot;</span>
<span class="p">});</span>

<span class="k">if</span> <span class="p">(</span><span class="n">tokenResponse</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tokenResponse</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tokenResponse</span><span class="p">.</span><span class="n">Json</span><span class="p">);</span>
</pre></div>
</div>
<p>（完整文件可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/samples/Quickstarts/1_ClientCredentials/src/Client/Program.cs">这里</a> 找到）</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>将访问令牌从控制台复制并粘贴到 <a class="reference external" href="https://jwt.ms">jwt.ms</a> 以检查原始令牌。</p>
</div>
</div>
<div class="section" id="id12">
<h3>调用 API<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>要将访问令牌发送到 API，您通常使用 HTTP 授权标头。 这是使用 <code class="docutils literal notranslate"><span class="pre">SetBearerToken</span></code> 扩展方法完成的:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 调用api</span>
<span class="kt">var</span> <span class="n">apiClient</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
<span class="n">apiClient</span><span class="p">.</span><span class="n">SetBearerToken</span><span class="p">(</span><span class="n">tokenResponse</span><span class="p">.</span><span class="n">AccessToken</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="k">await</span> <span class="n">apiClient</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s">&quot;https://localhost:6001/identity&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(!</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">StatusCode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="k">await</span> <span class="n">response</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="n">ReadAsStringAsync</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">JArray</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">content</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>（如果您在 Visual Studio 中，您可以右键单击解决方案并选择“多个启动项目”，并确保 Api 和 IdentityServer 将启动；然后运行解决方案；之后，要逐步执行客户端代码，您可以右键单击“客户端”项目并选择 调试… 启动新实例）。
输出应该是这样的:</p>
<img alt="_images/1_client_screenshot.png" src="_images/1_client_screenshot.png" />
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>默认情况下，访问令牌将包含有关范围、生命周期（nbf 和 exp）、客户端 ID (client_id) 和颁发者名称 (iss) 的声明。</p>
</div>
</div>
<div class="section" id="id13">
<h3>API 授权<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>现在，API 接受您的身份服务器颁发的任何访问令牌。</p>
<p>在下文中，我们将添加允许检查范围是否存在于客户端请求（并被授权）的访问令牌中的代码。
为此，我们将使用 ASP.NET Core 授权策略系统。 将以下内容添加到 <code class="docutils literal notranslate"><span class="pre">Startup</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 方法中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthorization</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">AddPolicy</span><span class="p">(</span><span class="s">&quot;ApiScope&quot;</span><span class="p">,</span> <span class="n">policy</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">policy</span><span class="p">.</span><span class="n">RequireAuthenticatedUser</span><span class="p">();</span>
        <span class="n">policy</span><span class="p">.</span><span class="n">RequireClaim</span><span class="p">(</span><span class="s">&quot;scope&quot;</span><span class="p">,</span> <span class="s">&quot;api1&quot;</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>您现在可以在各个级别执行此策略，例如</p>
<ul class="simple">
<li><p>全局</p></li>
<li><p>对于所有 API 端点</p></li>
<li><p>对特定的 controllers/actions</p></li>
</ul>
<p>通常，您为路由系统中的所有 API 端点设置策略:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="n">MapControllers</span><span class="p">()</span>
        <span class="p">.</span><span class="n">RequireAuthorization</span><span class="p">(</span><span class="s">&quot;ApiScope&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>进一步的实验<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>本演练重点介绍了迄今为止的成功路径</p>
<ul class="simple">
<li><p>客户端能够请求令牌</p></li>
<li><p>客户端可以使用令牌访问 API</p></li>
</ul>
<p>您现在可以尝试引发错误以了解系统的行为方式，例如</p>
<ul class="simple">
<li><p>尝试在 IdentityServer 未运行时连接到它（不可用）</p></li>
<li><p>尝试使用无效的客户端 ID 或机密来请求令牌</p></li>
<li><p>尝试在令牌请求期间请求无效范围</p></li>
<li><p>尝试在未运行时调用 API（不可用）</p></li>
<li><p>不要将令牌发送到 API</p></li>
<li><p>将 API 配置为需要与令牌中的范围不同的范围</p></li>
</ul>
</div>
</div>
<span id="document-quickstarts/2_interactive_aspnetcore"></span><div class="section" id="asp-net-core">
<h2>使用 ASP.NET Core 的交互式应用程序<a class="headerlink" href="#asp-net-core" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>对于任何先决条件（例如模板），请先查看 <a class="reference internal" href="index.html#refquickstartoverview"><span class="std std-ref">overview</span></a>。</p>
</div>
<p>在本快速入门中，我们希望通过 OpenID Connect 协议向我们在上一章中构建的 IdentityServer 添加对交互式用户身份验证的支持。</p>
<p>一旦到位，我们将创建一个 MVC 应用程序，该应用程序将使用 IdentityServer 进行身份验证。</p>
<div class="section" id="id1">
<h3>添加用户界面<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>OpenID Connect 所需的所有协议支持都已内置到 IdentityServer 中。
您需要为登录、注销、同意和错误提供必要的 UI 部分。</p>
<p>虽然每个 IdentityServer 实现的外观和感觉以及确切的工作流程可能总是有所不同，但我们提供了一个基于 MVC 的示例 UI，您可以将其用作起点。</p>
<p>这个 UI 可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/tree/main">Quickstart UI 仓库</a> 中找到。
您可以克隆或下载此存储库并将控制器、视图、模型和 CSS 放入您的 IdentityServer Web 应用程序中。</p>
<p>或者，您可以使用 .NET CLI（从 <code class="docutils literal notranslate"><span class="pre">src/IdentityServer</span></code> 文件夹中运行）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">new</span> <span class="n">is4ui</span>
</pre></div>
</div>
<p>添加 MVC UI 后，您还需要在 DI 系统和管道中启用 MVC。
当您查看 <code class="docutils literal notranslate"><span class="pre">Startup.cs</span></code> 时，您会发现 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Configure</span></code> 方法中的注释告诉您如何启用 MVC。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>还有一个名为 <code class="docutils literal notranslate"><span class="pre">is4inmem</span></code> 的模板，它结合了包括标准 UI 在内的基本 IdentityServer。</p>
</div>
<p>运行 IdentityServer 应用程序，您现在应该会看到一个主页。</p>
<p>花一些时间检查控制器和模型 —— 特别是 <code class="docutils literal notranslate"><span class="pre">AccountController</span></code> ，它是主要的 UI 入口点。
您对它们理解得越好，将来进行修改就越容易。
大多数代码使用“功能文件夹”样式位于 “Quickstart” 文件夹中。
如果这种风格不适合您，请随意以您想要的任何方式组织代码。</p>
</div>
<div class="section" id="mvc">
<h3>创建 MVC 客户端<a class="headerlink" href="#mvc" title="永久链接至标题">¶</a></h3>
<p>接下来，您将创建一个 MVC 应用程序。
为此使用 ASP.NET Core “Web 应用程序”（即 MVC）模板。</p>
<p>从 src 文件夹运行:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>dotnet new mvc -n MvcClient
cd ..
dotnet sln add .\src\MvcClient\MvcClient.csproj
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>我们建议通过 IIS Express 使用自托管选项。 其余文档假设您在端口 5002 上使用自托管。</p>
</div>
<p>要向 MVC 应用程序添加对 OpenID Connect 身份验证的支持，您首先需要将包含 OpenID Connect 处理程序的 nuget 包添加到您的项目中，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">add</span> <span class="n">package</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">AspNetCore</span><span class="p">.</span><span class="n">Authentication</span><span class="p">.</span><span class="n">OpenIdConnect</span>
</pre></div>
</div>
<p>..然后将以下内容添加到 <code class="docutils literal notranslate"><span class="pre">Startup</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System.IdentityModel.Tokens.Jwt</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="n">JwtSecurityTokenHandler</span><span class="p">.</span><span class="n">DefaultMapInboundClaims</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

<span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">DefaultScheme</span> <span class="p">=</span> <span class="s">&quot;Cookies&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">DefaultChallengeScheme</span> <span class="p">=</span> <span class="s">&quot;oidc&quot;</span><span class="p">;</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="n">AddCookie</span><span class="p">(</span><span class="s">&quot;Cookies&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;oidc&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://localhost:5001&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mvc&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ResponseType</span> <span class="p">=</span> <span class="s">&quot;code&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">SaveTokens</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AddAuthentication</span></code> 将身份验证服务添加到 DI。</p>
<p>我们使用 cookie 在本地登录用户（通过 <code class="docutils literal notranslate"><span class="pre">&quot;Cookies&quot;</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">DefaultScheme</span></code>），
我们将 <code class="docutils literal notranslate"><span class="pre">DefaultChallengeScheme</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">oidc</span></code>，因为当我们需要 用户登录，我们将使用 OpenID Connect 协议。</p>
<p>然后我们使用 <code class="docutils literal notranslate"><span class="pre">AddCookie</span></code> 来添加可以处理 cookie 的处理程序。</p>
<p>最后，<code class="docutils literal notranslate"><span class="pre">AddOpenIdConnect</span></code> 用于配置执行 OpenID Connect 协议的处理程序。
<code class="docutils literal notranslate"><span class="pre">Authority</span></code> 指示可信令牌服务所在的位置。
然后我们通过 <code class="docutils literal notranslate"><span class="pre">ClientId</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ClientSecret</span></code> 来识别这个客户端。
<code class="docutils literal notranslate"><span class="pre">SaveTokens</span></code> 用于将来自 IdentityServer 的令牌持久保存在 cookie 中（因为稍后将需要它们）。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>我们使用所谓的 <code class="docutils literal notranslate"><span class="pre">授权码(authorization</span> <span class="pre">code)</span></code> 流程与 PKCE 连接到 OpenID Connect 提供程序。 有关协议流的更多信息，请参见 <a class="reference internal" href="index.html#refgranttypes"><span class="std std-ref">这里</span></a>。</p>
</div>
<p>然后为了确保在每个请求上执行身份验证服务，将 <code class="docutils literal notranslate"><span class="pre">UseAuthentication</span></code> 添加到 <code class="docutils literal notranslate"><span class="pre">Startup</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">Configure</span></code></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">UseStaticFiles</span><span class="p">();</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseRouting</span><span class="p">();</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseAuthentication</span><span class="p">();</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseAuthorization</span><span class="p">();</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="n">MapDefaultControllerRoute</span><span class="p">()</span>
        <span class="p">.</span><span class="n">RequireAuthorization</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">RequireAuthorization</span></code> 方法禁用对整个应用程序的匿名访问。</p>
</div>
<p>如果您想在每个控制器或操作方法的基础上指定授权，您还可以使用 <code class="docutils literal notranslate"><span class="pre">[Authorize]</span></code> 属性。</p>
<p>还要修改主页视图以显示用户的声明以及 cookie 属性:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">@using</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">AspNetCore</span><span class="p">.</span><span class="n">Authentication</span>

<span class="p">&lt;</span><span class="n">h2</span><span class="p">&gt;</span><span class="n">Claims</span><span class="p">&lt;/</span><span class="n">h2</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">dl</span><span class="p">&gt;</span>
    <span class="n">@foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">claim</span> <span class="k">in</span> <span class="n">User</span><span class="p">.</span><span class="n">Claims</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">&lt;</span><span class="n">dt</span><span class="p">&gt;</span><span class="n">@claim</span><span class="p">.</span><span class="n">Type</span><span class="p">&lt;/</span><span class="n">dt</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">dd</span><span class="p">&gt;</span><span class="n">@claim</span><span class="p">.</span><span class="n">Value</span><span class="p">&lt;/</span><span class="n">dd</span><span class="p">&gt;</span>
    <span class="p">}</span>
<span class="p">&lt;/</span><span class="n">dl</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">h2</span><span class="p">&gt;</span><span class="n">Properties</span><span class="p">&lt;/</span><span class="n">h2</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">dl</span><span class="p">&gt;</span>
    <span class="n">@foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">prop</span> <span class="k">in</span> <span class="p">(</span><span class="k">await</span> <span class="n">Context</span><span class="p">.</span><span class="n">AuthenticateAsync</span><span class="p">()).</span><span class="n">Properties</span><span class="p">.</span><span class="n">Items</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">&lt;</span><span class="n">dt</span><span class="p">&gt;</span><span class="n">@prop</span><span class="p">.</span><span class="n">Key</span><span class="p">&lt;/</span><span class="n">dt</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">dd</span><span class="p">&gt;</span><span class="n">@prop</span><span class="p">.</span><span class="n">Value</span><span class="p">&lt;/</span><span class="n">dd</span><span class="p">&gt;</span>
    <span class="p">}</span>
<span class="p">&lt;/</span><span class="n">dl</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>如果您现在使用浏览器导航到应用程序，则会尝试重定向到 IdentityServer —— 这将导致错误，因为 MVC 客户端尚未注册。</p>
</div>
<div class="section" id="openid-connect">
<h3>添加对 OpenID Connect 身份范围的支持<a class="headerlink" href="#openid-connect" title="永久链接至标题">¶</a></h3>
<p>与 OAuth 2.0 类似，OpenID Connect 也使用范围(scopes)概念。
同样，范围代表您想要保护和客户端想要访问的东西。
与 OAuth 相比，OIDC 中的范围不代表 API，而是代表用户 ID、姓名或电子邮件地址等身份数据。</p>
<p>通过修改 <code class="docutils literal notranslate"><span class="pre">Config.cs</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">IdentityResources</span></code> 属性，添加对标准 <code class="docutils literal notranslate"><span class="pre">openid</span></code> （subject id）和 <code class="docutils literal notranslate"><span class="pre">profile</span></code> （名字、姓氏等）范围的支持:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span> <span class="n">IdentityResources</span> <span class="p">=&gt;</span>
    <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="n">IdentityResources</span><span class="p">.</span><span class="n">OpenId</span><span class="p">(),</span>
        <span class="k">new</span> <span class="n">IdentityResources</span><span class="p">.</span><span class="n">Profile</span><span class="p">(),</span>
    <span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">startup.cs</span></code> 中向 IdentityServer 注册身份资源:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddInMemoryIdentityResources</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">IdentityResources</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddInMemoryApiScopes</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddInMemoryClients</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">Clients</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>所有标准范围及其相应的声明都可以在 OpenID Connect <a class="reference external" href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">规范</a> 中找到。</p>
</div>
</div>
<div class="section" id="id3">
<h3>添加测试用户<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>示例 UI 还带有一个内存中的“用户数据库”。 您可以通过添加 <code class="docutils literal notranslate"><span class="pre">AddTestUsers</span></code> 扩展方法在 IdentityServer 中启用此功能:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddInMemoryIdentityResources</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">IdentityResources</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddInMemoryApiScopes</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddInMemoryClients</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">Clients</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddTestUsers</span><span class="p">(</span><span class="n">TestUsers</span><span class="p">.</span><span class="n">Users</span><span class="p">);</span>
</pre></div>
</div>
<p>当您导航到 <code class="docutils literal notranslate"><span class="pre">TestUsers</span></code> 类时，您可以看到定义了两个名为 <code class="docutils literal notranslate"><span class="pre">alice</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 的用户以及一些身份声明。
您可以使用这些用户登录。</p>
</div>
<div class="section" id="mvc-identityserver">
<h3>将 MVC 客户端添加到 IdentityServer 配置<a class="headerlink" href="#mvc-identityserver" title="永久链接至标题">¶</a></h3>
<p>最后一步是将 MVC 客户端的新配置条目添加到 IdentityServer。</p>
<p>基于 OpenID Connect 的客户端与我们目前添加的 OAuth 2.0 客户端非常相似。
但由于 OIDC 中的流程始终是交互式的，我们需要在配置中添加一些重定向 URL。</p>
<p>客户端列表应如下所示:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span> <span class="n">Clients</span> <span class="p">=&gt;</span>
    <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">// 机器到机器客户端（来自快速入门 1 开始）</span>
        <span class="k">new</span> <span class="n">Client</span>
        <span class="p">{</span>
            <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
            <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

            <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
            <span class="c1">// 客户端有权访问的范围</span>
            <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span> <span class="p">}</span>
        <span class="p">},</span>
        <span class="c1">// 交互式 ASP.NET Core MVC 客户端</span>
        <span class="k">new</span> <span class="n">Client</span>
        <span class="p">{</span>
            <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mvc&quot;</span><span class="p">,</span>
            <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

            <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>

            <span class="c1">// 登录后重定向到哪里</span>
            <span class="n">RedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signin-oidc&quot;</span> <span class="p">},</span>

            <span class="c1">// 注销后重定向到哪里</span>
            <span class="n">PostLogoutRedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signout-callback-oidc&quot;</span> <span class="p">},</span>

            <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
            <span class="p">{</span>
                <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">OpenId</span><span class="p">,</span>
                <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Profile</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>测试客户端<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>现在，新的 MVC 客户端的一切都应该就绪了。</p>
<p>通过导航到受保护的控制器操作来触发身份验证握手。
您应该会看到重定向到 IdentityServer 的登录页面。</p>
<img alt="_images/3_login.png" src="_images/3_login.png" />
<p>之后，IdentityServer 将重定向回 MVC 客户端，在那里 OpenID Connect 身份验证处理程序处理响应，并通过设置 cookie 在本地登录用户。
最后，MVC 视图将显示 cookie 的内容。</p>
<img alt="_images/3_claims.png" src="_images/3_claims.png" />
<p>如您所见，cookie 有两部分，用户的声明和一些元数据。 此元数据还包含 IdentityServer 发布的原始令牌。
随意将此令牌复制到 <a class="reference external" href="https://jwt.ms">jwt.ms</a> 以检查其内容。</p>
</div>
<div class="section" id="id5">
<h3>添加注销<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>最后一步是向 MVC 客户端添加注销。</p>
<p>使用 IdentityServer 这样的身份验证服务，仅清除本地应用程序 cookie 是不够的。
此外，您还需要往返 IdentityServer 以清除中央单点登录会话。</p>
<p>确切的协议步骤在 OpenID Connect 处理程序中实现，
只需将以下代码添加到某个控制器即可触发注销:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="n">IActionResult</span> <span class="nf">Logout</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">SignOut</span><span class="p">(</span><span class="s">&quot;Cookies&quot;</span><span class="p">,</span> <span class="s">&quot;oidc&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这将清除本地 cookie，然后重定向到 IdentityServer。
IdentityServer 将清除其 cookie，然后为用户提供一个链接以返回到 MVC 应用程序。</p>
</div>
<div class="section" id="userinfo">
<h3>从 UserInfo 端点获取声明<a class="headerlink" href="#userinfo" title="永久链接至标题">¶</a></h3>
<p>您可能已经注意到，即使我们已将客户端配置为允许检索 <code class="docutils literal notranslate"><span class="pre">profile</span></code> 身份范围，与该范围关联的声明（例如 <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">family_name</span></code>, <code class="docutils literal notranslate"><span class="pre">website</span></code> 等）不会出现在返回的令牌中。
我们需要告诉客户端应用程序，通过指定需要访问的范围并设置 <code class="docutils literal notranslate"><span class="pre">GetClaimsFromUserInfoEndpoint</span></code> 选项，来从 <a class="reference external" href="https://identityserver4.readthedocs.io/en/latest/endpoints/userinfo.html">UserInfo</a> 端点中提取剩余声明。
在以下示例中，我们请求的是 <code class="docutils literal notranslate"><span class="pre">profile</span></code> 范围，但它可以是客户端有权访问的任何范围（或多个范围）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;oidc&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;profile&quot;</span><span class="p">);</span>
    <span class="n">options</span><span class="p">.</span><span class="n">GetClaimsFromUserInfoEndpoint</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>
</div>
<p>重新启动客户端应用程序、注销并重新登录后，您应该会看到与页面上显示的 <code class="docutils literal notranslate"><span class="pre">profile</span></code> 身份范围关联的其他用户声明。</p>
<img alt="_images/3_additional_claims.png" src="_images/3_additional_claims.png" />
</div>
<div class="section" id="id7">
<h3>进一步的实验<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>随意向测试用户添加更多声明 —— 以及更多身份资源。</p>
<p>定义身份资源的过程如下:</p>
<ul>
<li><p>将新的身份资源添加到列表中 —— 为其命名并指定在请求此资源时应返回哪些声明</p></li>
<li><p>通过客户端配置上的 <code class="docutils literal notranslate"><span class="pre">AllowedScopes</span></code> 属性让客户端访问资源</p></li>
<li><p>通过将资源添加到客户端中 OpenID Connect 处理程序配置的 <code class="docutils literal notranslate"><span class="pre">Scopes</span></code> 集合来请求资源</p></li>
<li><p>（可选）如果身份资源与非标准声明（例如 <code class="docutils literal notranslate"><span class="pre">myclaim1</span></code>）相关联，则在客户端添加 JSON 中出现的声明（从 UserInfo 端点返回）和用户 <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.claims.claim">声明</a> 之间的 <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.openidconnect.openidconnectoptions.claimactions?view=aspnetcore-3.0">ClaimAction</a> 映射</p>
<blockquote>
<div><p>using Microsoft.AspNetCore.Authentication
// …
.AddOpenIdConnect(“oidc”, options =&gt;
{</p>
<blockquote>
<div><p>// …
options.ClaimActions.MapUniqueJsonKey(“myclaim1”, “myclaim1”);
// …</p>
</div></blockquote>
<p>});</p>
</div></blockquote>
</li>
</ul>
<p>同样值得注意的是，令牌声明的检索是一个扩展点 —— <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code>。
由于我们使用的是 <code class="docutils literal notranslate"><span class="pre">AddTestUsers</span></code>，因此默认使用 <code class="docutils literal notranslate"><span class="pre">TestUserProfileService</span></code>。
您可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/blob/main/src/IdentityServer4/src/Test/TestUserProfileService.cs">此处</a> 检查源代码以了解其工作原理。</p>
</div>
<div class="section" id="id10">
<h3>添加对外部身份验证的支持<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>接下来，我们将添加对外部身份验证的支持。
这真的很简单，因为您真正需要的只是一个与 ASP.NET Core 兼容的身份验证处理程序。</p>
<p>ASP.NET Core 本身支持 Google、Facebook、Twitter、Microsoft Account 和 OpenID Connect。
此外，您可以在 <a class="reference external" href="https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers">此处</a> 找到许多其他身份验证提供程序的实现。</p>
</div>
<div class="section" id="google">
<h3>添加 Google 支持<a class="headerlink" href="#google" title="永久链接至标题">¶</a></h3>
<p>为了能够使用 Google 进行身份验证，您首先需要向他们注册。
这是在他们的开发人员 <a class="reference external" href="https://console.developers.google.com/">控制台</a> 上完成的。
创建一个新项目，启用 Google+ API ，并通过将 <em>/signin-google</em> 路径添加到您的基地址（例如 <a class="reference external" href="https://localhost:5001/signin-google">https://localhost:5001/signin-google</a>）来配置您本地 IdentityServer 的回调地址。</p>
<p>开发者控制台将向您显示由 Google 发布的客户端ID和密码 —— 下一步你会用到的。</p>
<p>将 Google 身份验证处理程序添加到 IdentityServer 主机的 DI。
首先添加 <code class="docutils literal notranslate"><span class="pre">Microsoft.AspNetCore.Authentication.Google</span></code> nuget包，然后将此代码段添加到 <code class="docutils literal notranslate"><span class="pre">Startup</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddGoogle</span><span class="p">(</span><span class="s">&quot;Google&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;&lt;在此处插入&gt;&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;&lt;在此处插入&gt;&quot;</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>默认情况下，IdentityServer 专门为外部身份验证的结果配置 cookie 处理程序（使用基于常量 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.ExternalCookieAuthenticationScheme</span></code> 的方案）。
Google 处理程序的配置将使用该 cookie 处理程序。</p>
<p>现在运行 MVC 客户端并尝试进行身份验证 —— 您将在登录页面上看到一个 Google 按钮:</p>
<img alt="_images/4_login_page.png" src="_images/4_login_page.png" />
<p>在使用MVC客户端进行身份验证之后，您可以看到这些声明现在来自 Google 数据。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您对在登录页面上自动呈现 Google 按钮的魔法感兴趣，请检查 <code class="docutils literal notranslate"><span class="pre">AccountController</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">BuildLoginViewModel</span></code> 方法。</p>
</div>
</div>
<div class="section" id="id13">
<h3>进一步的实验<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>您可以添加额外的外部提供程序。
我们有一个 <a class="reference external" href="https://demo.identityserver.io">云托管演示</a> 版本的 IdentityServer4，您可以使用 OpenID Connect 进行集成。</p>
<p>将 OpenId Connect 处理程序添加到 DI:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddGoogle</span><span class="p">(</span><span class="s">&quot;Google&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;&lt;在此处插入&gt;&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;&lt;在此处插入&gt;&quot;</span><span class="p">;</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;oidc&quot;</span><span class="p">,</span> <span class="s">&quot;Demo IdentityServer&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignOutScheme</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">SignoutScheme</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SaveTokens</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://demo.identityserver.io/&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;interactive.confidential&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ResponseType</span> <span class="p">=</span> <span class="s">&quot;code&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">TokenValidationParameters</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TokenValidationParameters</span>
        <span class="p">{</span>
            <span class="n">NameClaimType</span> <span class="p">=</span> <span class="s">&quot;name&quot;</span><span class="p">,</span>
            <span class="n">RoleClaimType</span> <span class="p">=</span> <span class="s">&quot;role&quot;</span>
        <span class="p">};</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>现在，用户应该能够使用云托管的演示身份提供程序。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>快速入门 UI 自动配置外部用户。 当外部用户第一次登录时，会创建一个新的本地用户，所有外部声明都被复制并与新用户关联。 但是，您处理这种情况的方式完全取决于您。 也许您想先显示一些注册 UI。 可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">这里</a> 找到默认快速入门的源代码。 可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/blob/main/Quickstart/Account/ExternalController.cs">此处</a> 找到执行自动配置的控制器。</p>
</div>
</div>
</div>
<span id="document-quickstarts/3_aspnetcore_and_apis"></span><div class="section" id="asp-net-core-api">
<h2>ASP.NET Core 和 API 访问<a class="headerlink" href="#asp-net-core-api" title="永久链接至标题">¶</a></h2>
<p>在之前的快速入门中，我们探讨了 API 访问和用户身份验证。
现在我们想把这两个部分放在一起。</p>
<p>OpenID Connect 和 OAuth 2.0 结合的美妙之处在于，您可以通过单个协议和与令牌服务的单个交换来实现。</p>
<p>到目前为止，我们只在令牌请求期间请求身份资源，一旦我们开始包括 API 资源，IdentityServer 将返回两个令牌：
包含身份验证和会话信息的身份令牌，以及代表登录用户访问 API 的访问令牌。</p>
<div class="section" id="id1">
<h3>修改客户端配置<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>在 IdentityServer 中更新客户端配置很简单 —— 我们只需要将 <code class="docutils literal notranslate"><span class="pre">api1</span></code> 资源添加到允许的范围列表中。
此外，我们通过 <code class="docutils literal notranslate"><span class="pre">AllowOfflineAccess</span></code> 属性启用对刷新令牌的支持:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mvc&quot;</span><span class="p">,</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>

    <span class="c1">// 登录后重定向到哪里</span>
    <span class="n">RedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signin-oidc&quot;</span> <span class="p">},</span>

    <span class="c1">// 注销后重定向到哪里</span>
    <span class="n">PostLogoutRedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signout-callback-oidc&quot;</span> <span class="p">},</span>

    <span class="n">AllowOfflineAccess</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">OpenId</span><span class="p">,</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Profile</span><span class="p">,</span>
        <span class="s">&quot;api1&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mvc">
<h3>修改MVC客户端<a class="headerlink" href="#mvc" title="永久链接至标题">¶</a></h3>
<p>现在客户端要做的就是通过 scope 参数请求额外的资源。 这是在 OpenID Connect 处理程序配置中完成的:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">DefaultScheme</span> <span class="p">=</span> <span class="s">&quot;Cookies&quot;</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">DefaultChallengeScheme</span> <span class="p">=</span> <span class="s">&quot;oidc&quot;</span><span class="p">;</span>
<span class="p">})</span>
    <span class="p">.</span><span class="n">AddCookie</span><span class="p">(</span><span class="s">&quot;Cookies&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;oidc&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://localhost:5001&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mvc&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ResponseType</span> <span class="p">=</span> <span class="s">&quot;code&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">SaveTokens</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;api1&quot;</span><span class="p">);</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;offline_access&quot;</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>由于启用了 <code class="docutils literal notranslate"><span class="pre">SaveTokens</span></code>，ASP.NET Core 将自动将结果访问和刷新令牌存储在身份验证会话中。
您应该能够检查打印出您之前创建的会话内容的页面上的数据。</p>
</div>
<div class="section" id="id2">
<h3>使用访问令牌<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>您可以使用可以在 <code class="docutils literal notranslate"><span class="pre">Microsoft.AspNetCore.Authentication</span></code> 命名空间中找到的标准 ASP.NET Core 扩展方法 来访问会话中的令牌:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">accessToken</span> <span class="p">=</span> <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">GetTokenAsync</span><span class="p">(</span><span class="s">&quot;access_token&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>要使用访问令牌访问 API，您需要做的就是检索令牌，并将其设置在您的 HttpClient 上:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="n">CallApi</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">accessToken</span> <span class="p">=</span> <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">GetTokenAsync</span><span class="p">(</span><span class="s">&quot;access_token&quot;</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
    <span class="n">client</span><span class="p">.</span><span class="n">DefaultRequestHeaders</span><span class="p">.</span><span class="n">Authorization</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AuthenticationHeaderValue</span><span class="p">(</span><span class="s">&quot;Bearer&quot;</span><span class="p">,</span> <span class="n">accessToken</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="s">&quot;https://localhost:6001/identity&quot;</span><span class="p">);</span>

    <span class="n">ViewBag</span><span class="p">.</span><span class="n">Json</span> <span class="p">=</span> <span class="n">JArray</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">content</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">View</span><span class="p">(</span><span class="s">&quot;json&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>创建一个名为 json.cshtml 的视图，输出如下所示的 json:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;</span><span class="n">@ViewBag</span><span class="p">.</span><span class="n">Json</span><span class="p">&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>确保 API 正在运行，启动 MVC 客户端并在身份验证后调用 <code class="docutils literal notranslate"><span class="pre">/home/CallApi</span></code> 。</p>
</div>
<div class="section" id="id3">
<h3>管理访问令牌<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>到目前为止，典型客户端最复杂的任务是管理访问令牌。 你通常想要</p>
<ul class="simple">
<li><p>在登录时请求访问和刷新令牌</p></li>
<li><p>缓存这些令牌</p></li>
<li><p>使用访问令牌调用 API，直到它过期</p></li>
<li><p>使用刷新令牌获取新的访问令牌</p></li>
<li><p>重新开始</p></li>
</ul>
<p>ASP.NET Core 有许多内置工具可以帮助您完成这些任务（如缓存或 sessions），但仍有很多工作要做。
随意看看 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel.AspNetCore">这个</a> 库，它可以自动执行许多样板任务。</p>
</div>
</div>
<span id="document-quickstarts/4_javascript_client"></span><div class="section" id="javascript">
<h2>添加 JavaScript 客户端<a class="headerlink" href="#javascript" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>对于任何先决条件（例如模板），请先查看 <a class="reference internal" href="index.html#refquickstartoverview"><span class="std std-ref">概述</span></a>。</p>
</div>
<p>本快速入门将展示如何构建基于浏览器的 JavaScript 客户端应用程序（有时称为“单页应用程序”或”<cite>SPA</cite>”）。</p>
<p>用户将登录到 IdentityServer，使用 IdentityServer 颁发的访问令牌调用 Web API，然后注销 IdentityServer。
所有这一切都将由在浏览器中运行的 JavaScript 驱动。</p>
<div class="section" id="id1">
<h3>新的 JavaScript 客户端项目<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>为 JavaScript 应用程序创建一个新项目。
它可以只是一个空的 Web 项目、一个空的 ASP.NET Core 应用程序或其他类似 Node.js 的应用程序。
本快速入门将使用 ASP.NET Core 应用程序。</p>
<p>在 <cite>~/src</cite> 目录中创建一个新的 “Empty” ASP.NET Core Web 应用程序。
您可以使用 Visual Studio 或从命令行执行此操作:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">md</span> <span class="n">JavaScriptClient</span>
<span class="n">cd</span> <span class="n">JavaScriptClient</span>
<span class="n">dotnet</span> <span class="k">new</span> <span class="n">web</span>
</pre></div>
</div>
<p>正如我们之前所做的那样，对于其他客户端项目，也将此项目添加到您的解决方案中。 从包含 sln 文件的根文件夹运行它:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>dotnet sln add .\src\JavaScriptClient\JavaScriptClient.csproj
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>修改托管<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>修改 <cite>JavaScriptClient</cite> 项目以在 <a class="reference external" href="https://localhost:5003">https://localhost:5003</a> 上运行。</p>
</div>
<div class="section" id="id3">
<h3>添加静态文件中间件<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>鉴于此项目旨在运行客户端，我们需要 ASP.NET Core 做的就是提供构成我们应用程序的静态 HTML 和 JavaScript 文件。
静态文件中间件就是为此而设计的。</p>
<p>在 <cite>Startup.cs</cite> 中的 <cite>Configure</cite> 方法中注册静态文件中间件（同时删除其他所有内容）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseDefaultFiles</span><span class="p">();</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseStaticFiles</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个中间件现在将从应用程序的 <cite>~/wwwroot</cite> 文件夹中提供静态文件。
这是我们将放置 HTML 和 JavaScript 文件的地方。
如果您的项目中不存在该文件夹，请立即创建它。</p>
</div>
<div class="section" id="oidc-client">
<h3>引用 oidc-client<a class="headerlink" href="#oidc-client" title="永久链接至标题">¶</a></h3>
<p>在之前基于 ASP.NET Core MVC 的客户端项目的快速入门之一中，我们使用了一个库来处理 OpenID Connect 协议。
在 JavaScriptClient 项目的这个快速入门中，我们需要一个类似的库，一个只在 JavaScript 中工作并设计为在浏览器中运行的库。
<a class="reference external" href="https://github.com/IdentityModel/oidc-client-js">oidc-client 库</a> 就是这样的一个库。
它可以通过 <a class="reference external" href="https://github.com/IdentityModel/oidc-client-js">NPM</a>， <a class="reference external" href="https://bower.io/search/?q=oidc-client">Bower</a>，以及从 github 的 <a class="reference external" href="https://github.com/IdentityModel/oidc-client-js/tree/release/dist">直接下载</a> 获得。</p>
<p><strong>NPM</strong></p>
<p>如果你想使用 NPM 下载 <cite>oidc-client</cite>，那么从你的 <cite>JavaScriptClient</cite> 项目目录运行这些命令:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>npm i oidc-client
copy node_modules\oidc-client\dist\* wwwroot
</pre></div>
</div>
<p>这会在本地下载最新的 <cite>oidc-client</cite> 包，然后将相关的 JavaScript 文件复制到 <cite>~/wwwroot</cite> 中，以便您的应用程序提供它们。</p>
<p><strong>手动下载</strong></p>
<p>如果您只想手动下载 <cite>oidc-client</cite> JavaScript 文件，请浏览到 <a class="reference external" href="https://github.com/IdentityModel/oidc-client-js/tree/release/dist">GitHub 存储库</a> 并下载 JavaScript 文件。 下载后，将它们复制到 <cite>~/wwwroot</cite> 中，以便您的应用程序提供它们。</p>
</div>
<div class="section" id="html-javascript">
<h3>添加您的 HTML 和 JavaScript 文件<a class="headerlink" href="#html-javascript" title="永久链接至标题">¶</a></h3>
<p>接下来是将您的 HTML 和 JavaScript 文件添加到 <cite>~/wwwroot</cite>。
我们将有两个 HTML 文件和一个特定于应用程序的 JavaScript 文件（除了 <cite>oidc-client.js</cite> 库）。
在 <cite>~/wwwroot</cite> 中，添加名为 <cite>index.html</cite> 和 <cite>callback.html</cite> 的 HTML 文件，并添加名为 <cite>app.js</cite> 的 JavaScript 文件。</p>
<p><strong>index.html</strong></p>
<p>这将是您的应用程序的主页。
它将只包含用于用户登录、注销和调用 Web API 的按钮的 HTML。
它还将包含 <code class="docutils literal notranslate"><span class="pre">&lt;script&gt;</span></code> 标签以包含我们的两个 JavaScript 文件。
它还将包含一个 <code class="docutils literal notranslate"><span class="pre">&lt;pre&gt;</span></code> 用于向用户显示消息。</p>
<p>它应该是这样的:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;!</span><span class="n">DOCTYPE</span> <span class="n">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">meta</span> <span class="n">charset</span><span class="p">=</span><span class="s">&quot;utf-8&quot;</span> <span class="p">/&gt;</span>
    <span class="p">&lt;</span><span class="n">title</span><span class="p">&gt;&lt;/</span><span class="n">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">button</span> <span class="n">id</span><span class="p">=</span><span class="s">&quot;login&quot;</span><span class="p">&gt;</span><span class="n">Login</span><span class="p">&lt;/</span><span class="n">button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">button</span> <span class="n">id</span><span class="p">=</span><span class="s">&quot;api&quot;</span><span class="p">&gt;</span><span class="n">Call</span> <span class="n">API</span><span class="p">&lt;/</span><span class="n">button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">button</span> <span class="n">id</span><span class="p">=</span><span class="s">&quot;logout&quot;</span><span class="p">&gt;</span><span class="n">Logout</span><span class="p">&lt;/</span><span class="n">button</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="n">pre</span> <span class="n">id</span><span class="p">=</span><span class="s">&quot;results&quot;</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="n">script</span> <span class="n">src</span><span class="p">=</span><span class="s">&quot;oidc-client.js&quot;</span><span class="p">&gt;&lt;/</span><span class="n">script</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">script</span> <span class="n">src</span><span class="p">=</span><span class="s">&quot;app.js&quot;</span><span class="p">&gt;&lt;/</span><span class="n">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">html</span><span class="p">&gt;</span>
</pre></div>
</div>
<p><strong>app.js</strong></p>
<p>这将包含我们应用程序的主要代码。
首先是添加一个辅助函数来将消息记录到 <code class="docutils literal notranslate"><span class="pre">&lt;pre&gt;</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>function log() {
    document.getElementById(&#39;results&#39;).innerText = &#39;&#39;;

    Array.prototype.forEach.call(arguments, function (msg) {
        if (msg instanceof Error) {
            msg = &quot;Error: &quot; + msg.message;
        }
        else if (typeof msg !== &#39;string&#39;) {
            msg = JSON.stringify(msg, null, 2);
        }
        document.getElementById(&#39;results&#39;).innerHTML += msg + &#39;\r\n&#39;;
    });
}
</pre></div>
</div>
<p>接下来，添加代码以将 <code class="docutils literal notranslate"><span class="pre">click</span></code> 事件处理程序注册到三个按钮:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s">&quot;login&quot;</span><span class="p">).</span><span class="n">addEventListener</span><span class="p">(</span><span class="s">&quot;click&quot;</span><span class="p">,</span> <span class="n">login</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s">&quot;api&quot;</span><span class="p">).</span><span class="n">addEventListener</span><span class="p">(</span><span class="s">&quot;click&quot;</span><span class="p">,</span> <span class="n">api</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s">&quot;logout&quot;</span><span class="p">).</span><span class="n">addEventListener</span><span class="p">(</span><span class="s">&quot;click&quot;</span><span class="p">,</span> <span class="n">logout</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
</pre></div>
</div>
<p>接下来，我们可以使用 <cite>oidc-client</cite> 库中的 <cite>UserManager</cite> 类来管理 OpenID Connect 协议。
它需要MVC客户端中所必需的类似配置（尽管具有不同的值）。
添加此代码以配置和实例化 <code class="docutils literal notranslate"><span class="pre">UserManager</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="p">{</span>
    <span class="n">authority</span><span class="p">:</span> <span class="s">&quot;https://localhost:5001&quot;</span><span class="p">,</span>
    <span class="n">client_id</span><span class="p">:</span> <span class="s">&quot;js&quot;</span><span class="p">,</span>
    <span class="n">redirect_uri</span><span class="p">:</span> <span class="s">&quot;https://localhost:5003/callback.html&quot;</span><span class="p">,</span>
    <span class="n">response_type</span><span class="p">:</span> <span class="s">&quot;code&quot;</span><span class="p">,</span>
    <span class="n">scope</span><span class="p">:</span><span class="s">&quot;openid profile api1&quot;</span><span class="p">,</span>
    <span class="n">post_logout_redirect_uri</span> <span class="p">:</span> <span class="s">&quot;https://localhost:5003/index.html&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">var</span> <span class="n">mgr</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Oidc</span><span class="p">.</span><span class="n">UserManager</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
</pre></div>
</div>
<p>接下来，<code class="docutils literal notranslate"><span class="pre">UserManager</span></code> 提供了一个 <code class="docutils literal notranslate"><span class="pre">getUser</span></code> API 来了解用户是否已登录到 JavaScript 应用程序。
它使用 JavaScript <code class="docutils literal notranslate"><span class="pre">Promise</span></code> 异步返回结果。
返回的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象有一个 <code class="docutils literal notranslate"><span class="pre">profile</span></code> 属性，其中包含用户的声明。
添加此代码以检测用户是否登录到 JavaScript 应用程序:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">mgr</span><span class="p">.</span><span class="n">getUser</span><span class="p">().</span><span class="n">then</span><span class="p">(</span><span class="n">function</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">log</span><span class="p">(</span><span class="s">&quot;User logged in&quot;</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">profile</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">log</span><span class="p">(</span><span class="s">&quot;User not logged in&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>接下来，我们要实现 <code class="docutils literal notranslate"><span class="pre">login</span></code>、<code class="docutils literal notranslate"><span class="pre">api</span></code> 和 <code class="docutils literal notranslate"><span class="pre">logout</span></code> 函数。
<code class="docutils literal notranslate"><span class="pre">UserManager</span></code> 提供了一个 <code class="docutils literal notranslate"><span class="pre">signinRedirect</span></code> 来登录用户，和一个 <code class="docutils literal notranslate"><span class="pre">signoutRedirect</span></code> 来注销用户。
我们在上面的代码中获得的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象也有一个 <code class="docutils literal notranslate"><span class="pre">access_token</span></code> 属性，可用于对 Web API 进行身份验证。
<code class="docutils literal notranslate"><span class="pre">access_token</span></code> 将通过带有 <cite>Bearer</cite> 方案的 <cite>Authorization</cite> 标头传递给 Web API。
添加此代码以在我们的应用程序中实现这三个函数:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="nf">login</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mgr</span><span class="p">.</span><span class="n">signinRedirect</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">function</span> <span class="nf">api</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mgr</span><span class="p">.</span><span class="n">getUser</span><span class="p">().</span><span class="n">then</span><span class="p">(</span><span class="n">function</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="s">&quot;https://localhost:6001/identity&quot;</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">xhr</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XMLHttpRequest</span><span class="p">();</span>
        <span class="n">xhr</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
        <span class="n">xhr</span><span class="p">.</span><span class="n">onload</span> <span class="p">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="n">log</span><span class="p">(</span><span class="n">xhr</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="n">JSON</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">xhr</span><span class="p">.</span><span class="n">responseText</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">xhr</span><span class="p">.</span><span class="n">setRequestHeader</span><span class="p">(</span><span class="s">&quot;Authorization&quot;</span><span class="p">,</span> <span class="s">&quot;Bearer &quot;</span> <span class="p">+</span> <span class="n">user</span><span class="p">.</span><span class="n">access_token</span><span class="p">);</span>
        <span class="n">xhr</span><span class="p">.</span><span class="n">send</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="n">function</span> <span class="nf">logout</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mgr</span><span class="p">.</span><span class="n">signoutRedirect</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请参阅 <a class="reference internal" href="index.html#refclientcredentialsquickstart"><span class="std std-ref">客户端凭据快速入门</span></a> 以获取有关如何创建上述代码中使用的 api 的信息。</p>
</div>
<p><strong>callback.html</strong></p>
<p>一旦用户登录到 IdentityServer，这个 HTML 文件就是指定的 <code class="docutils literal notranslate"><span class="pre">redirect_uri</span></code> 页面。
它将完成与 IdentityServer 的 OpenID Connect 协议登录握手。
这一切的代码都是由我们之前使用的 <code class="docutils literal notranslate"><span class="pre">UserManager</span></code> 类提供的。
登录完成后，我们可以将用户重定向回主要的 <cite>index.html</cite> 页面。
添加此代码以完成登录过程:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;!</span><span class="n">DOCTYPE</span> <span class="n">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">meta</span> <span class="n">charset</span><span class="p">=</span><span class="s">&quot;utf-8&quot;</span> <span class="p">/&gt;</span>
    <span class="p">&lt;</span><span class="n">title</span><span class="p">&gt;&lt;/</span><span class="n">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="n">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">script</span> <span class="n">src</span><span class="p">=</span><span class="s">&quot;oidc-client.js&quot;</span><span class="p">&gt;&lt;/</span><span class="n">script</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">script</span><span class="p">&gt;</span>
        <span class="k">new</span> <span class="n">Oidc</span><span class="p">.</span><span class="n">UserManager</span><span class="p">({</span><span class="n">response_mode</span><span class="p">:</span><span class="s">&quot;query&quot;</span><span class="p">}).</span><span class="n">signinRedirectCallback</span><span class="p">().</span><span class="n">then</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">window</span><span class="p">.</span><span class="n">location</span> <span class="p">=</span> <span class="s">&quot;index.html&quot;</span><span class="p">;</span>
        <span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">console</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">&lt;/</span><span class="n">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">html</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="javascript-identityserver">
<h3>为 JavaScript 客户端向 IdentityServer 添加客户端注册<a class="headerlink" href="#javascript-identityserver" title="永久链接至标题">¶</a></h3>
<p>现在客户端应用程序已准备就绪，我们需要在 IdentityServer 中为这个新的 JavaScript 客户端定义一个配置条目。
在 IdentityServer 项目中找到客户端配置（在 <cite>Config.cs</cite> 中）。
为我们的新 JavaScript 应用程序，向列表中添加一个新的 <cite>Client</cite>。
它应该具有下面列出的配置:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// JavaScript 客户端</span>
<span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;js&quot;</span><span class="p">,</span>
    <span class="n">ClientName</span> <span class="p">=</span> <span class="s">&quot;JavaScript Client&quot;</span><span class="p">,</span>
    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>
    <span class="n">RequireClientSecret</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>

    <span class="n">RedirectUris</span> <span class="p">=</span>           <span class="p">{</span> <span class="s">&quot;https://localhost:5003/callback.html&quot;</span> <span class="p">},</span>
    <span class="n">PostLogoutRedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5003/index.html&quot;</span> <span class="p">},</span>
    <span class="n">AllowedCorsOrigins</span> <span class="p">=</span>     <span class="p">{</span> <span class="s">&quot;https://localhost:5003&quot;</span> <span class="p">},</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">OpenId</span><span class="p">,</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Profile</span><span class="p">,</span>
        <span class="s">&quot;api1&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cors-ajax-web-api">
<h3>使用 CORS 允许 Ajax 调用 Web API<a class="headerlink" href="#cors-ajax-web-api" title="永久链接至标题">¶</a></h3>
<p>必需的最后一点配置是在 Web API 项目中配置 CORS。
这将允许从 <cite>https://localhost:5003</cite> 到 <cite>https://localhost:6001</cite> 的 Ajax 调用。</p>
<p><strong>配置 CORS</strong></p>
<p>在  <cite>Startup.cs</cite> 的 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中将 CORS 服务添加到依赖注入系统中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddCors</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="c1">// 这定义了一个名为 ``default`` 的 CORS 策略</span>
        <span class="n">options</span><span class="p">.</span><span class="n">AddPolicy</span><span class="p">(</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">policy</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">policy</span><span class="p">.</span><span class="n">WithOrigins</span><span class="p">(</span><span class="s">&quot;https://localhost:5003&quot;</span><span class="p">)</span>
                <span class="p">.</span><span class="n">AllowAnyHeader</span><span class="p">()</span>
                <span class="p">.</span><span class="n">AllowAnyMethod</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">Configure</span></code> 中将 CORS 中间件添加到管道中（在路由之后）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseRouting</span><span class="p">();</span>

    <span class="n">app</span><span class="p">.</span><span class="n">UseCors</span><span class="p">(</span><span class="s">&quot;default&quot;</span><span class="p">);</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>运行 JavaScript 应用程序<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>现在您应该能够运行 JavaScript 客户端应用程序:</p>
<img alt="_images/jsclient_not_logged_in.png" src="_images/jsclient_not_logged_in.png" />
<p>单击 “Login” 按钮以登录用户。
一旦用户返回到 JavaScript 应用程序，您应该会看到他们的个人资料信息：</p>
<img alt="_images/jsclient_logged_in.png" src="_images/jsclient_logged_in.png" />
<p>然后单击 “API” 按钮调用 Web API：</p>
<img alt="_images/jsclient_api_results.png" src="_images/jsclient_api_results.png" />
<p>最后单击 “Logout” 将用户注销。</p>
<img alt="_images/jsclient_signed_out.png" src="_images/jsclient_signed_out.png" />
<p>您现在已经启动了一个 JavaScript 客户端应用程序，该应用程序使用 IdentityServer 进行登录、注销和验证对 Web API 的调用。</p>
</div>
</div>
<span id="document-quickstarts/5_entityframework"></span><div class="section" id="entityframework-core">
<h2>使用 EntityFramework Core 获取配置和操作数据<a class="headerlink" href="#entityframework-core" title="永久链接至标题">¶</a></h2>
<p>在之前的快速入门中，我们在代码中创建了客户端和范围数据。
在启动时，IdentityServer 将此配置数据加载到内存中。
如果我们想修改这个配置数据，我们必须停止和启动 IdentityServer。</p>
<p>IdentityServer 还会生成临时数据，例如授权码、同意选择和刷新令牌。
默认情况下，这些也存储在内存中。</p>
<p>要将这些数据移动到在重新启动和跨多个 IdentityServer 实例之间持久的数据库中，我们可以使用 IdentityServer4 Entity Framework 库。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>除了手动配置 EF 支持外，还有一个 IdentityServer 模板可以使用 <code class="docutils literal notranslate"><span class="pre">dotnet</span> <span class="pre">new</span> <span class="pre">is4ef</span></code> 创建一个支持 EF 的新项目。</p>
</div>
<div class="section" id="identityserver4-entityframework">
<h3>IdentityServer4.EntityFramework<a class="headerlink" href="#identityserver4-entityframework" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework</span></code> 使用以下 DbContext 实现所需的存储和服务：</p>
<blockquote>
<div><ul class="simple">
<li><p>ConfigurationDbContext —— 用于配置数据，例如客户端、资源和范围</p></li>
<li><p>PersistedGrantDbContext —— 用于临时操作数据，例如授权码和刷新令牌</p></li>
</ul>
</div></blockquote>
<p>这些 context 适用于任何 Entity Framework Core 兼容的关系数据库。</p>
<p>您可以在 <code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework.Storage</span></code> nuget 包中找到这些 context、它们的实体以及使用它们的 IdentityServer4 存储。</p>
<p>您可以在 <code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework</span></code> 中找到在您的 IdentityServer 中注册它们的扩展方法，我们现在将这样做:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">add</span> <span class="n">package</span> <span class="n">IdentityServer4</span><span class="p">.</span><span class="n">EntityFramework</span>
</pre></div>
</div>
</div>
<div class="section" id="sqlserver">
<h3>使用 SqlServer<a class="headerlink" href="#sqlserver" title="永久链接至标题">¶</a></h3>
<p>对于本快速入门，我们将使用 Visual Studio 附带的 SQLServer 的 LocalDb 版本。
要将 SQL Server 支持添加到我们的 IdentityServer 项目，您需要以下 nuget 包:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="k">add</span> <span class="n">package</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">EntityFrameworkCore</span><span class="p">.</span><span class="n">SqlServer</span>
</pre></div>
</div>
</div>
<div class="section" id="ef">
<h3>数据库架构更改和使用 EF 迁移<a class="headerlink" href="#ef" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework.Storage</span></code> 包包含从 IdentityServer 模型映射的实体类。
随着 IdentityServer 的模型发生变化， <code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework.Storage</span></code> 中的实体类也会发生变化。
当您使用 <code class="docutils literal notranslate"><span class="pre">IdentityServer4.EntityFramework.Storage</span></code> 并随着时间的推移升级时，您需要负责数据库架构以及随着实体类的更改而对该架构进行必要的更改。
管理这些更改的一种方法是使用 <a class="reference external" href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/index">EF迁移</a>，我们将在本快速入门中使用它。
如果迁移不是您的偏好，那么您可以用任何您认为合适的方式管理架构更改。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以在 IdentityServer4.EntityFramework.Storage 存储库中找到 SqlServer 的 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/src/EntityFramework.Storage/migrations/SqlServer/Migrations">最新 SQL 脚本</a>。</p>
</div>
</div>
<div class="section" id="id2">
<h3>配置存储<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>要开始使用这些存储，您需要在 <cite>Startup.cs</cite> 的 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 方法中使用 <code class="docutils literal notranslate"><span class="pre">AddConfigurationStore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddOperationalStore</span></code> 来替换对 <code class="docutils literal notranslate"><span class="pre">AddInMemoryClients</span></code>、<code class="docutils literal notranslate"><span class="pre">AddInMemoryIdentityResources</span></code>、<code class="docutils literal notranslate"><span class="pre">AddInMemoryApiScopes</span></code>、<code class="docutils literal notranslate"><span class="pre">AddInMemoryApiResources</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddInMemoryPersistedGrants</span></code> 的任何现有调用。</p>
<p>这些方法每个都需要一个 <code class="docutils literal notranslate"><span class="pre">DbContextOptionsBuilder</span></code>，这意味着你的代码看起来像这样:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">migrationsAssembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Startup</span><span class="p">).</span><span class="n">GetTypeInfo</span><span class="p">().</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetName</span><span class="p">().</span><span class="n">Name</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">string</span> <span class="n">connectionString</span> <span class="p">=</span> <span class="s">@&quot;Data Source=(LocalDb)\MSSQLLocalDB;database=IdentityServer4.Quickstart.EntityFramework-4.0.0;trusted_connection=yes;&quot;</span><span class="p">;</span>

<span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddTestUsers</span><span class="p">(</span><span class="n">TestUsers</span><span class="p">.</span><span class="n">Users</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddConfigurationStore</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ConfigureDbContext</span> <span class="p">=</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">,</span>
            <span class="n">sql</span> <span class="p">=&gt;</span> <span class="n">sql</span><span class="p">.</span><span class="n">MigrationsAssembly</span><span class="p">(</span><span class="n">migrationsAssembly</span><span class="p">));</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="n">AddOperationalStore</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ConfigureDbContext</span> <span class="p">=</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">,</span>
            <span class="n">sql</span> <span class="p">=&gt;</span> <span class="n">sql</span><span class="p">.</span><span class="n">MigrationsAssembly</span><span class="p">(</span><span class="n">migrationsAssembly</span><span class="p">));</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>您可能需要将这些命名空间添加到文件中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">Microsoft.EntityFrameworkCore</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
</pre></div>
</div>
<p>由于我们在本快速入门中使用 EF 迁移，因此调用 <code class="docutils literal notranslate"><span class="pre">MigrationsAssembly</span></code> 用于通知 Entity Framework 宿主项目将包含迁移代码。
这是必要的，因为宿主项目位于与包含 <code class="docutils literal notranslate"><span class="pre">DbContext</span></code> 类的程序集中不同的程序集中。</p>
</div>
<div class="section" id="id3">
<h3>添加迁移<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>一旦 IdentityServer 被配置为使用 Entity Framework，我们需要生成一些迁移。</p>
<p>要创建迁移，您需要在您的机器上安装 Entity Framework Core CLI，和在 IdentityServer 中安装 <code class="docutils literal notranslate"><span class="pre">Microsoft.EntityFrameworkCore.Design</span></code> nuget 包:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="n">tool</span> <span class="n">install</span> <span class="p">--</span><span class="n">global</span> <span class="n">dotnet</span><span class="p">-</span><span class="n">ef</span>
<span class="n">dotnet</span> <span class="k">add</span> <span class="n">package</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">EntityFrameworkCore</span><span class="p">.</span><span class="n">Design</span>
</pre></div>
</div>
<p>要创建迁移，请在 IdentityServer 项目目录中打开命令提示符并运行以下两个命令:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">dotnet</span> <span class="n">ef</span> <span class="n">migrations</span> <span class="k">add</span> <span class="n">InitialIdentityServerPersistedGrantDbMigration</span> <span class="p">-</span><span class="n">c</span> <span class="n">PersistedGrantDbContext</span> <span class="p">-</span><span class="n">o</span> <span class="n">Data</span><span class="p">/</span><span class="n">Migrations</span><span class="p">/</span><span class="n">IdentityServer</span><span class="p">/</span><span class="n">PersistedGrantDb</span>
<span class="n">dotnet</span> <span class="n">ef</span> <span class="n">migrations</span> <span class="k">add</span> <span class="n">InitialIdentityServerConfigurationDbMigration</span> <span class="p">-</span><span class="n">c</span> <span class="n">ConfigurationDbContext</span> <span class="p">-</span><span class="n">o</span> <span class="n">Data</span><span class="p">/</span><span class="n">Migrations</span><span class="p">/</span><span class="n">IdentityServer</span><span class="p">/</span><span class="n">ConfigurationDb</span>
</pre></div>
</div>
<p>您现在应该在项目中看到一个 <code class="docutils literal notranslate"><span class="pre">~/Data/Migrations/IdentityServer</span></code> 文件夹，其中包含新创建的迁移的代码。</p>
</div>
<div class="section" id="id4">
<h3>初始化数据库<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>现在我们有了迁移，我们可以编写代码来从迁移创建数据库。
我们还可以使用我们在之前的快速入门中已经定义的内存中配置数据为数据库种子。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本快速入门中使用的方法用于轻松启动和运行 IdentityServer。 您应该设计适合您的架构的自己的数据库创建和维护策略。</p>
</div>
<p>在 <cite>Startup.cs</cite> 中添加这个方法来帮助初始化数据库:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">void</span> <span class="nf">InitializeDatabase</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">serviceScope</span> <span class="p">=</span> <span class="n">app</span><span class="p">.</span><span class="n">ApplicationServices</span><span class="p">.</span><span class="n">GetService</span><span class="p">&lt;</span><span class="n">IServiceScopeFactory</span><span class="p">&gt;().</span><span class="n">CreateScope</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">serviceScope</span><span class="p">.</span><span class="n">ServiceProvider</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">PersistedGrantDbContext</span><span class="p">&gt;().</span><span class="n">Database</span><span class="p">.</span><span class="n">Migrate</span><span class="p">();</span>

        <span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">serviceScope</span><span class="p">.</span><span class="n">ServiceProvider</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">ConfigurationDbContext</span><span class="p">&gt;();</span>
        <span class="n">context</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">Migrate</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">context</span><span class="p">.</span><span class="n">Clients</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">client</span> <span class="k">in</span> <span class="n">Config</span><span class="p">.</span><span class="n">Clients</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">context</span><span class="p">.</span><span class="n">Clients</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">ToEntity</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">context</span><span class="p">.</span><span class="n">SaveChanges</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(!</span><span class="n">context</span><span class="p">.</span><span class="n">IdentityResources</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">resource</span> <span class="k">in</span> <span class="n">Config</span><span class="p">.</span><span class="n">IdentityResources</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">context</span><span class="p">.</span><span class="n">IdentityResources</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">resource</span><span class="p">.</span><span class="n">ToEntity</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">context</span><span class="p">.</span><span class="n">SaveChanges</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(!</span><span class="n">context</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">resource</span> <span class="k">in</span> <span class="n">Config</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">context</span><span class="p">.</span><span class="n">ApiScopes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">resource</span><span class="p">.</span><span class="n">ToEntity</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">context</span><span class="p">.</span><span class="n">SaveChanges</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码可能需要您将以下命名空间添加到您的文件中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">IdentityServer4.EntityFramework.DbContexts</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">IdentityServer4.EntityFramework.Mappers</span><span class="p">;</span>
</pre></div>
</div>
<p>然后我们可以从 <code class="docutils literal notranslate"><span class="pre">Configure</span></code> 方法中调用它:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 这将进行初始数据库填充</span>
    <span class="n">InitializeDatabase</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>

    <span class="c1">// 已经在这里的其余代码</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在，如果您运行 IdentityServer 项目，则应创建数据库，并使用快速入门配置数据作为种子。
您应该能够使用 SQL Server Management Studio 或 Visual Studio 来连接和检查数据。</p>
<img alt="_images/ef_database.png" src="_images/ef_database.png" />
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>上面的 <code class="docutils literal notranslate"><span class="pre">InitializeDatabase</span></code> 辅助 API 可以方便地为数据库设置种子，但是这种方法不适合每次应用程序运行时都执行。 填充数据库后，请考虑删除对 API 的调用。</p>
</div>
</div>
<div class="section" id="id5">
<h3>运行客户端应用程序<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>您现在应该能够运行任何现有的客户端应用程序，并进行登录、获取令牌和调用 API —— 所有这些都基于数据库配置。</p>
</div>
</div>
<span id="document-quickstarts/6_aspnet_identity"></span><div class="section" id="asp-net-core-identity">
<h2>使用 ASP.NET Core Identity<a class="headerlink" href="#asp-net-core-identity" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>对于任何先决条件（例如模板），请先查看 <a class="reference internal" href="index.html#refquickstartoverview"><span class="std std-ref">概述</span></a> 。</p>
</div>
<p>IdentityServer 旨在提供灵活性，其中一部分是允许您为您的用户及其数据（包括密码）使用您想使用的任何数据库。
如果您开始使用新的用户数据库，则 ASP.NET Core Identity 是您可以选择的一个选择。
本快速入门展示了如何将 ASP.NET Core Identity 与 IdentityServer 结合使用。</p>
<p>本快速入门使用 ASP.NET Core Identity 的方法是为 IdentityServer 主机创建一个新项目。
这个新项目将取代我们在之前的快速入门中建立的先前 IdentityServer 项目。
这个新项目的原因是由于使用 ASP.NET Core Identity 时 UI 资产的差异（主要围绕登录和注销的差异）。
此解决方案中的所有其他项目（针对客户端和 API）将保持不变。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本快速入门假设您熟悉 ASP.NET Core Identity 的工作原理。 如果不是，建议先 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity">了解一下</a>。</p>
</div>
<div class="section" id="id2">
<h3>新的 ASP.NET Core Identity 项目<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>第一步是将 ASP.NET Core Identity 的新项目添加到您的解决方案中。
我们提供了一个模板，其中包含 ASP.NET Core Identity 和 IdentityServer 所需的最少 UI 资产。
您最终将删除 IdentityServer 的旧项目，但您需要迁移一些项目。</p>
<p>首先创建一个将使用 ASP.NET Core Identity 的新 IdentityServer 项目:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">quickstart</span><span class="p">/</span><span class="n">src</span>
<span class="n">dotnet</span> <span class="k">new</span> <span class="n">is4aspid</span> <span class="p">-</span><span class="n">n</span> <span class="n">IdentityServerAspNetIdentity</span>
</pre></div>
</div>
<p>当提示 “seed” 用户数据库时，选择 “Y” 作为 “yes”。
这将使用我们的 “alice” 和 “bob” 用户填充用户数据库。
他们的密码是 “Pass123$”。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>该模板使用 Sqlite 作为用户的数据库，并且在模板中预先创建了 EF 迁移。 如果您希望使用不同的数据库提供程序，则需要更改代码中使用的提供程序并重新创建 EF 迁移。</p>
</div>
</div>
<div class="section" id="id3">
<h3>检查新项目<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>在您选择的编辑器中打开新项目，并检查生成的代码。
请务必查看：</p>
<div class="section" id="identityserveraspnetidentity-csproj">
<h4>IdentityServerAspNetIdentity.csproj<a class="headerlink" href="#identityserveraspnetidentity-csproj" title="永久链接至标题">¶</a></h4>
<p>注意对 <cite>IdentityServer4.AspNetIdentity</cite> 的引用。
此 NuGet 包包含 IdentityServer 的 ASP.NET Core Identity 集成组件。</p>
</div>
<div class="section" id="startup-cs">
<h4>Startup.cs<a class="headerlink" href="#startup-cs" title="永久链接至标题">¶</a></h4>
<p>在`ConfigureServices` 中注意必要的 <code class="docutils literal notranslate"><span class="pre">AddDbContext&lt;ApplicationDbContext&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddIdentity&lt;ApplicationUser,</span> <span class="pre">IdentityRole&gt;</span></code> 调用来配置 ASP.NET Core Identity。</p>
<p>另请注意，您在之前的快速入门中所做的大部分相同 IdentityServer 配置已经完成。
该模板对客户端和资源使用内存中的样式，它们来自 <cite>Config.cs</cite>。</p>
<p>最后，注意添加了对 <code class="docutils literal notranslate"><span class="pre">AddAspNetIdentity&lt;ApplicationUser&gt;</span></code> 的新调用。
<code class="docutils literal notranslate"><span class="pre">AddAspNetIdentity</span></code> 添加了集成层以允许 IdentityServer 访问 ASP.NET Core Identity 用户数据库的用户数据。
当 IdentityServer 必须将用户的声明添加到令牌中时，这是必需的。</p>
<p>注意 <code class="docutils literal notranslate"><span class="pre">AddIdentity&lt;ApplicationUser,</span> <span class="pre">IdentityRole&gt;</span></code> 必须在 <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code> 之前调用。</p>
</div>
<div class="section" id="config-cs">
<h4>Config.cs<a class="headerlink" href="#config-cs" title="永久链接至标题">¶</a></h4>
<p><cite>Config.cs</cite> 包含硬编码的内存客户端和资源定义。
为了让相同的客户端和 API 像之前的快速入门一样工作，我们需要将旧 IdentityServer 项目中的配置数据复制到这个项目中。
现在这样做，之后 <cite>Config.cs</cite> 应该是这样的:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Config</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span> <span class="n">IdentityResources</span> <span class="p">=&gt;</span>
        <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">new</span> <span class="n">IdentityResources</span><span class="p">.</span><span class="n">OpenId</span><span class="p">(),</span>
            <span class="k">new</span> <span class="n">IdentityResources</span><span class="p">.</span><span class="n">Profile</span><span class="p">(),</span>
        <span class="p">};</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span> <span class="n">ApiScopes</span> <span class="p">=&gt;</span>
        <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;My API&quot;</span><span class="p">)</span>
        <span class="p">};</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span> <span class="n">Clients</span> <span class="p">=&gt;</span>
        <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="c1">// 机器对机器客户端</span>
            <span class="k">new</span> <span class="n">Client</span>
            <span class="p">{</span>
                <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
                <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

                <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
                <span class="c1">// 客户端有权访问的范围</span>
                <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span> <span class="p">}</span>
            <span class="p">},</span>

            <span class="c1">// interactive ASP.NET Core MVC client</span>
            <span class="k">new</span> <span class="n">Client</span>
            <span class="p">{</span>
                <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mvc&quot;</span><span class="p">,</span>
                <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

                <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>

                <span class="c1">// 登录后重定向到哪里</span>
                <span class="n">RedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signin-oidc&quot;</span> <span class="p">},</span>

                <span class="c1">// 注销后重定向到哪里</span>
                <span class="n">PostLogoutRedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://localhost:5002/signout-callback-oidc&quot;</span> <span class="p">},</span>

                <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
                <span class="p">{</span>
                    <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">OpenId</span><span class="p">,</span>
                    <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Profile</span><span class="p">,</span>
                    <span class="s">&quot;api1&quot;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此时，您不再需要旧的 IdentityServer 项目。</p>
</div>
<div class="section" id="program-cs-seeddata-cs">
<h4>Program.cs 和 SeedData.cs<a class="headerlink" href="#program-cs-seeddata-cs" title="永久链接至标题">¶</a></h4>
<p><cite>Program.cs</cite> 的 <code class="docutils literal notranslate"><span class="pre">Main</span></code> 与大多数 ASP.NET Core 项目略有不同。
请注意这如何查找名为 <cite>/seed</cite> 的命令行参数，该参数用作在 ASP.NET Core Identity 数据库中为用户提供种子的标志。</p>
<p>查看 <code class="docutils literal notranslate"><span class="pre">SeedData</span></code> 类代码以了解如何创建数据库以及如何创建第一个用户。</p>
</div>
<div class="section" id="accountcontroller">
<h4>AccountController<a class="headerlink" href="#accountcontroller" title="永久链接至标题">¶</a></h4>
<p>此模板中要检查的最后一个代码是 <code class="docutils literal notranslate"><span class="pre">AccountController</span></code>。
这包含与之前的快速入门和模板略有不同的登录和注销代码。
请注意使用 ASP.NET Core Identity 中的 <code class="docutils literal notranslate"><span class="pre">SignInManager&lt;ApplicationUser&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">UserManager&lt;ApplicationUser&gt;</span></code> 来验证凭据和管理身份验证会话。</p>
<p>其余大部分代码与之前的快速入门和模板相同。</p>
</div>
</div>
<div class="section" id="mvc">
<h3>使用 MVC 客户端登录<a class="headerlink" href="#mvc" title="永久链接至标题">¶</a></h3>
<p>此时，您应该能够运行所有现有的客户端和示例。
一个例外是 <cite>ResourceOwnerClient</cite> ——密码需要从 <code class="docutils literal notranslate"><span class="pre">password</span></code> 更新为 <code class="docutils literal notranslate"><span class="pre">Pass123$</span></code>。</p>
<p>启动 MVC 客户端应用程序，您应该能够单击“安全”链接以登录。</p>
<img alt="_images/aspid_mvc_client.png" src="_images/aspid_mvc_client.png" />
<p>您应该被重定向到 ASP.NET Core Identity 登录页面。
使用您新创建的用户登录：</p>
<img alt="_images/aspid_login.png" src="_images/aspid_login.png" />
<p>登录后，您会看到正常的同意页面。
同意后，您将被重定向回 MVC 客户端应用程序，您的用户声明应在其中列出。</p>
<img alt="_images/aspid_claims.png" src="_images/aspid_claims.png" />
<p>您还应该能够点击 “Call API using application identity” 以代表用户调用 API：</p>
<img alt="_images/aspid_api_claims.png" src="_images/aspid_api_claims.png" />
<p>现在，您正在 IdentityServer 中使用来自 ASP.NET Core Identity 的用户。</p>
</div>
<div class="section" id="id4">
<h3>缺少了什么？<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>此模板中的大部分其余代码与我们提供的其他快速入门和模板类似。
您会注意到此模板中缺少的一件事是用于用户注册、密码重置的 UI 代码，以及您可能期望从 Visual Studio ASP.NET Core Identity 模板中获得的其他内容。</p>
<p>鉴于使用 ASP.NET Core Identity 的各种要求和不同方法，我们的模板故意不提供这些功能。
您应该了解 ASP.NET Core Identity 如何工作得足够好，以便将这些功能添加到您的项目中。
或者，您可以基于 Visual Studio ASP.NET Core Identity 模板创建一个新项目，并将您在这些快速入门中了解的 IdentityServer 功能添加到该项目。</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="toctree-wrapper compound">
<span id="document-topics/startup"></span><div class="section" id="startup">
<h2>Startup<a class="headerlink" href="#startup" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 是中间件和服务的组合。
所有配置都在您的启动类中完成。</p>
<div class="section" id="id1">
<h3>配置服务<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>您可以通过调用将 IdentityServer 服务添加到 DI 系统:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您可以选择将选项传递到此调用中。 有关选项的详细信息，请参阅 <a class="reference internal" href="index.html#refoptions"><span class="std std-ref">这里</span></a>。</p>
<p>这将返回一个 builder 对象，该对象又具有许多连接附加服务的便捷方法。</p>
</div>
<div class="section" id="id2">
<h3>密钥材料<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 支持 X.509 证书（原始文件和对 Windows 证书存储的引用）、RSA 密钥和用于令牌签名和验证的 EC 密钥。
每个密钥都可以配置一个（兼容的）签名算法，例如 RS256、RS384、RS512、PS256、PS384、PS512、ES256、ES384 或 ES512。</p>
<p>您可以使用以下方法配置密钥材料：</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddSigningCredential</span></code></dt><dd><p>添加一个签名密钥，为各种令牌创建/验证服务提供指定的密钥材料。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddDeveloperSigningCredential</span></code></dt><dd><p>在启动时创建临时密钥材料。 这是针对开发场景的。 默认情况下，生成的密钥将持久保存在本地目录中。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddValidationKey</span></code></dt><dd><p>添加用于验证令牌的密钥。 它们将由内部令牌验证器使用，并将显示在发现文档中。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id3">
<h3>内存配置存储<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>各种 “in-memory” 配置 API 允许从内存中的配置对象列表配置 IdentityServer。
这些 “in-memory” 集合可以在托管应用程序中进行硬编码，也可以从配置文件或数据库中动态加载。
但是，按照设计，这些集合仅在托管应用程序启动时创建。</p>
<p>这些配置 API 的使用旨在用于原型设计、开发和/或测试，其中不需要在运行时动态查询数据库以获取配置数据。
如果配置很少更改，或者在必须更改值时要求重新启动应用程序并不不方便，则这种配置样式也可能适用于生产场景。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddInMemoryClients</span></code></dt><dd><p>基于 <code class="docutils literal notranslate"><span class="pre">Client</span></code> 配置对象的内存集合注册 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddInMemoryIdentityResources</span></code></dt><dd><p>基于 <code class="docutils literal notranslate"><span class="pre">IdentityResource</span></code> 配置对象的内存集合注册 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddInMemoryApiScopes</span></code></dt><dd><p>基于 <code class="docutils literal notranslate"><span class="pre">ApiScope</span></code> 配置对象的内存中集合注册 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddInMemoryApiResources</span></code></dt><dd><p>基于 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 配置对象的内存集合注册 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 实现。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id4">
<h3>测试存储<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TestUser</span></code> 类在 IdentityServer 中对用户、他们的凭据和声明进行建模。
<code class="docutils literal notranslate"><span class="pre">TestUser</span></code> 的使用类似于 “in-memory” 存储的使用，因为它用于原型设计、开发和/或测试。
不建议在生产中使用 <code class="docutils literal notranslate"><span class="pre">TestUser</span></code>。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddTestUsers</span></code></dt><dd><p>基于 <code class="docutils literal notranslate"><span class="pre">TestUser</span></code> 对象的集合注册 <code class="docutils literal notranslate"><span class="pre">TestUserStore</span></code>。
<code class="docutils literal notranslate"><span class="pre">TestUserStore</span></code> 由默认的快速入门 UI 使用。
还注册了 <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code> 和 <code class="docutils literal notranslate"><span class="pre">IResourceOwnerPasswordValidator</span></code> 的实现。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id5">
<h3>额外服务<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddExtensionGrantValidator</span></code></dt><dd><p>添加用于扩展授权的 <code class="docutils literal notranslate"><span class="pre">IExtensionGrantValidator</span></code> 实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddSecretParser</span></code></dt><dd><p>添加用于解析客户端或 API 资源凭据的 <code class="docutils literal notranslate"><span class="pre">ISecretParser</span></code> 实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddSecretValidator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">ISecretValidator</span></code> 实现，用于根据凭证存储验证客户端或 API 资源凭证。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddResourceOwnerValidator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">IResourceOwnerPasswordValidator</span></code> 实现，用于验证资源所有者密码凭据授权类型的用户凭据。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddProfileService</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code> 实现以连接到您的 <a class="reference internal" href="index.html#refprofileservice"><span class="std std-ref">自定义用户配置文件存储</span></a>。
<code class="docutils literal notranslate"><span class="pre">DefaultProfileService</span></code> 类提供了默认实现，该实现依赖于身份验证 cookie 作为在令牌中发布的唯一声明来源。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddAuthorizeInteractionResponseGenerator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">IAuthorizeInteractionResponseGenerator</span></code> 实现，以自定义授权端点的逻辑，以便在必须向用户显示错误、登录、同意或任何其他自定义页面的 UI时使用。
<code class="docutils literal notranslate"><span class="pre">AuthorizeInteractionResponseGenerator</span></code> 类提供了默认实现，因此如果您需要增强现有行为，请考虑从该现有类派生。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddCustomAuthorizeRequestValidator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">ICustomAuthorizeRequestValidator</span></code> 实现，以在授权端点自定义请求参数验证。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddCustomTokenRequestValidator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">ICustomTokenRequestValidator</span></code> 实现，以自定义令牌端点处的请求参数验证。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddRedirectUriValidator</span></code></dt><dd><p>添加 <code class="docutils literal notranslate"><span class="pre">IRedirectUriValidator</span></code> 实现，以自定义重定向 URI 验证。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddAppAuthRedirectUriValidator</span></code></dt><dd><p>添加符合 “AppAuth”（原生应用程序的 OAuth 2.0）的重定向 URI 验证器（进行严格验证，但也允许使用随机端口的 <a class="reference external" href="http://127.0.0.1">http://127.0.0.1</a>）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddJwtBearerClientAuthentication</span></code></dt><dd><p>添加对使用 JWT bearer 断言的客户端身份验证的支持。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddMutualTlsSecretValidators</span></code></dt><dd><p>为 mutual TLS 添加 X509 密钥验证器。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3>缓存<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 经常使用客户端和资源配置数据。
如果这些数据是从数据库或其他外部存储加载的，那么频繁地重新加载相同的数据可能会很昂贵。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddInMemoryCaching</span></code></dt><dd><p>要使用下面描述的任何缓存，必须在 DI 中注册 <code class="docutils literal notranslate"><span class="pre">ICache&lt;T&gt;</span></code> 的实现。
此 API 注册了一个基于 ASP.NET Core 的 <code class="docutils literal notranslate"><span class="pre">MemoryCache</span></code> 的默认内存中实现 <code class="docutils literal notranslate"><span class="pre">ICache&lt;T&gt;</span></code> 。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddClientStoreCache</span></code></dt><dd><p>注册一个 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code> 装饰器实现，它将维护一个 <code class="docutils literal notranslate"><span class="pre">Client</span></code> 配置对象的内存缓存。
缓存持续时间可在 <code class="docutils literal notranslate"><span class="pre">IdentityServerOptions``的</span> <span class="pre">``Caching</span></code> 配置选项中配置。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddResourceStoreCache</span></code></dt><dd><p>注册一个 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 装饰器实现，它将维护一个 <code class="docutils literal notranslate"><span class="pre">IdentityResource</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 配置对象的内存缓存。
缓存持续时间可在 <code class="docutils literal notranslate"><span class="pre">IdentityServerOptions``的</span> <span class="pre">``Caching</span></code> 配置选项中配置。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddCorsPolicyCache</span></code></dt><dd><p>注册一个 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 装饰器实现，它将维护 CORS 策略服务评估结果的内存缓存。
缓存持续时间可在 <code class="docutils literal notranslate"><span class="pre">IdentityServerOptions``的</span> <span class="pre">``Caching</span></code> 配置选项中配置。</p>
</dd>
</dl>
</li>
</ul>
<p>可以进一步自定义缓存：</p>
<p>默认缓存依赖于 <code class="docutils literal notranslate"><span class="pre">ICache&lt;T&gt;</span></code> 实现。
如果您希望为特定配置对象自定义缓存行为，您可以在依赖注入系统中替换此实现。</p>
<p><code class="docutils literal notranslate"><span class="pre">ICache&lt;T&gt;</span></code> 本身的默认实现依赖于.NET 提供的 <code class="docutils literal notranslate"><span class="pre">IMemoryCache</span></code> 接口（和 <code class="docutils literal notranslate"><span class="pre">MemoryCache</span></code> 实现）。
如果您希望自定义内存缓存行为，您可以替换依赖注入系统中的 <code class="docutils literal notranslate"><span class="pre">IMemoryCache</span></code> 实现。</p>
</div>
<div class="section" id="id7">
<h3>配置管道<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>您需要通过调用将 IdentityServer 添加到管道中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseIdentityServer</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">UseIdentityServer</span></code> 包括对 <code class="docutils literal notranslate"><span class="pre">UseAuthentication</span></code> 的调用，因此不必同时具有这两个调用。</p>
</div>
<p>中间件没有额外的配置。</p>
<p>请注意，顺序在管道中很重要。
例如，您需要在实现登录屏幕的 UI 框架之前添加 IdentitySever。</p>
</div>
</div>
<span id="document-topics/resources"></span><div class="section" id="id1">
<h2>定义资源<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>OpenID Connect/OAuth 令牌服务的最终工作是控制对资源的访问。</p>
<p>IdentityServer 中的两种基本资源类型是：</p>
<ul class="simple">
<li><p><strong>identity resources:</strong> 代表关于用户的声明，如用户 ID、显示名称、电子邮件地址等……</p></li>
<li><p><strong>API resources:</strong> 代表客户想要访问的功能。 通常，它们是基于 HTTP 的端点（又名 API），但也可以是消息队列端点或类似端点。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 C# 对象模型定义资源 —— 或从数据存储加载它们。 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 的实现处理这些低级细节。 对于本文档，我们使用内存中实现。</p>
</div>
<div class="section" id="id2">
<h3>身份资源<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>身份资源是一组命名的声明，可以使用 <em>scope</em> 参数进行请求。</p>
<p>OpenID Connect 规范 <a class="reference external" href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">建议</a> 了几个标准范围名称来声明类型映射，它们可能对您的灵感有用，但您可以自由地自己设计它们。</p>
<p>其中之一实际上是强制性的，<em>openid</em> 范围，它告诉提供者在身份令牌中返回 <a href="#id4"><span class="problematic" id="id5">*</span></a>sub*（subject id）声明。</p>
<p>这是您在代码中定义 openid 范围的方式:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span> <span class="n">GetIdentityResources</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">IdentityResource</span><span class="p">(</span>
            <span class="n">name</span><span class="p">:</span> <span class="s">&quot;openid&quot;</span><span class="p">,</span>
            <span class="n">userClaims</span><span class="p">:</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;sub&quot;</span> <span class="p">},</span>
            <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;您的用户标识符&quot;</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>但由于这是规范中的标准范围之一，您可以将其缩短为:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span> <span class="n">GetIdentityResources</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="n">IdentityResources</span><span class="p">.</span><span class="n">OpenId</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">IdentityResource</span></code> 的更多信息，请参阅参考部分。</p>
</div>
<p>以下示例显示了一个名为 <em>profile</em> 的自定义身份资源，它表示显示名称、电子邮件地址和网站声明:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span> <span class="n">GetIdentityResources</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IdentityResource</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">IdentityResource</span><span class="p">(</span>
            <span class="n">name</span><span class="p">:</span> <span class="s">&quot;profile&quot;</span><span class="p">,</span>
            <span class="n">userClaims</span><span class="p">:</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;email&quot;</span><span class="p">,</span> <span class="s">&quot;website&quot;</span> <span class="p">},</span>
            <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;您的个人资料数据&quot;</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>定义资源后，您可以通过 <code class="docutils literal notranslate"><span class="pre">AllowedScopes</span></code> 选项（省略其他属性）将其访问权限授予客户端:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;openid&quot;</span><span class="p">,</span> <span class="s">&quot;profile&quot;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>然后客户端可以使用 scope 参数请求资源（其他参数省略）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="c1">//demo.identityserver.io/connect/authorize?client_id=client&amp;scope=openid profile</span>
</pre></div>
</div>
<p>IdentityServer 然后将使用 scope 名称创建请求的声明类型列表，
并将其呈现给您的 <a class="reference internal" href="index.html#refprofileservice"><span class="std std-ref">profile service</span></a> 的实现。</p>
</div>
<div class="section" id="apis">
<h3>APIs<a class="headerlink" href="#apis" title="永久链接至标题">¶</a></h3>
<p>设计您的 API 表面可能是一项复杂的任务。 IdentityServer 提供了一些原语来帮助您解决这个问题。</p>
<p>原始的 OAuth 2.0 规范中有 scope 的概念，它只是定义为客户端请求的 <em>访问范围</em>。
从技术上讲，<em>scope</em> 参数是一个空格分隔值列表 —— 您需要提供它的结构和语义。</p>
<p>在更复杂的系统中，通常会引入 <em>resource</em> 的概念。 这可能是例如 物理或逻辑 API。
反过来，每个 API 也可能具有 scope。 某些 scope 可能是该资源独有的，而某些 scope 可能是共享的。</p>
<p>让我们首先从简单的 scopes 开始，然后我们将看看 resources 如何帮助构建 scopes。</p>
<div class="section" id="scopes">
<h4>Scopes<a class="headerlink" href="#scopes" title="永久链接至标题">¶</a></h4>
<p>让我们对一些非常简单的东西进行建模 —— 个具有三个逻辑操作 <em>read</em>、<em>write</em> 和 <em>delete</em> 的系统。</p>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">ApiScope</span></code> 类定义它们:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span> <span class="n">GetApiScopes</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;read&quot;</span><span class="p">,</span>   <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;读取您的数据。&quot;</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span>  <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;写入您的数据。&quot;</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;delete&quot;</span><span class="p">,</span> <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;删除您的数据。&quot;</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后，您可以将 scopes 分配给各种客户端，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">webViewer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;web_viewer&quot;</span><span class="p">,</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;openid&quot;</span><span class="p">,</span> <span class="s">&quot;profile&quot;</span><span class="p">,</span> <span class="s">&quot;read&quot;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">var</span> <span class="n">mobileApp</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mobile_app&quot;</span><span class="p">,</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;openid&quot;</span><span class="p">,</span> <span class="s">&quot;profile&quot;</span><span class="p">,</span> <span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="s">&quot;delete&quot;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>基于 Scopes 的授权<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>当客户端请求 scope（并且该 scope 是通过配置允许的，而不是通过同意拒绝）时，
该 scope 的值将作为 <em>scope</em> 类型的声明包含在结果访问令牌中（对于 JWT 和自省） ，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;typ&quot;</span><span class="p">:</span> <span class="s">&quot;at+jwt&quot;</span>
<span class="p">}.</span>
<span class="p">{</span>
    <span class="s">&quot;client_id&quot;</span><span class="p">:</span> <span class="s">&quot;mobile_app&quot;</span><span class="p">,</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;123&quot;</span><span class="p">,</span>

    <span class="s">&quot;scope&quot;</span><span class="p">:</span> <span class="s">&quot;read write delete&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>访问令牌的使用者可以使用该数据来确保实际上允许客户端调用相应的功能。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请注意，scope 仅用于授权客户端 —— 而不是用户。 IOW —— <em>write</em> scope 允许客户端调用与之相关的功能。 但是，该客户端很可能只能写入属于当前用户的数据。 这个额外的以用户为中心的授权是应用程序逻辑，不包含在 OAuth 中。</p>
</div>
<p>您可以通过从 scope 请求派生其他声明来添加有关用户的更多身份信息。 以下 scope 定义告诉配置系统，当授予 <em>write</em> scope 时，应将 <em>user_level</em> 声明添加到访问令牌:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">writeScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ApiScope</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span>
    <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;写入您的数据。&quot;</span><span class="p">,</span>
    <span class="n">userClaims</span><span class="p">:</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;user_level&quot;</span> <span class="p">});</span>
</pre></div>
</div>
<p>这会将 <em>user_level</em> 声明作为请求的声明类型传递给 profile service，以便访问令牌的使用者可以使用此数据作为授权决策或业务逻辑的输入。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>使用仅 scope 模型时，不会向令牌添加任何 aud（受众）声明，因为此概念不适用。 如果您需要 aud 声明，您可以在选项上启用 <code class="docutils literal notranslate"><span class="pre">EmitStaticAudience</span></code> 设置。 这将以 <code class="docutils literal notranslate"><span class="pre">issuer_name/resources</span></code> 格式发出 aud 声明。如果您需要更多地控制 aud 声明，请使用 API resources。</p>
</div>
</div>
<div class="section" id="id7">
<h4>参数化 Scopes<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>有时 scopes 具有特定的结构，例如，scope 名称带有附加参数： <em>transaction:id</em> 或 <em>read_patient:patientid</em>。</p>
<p>在这种情况下，您将创建一个没有参数部分的 scope 并将该名称分配给客户端，
但另外提供一些逻辑来在运行时使用 <code class="docutils literal notranslate"><span class="pre">IScopeParser</span></code> 接口或通过从我们的默认实现派生来解析 scope 的结构 ，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ParameterizedScopeParser</span> <span class="p">:</span> <span class="n">DefaultScopeParser</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">ParameterizedScopeParser</span><span class="p">(</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">DefaultScopeParser</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ParseScopeValue</span><span class="p">(</span><span class="n">ParseScopeContext</span> <span class="n">scopeContext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">string</span> <span class="n">transactionScopeName</span> <span class="p">=</span> <span class="s">&quot;transaction&quot;</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">string</span> <span class="n">separator</span> <span class="p">=</span> <span class="s">&quot;:&quot;</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">string</span> <span class="n">transactionScopePrefix</span> <span class="p">=</span> <span class="n">transactionScopeName</span> <span class="p">+</span> <span class="n">separator</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">scopeValue</span> <span class="p">=</span> <span class="n">scopeContext</span><span class="p">.</span><span class="n">RawValue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">scopeValue</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="n">transactionScopePrefix</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// 进入这里的 scope 类似于“transaction:something”</span>
            <span class="kt">var</span> <span class="n">parts</span> <span class="p">=</span> <span class="n">scopeValue</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">RemoveEmptyEntries</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parts</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">scopeContext</span><span class="p">.</span><span class="n">SetParsedValues</span><span class="p">(</span><span class="n">transactionScopeName</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">scopeContext</span><span class="p">.</span><span class="n">SetError</span><span class="p">(</span><span class="s">&quot;transaction scope 缺少 transaction 参数值&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">scopeValue</span> <span class="p">!=</span> <span class="n">transactionScopeName</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 进入这里的 scope 不像“transaction”</span>
            <span class="k">base</span><span class="p">.</span><span class="n">ParseScopeValue</span><span class="p">(</span><span class="n">scopeContext</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// 进入这里的 scope 恰好是“transaction”，也就是说我们忽略了它并且不将它包含在结果中</span>
            <span class="n">scopeContext</span><span class="p">.</span><span class="n">SetIgnore</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后，您可以访问整个管道中的解析值，例如，在配置文件服务中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">HostProfileService</span> <span class="p">:</span> <span class="n">IProfileService</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">GetProfileDataAsync</span><span class="p">(</span><span class="n">ProfileDataRequestContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">transaction</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">RequestedResources</span><span class="p">.</span><span class="n">ParsedScopes</span><span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">ParsedName</span> <span class="p">==</span> <span class="s">&quot;transaction&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">?.</span><span class="n">ParsedParameter</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">IssuedClaims</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Claim</span><span class="p">(</span><span class="s">&quot;transaction_id&quot;</span><span class="p">,</span> <span class="n">transaction</span><span class="p">.</span><span class="n">ParsedParameter</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="api-resources">
<h4>API Resources<a class="headerlink" href="#api-resources" title="永久链接至标题">¶</a></h4>
<p>当 API 表面变得更大时，像上面使用的那样一个简单的 scope 列表可能是不可行的。</p>
<p>您通常需要引入某种命名空间来组织 scope 名称，也许您还想将它们组合在一起并获得一些更高级别的结构，例如访问令牌中的 <em>audience</em> 声明。
您可能还会遇到多个资源应支持相同 scope 名称的情况，而有时您明确希望将 scope 与特定资源隔离。</p>
<p>在 IdentityServer 中，<code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 类允许一些额外的组织。 让我们使用以下 scope 定义:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span> <span class="n">GetApiScopes</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiScope</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">// 发票 API 特有的 scopes</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;invoice.read&quot;</span><span class="p">,</span>   <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;读取您的发票。&quot;</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;invoice.pay&quot;</span><span class="p">,</span>    <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;支付您的发票。&quot;</span><span class="p">),</span>

        <span class="c1">// 客户 API 特有的 scopes</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;customer.read&quot;</span><span class="p">,</span>    <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;读取您的客户信息。&quot;</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;customer.contact&quot;</span><span class="p">,</span> <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;允许联系您的客户之一。&quot;</span><span class="p">),</span>

        <span class="c1">// 共享 scope</span>
        <span class="k">new</span> <span class="nf">ApiScope</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;manage&quot;</span><span class="p">,</span> <span class="n">displayName</span><span class="p">:</span> <span class="s">&quot;提供对发票和客户数据的管理访问。&quot;</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> ，您现在可以创建两个逻辑 API 及其对应的 scope:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiResource</span><span class="p">&gt;</span> <span class="n">GetApiResources</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiResource</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">ApiResource</span><span class="p">(</span><span class="s">&quot;invoice&quot;</span><span class="p">,</span> <span class="s">&quot;发票 API&quot;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Scopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;invoice.read&quot;</span><span class="p">,</span> <span class="s">&quot;invoice.pay&quot;</span><span class="p">,</span> <span class="s">&quot;manage&quot;</span> <span class="p">}</span>
        <span class="p">},</span>

        <span class="k">new</span> <span class="nf">ApiResource</span><span class="p">(</span><span class="s">&quot;customer&quot;</span><span class="p">,</span> <span class="s">&quot;客户 API&quot;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Scopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;customer.read&quot;</span><span class="p">,</span> <span class="s">&quot;customer.contact&quot;</span><span class="p">,</span> <span class="s">&quot;manage&quot;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用 API 资源分组可以为您提供以下附加功能</p>
<ul class="simple">
<li><p>支持 JWT <em>aud</em> 声明。 audience 声明的值将是 API 资源的名称</p></li>
<li><p>支持在所有包含的 scopes 内添加通用用户声明</p></li>
<li><p>通过为资源分配 API 密钥来支持自省</p></li>
<li><p>支持为资源配置访问令牌签名算法</p></li>
</ul>
<p>让我们看一下上述资源配置的一些示例访问令牌。</p>
<p><strong>客户端请求</strong> invoice.read 和 invoice.pay:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;typ&quot;</span><span class="p">:</span> <span class="s">&quot;at+jwt&quot;</span>
<span class="p">}.</span>
<span class="p">{</span>
    <span class="s">&quot;client_id&quot;</span><span class="p">:</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;123&quot;</span><span class="p">,</span>

    <span class="s">&quot;aud&quot;</span><span class="p">:</span> <span class="s">&quot;invoice&quot;</span><span class="p">,</span>
    <span class="s">&quot;scope&quot;</span><span class="p">:</span> <span class="s">&quot;invoice.read invoice.pay&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>客户端请求</strong> invoice.read 和 customer.read:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;typ&quot;</span><span class="p">:</span> <span class="s">&quot;at+jwt&quot;</span>
<span class="p">}.</span>
<span class="p">{</span>
    <span class="s">&quot;client_id&quot;</span><span class="p">:</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;123&quot;</span><span class="p">,</span>

    <span class="s">&quot;aud&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="s">&quot;invoice&quot;</span><span class="p">,</span> <span class="s">&quot;customer&quot;</span> <span class="p">]</span>
    <span class="s">&quot;scope&quot;</span><span class="p">:</span> <span class="s">&quot;invoice.read customer.read&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>客户端请求</strong> manage:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;typ&quot;</span><span class="p">:</span> <span class="s">&quot;at+jwt&quot;</span>
<span class="p">}.</span>
<span class="p">{</span>
    <span class="s">&quot;client_id&quot;</span><span class="p">:</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;123&quot;</span><span class="p">,</span>

    <span class="s">&quot;aud&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="s">&quot;invoice&quot;</span><span class="p">,</span> <span class="s">&quot;customer&quot;</span> <span class="p">]</span>
    <span class="s">&quot;scope&quot;</span><span class="p">:</span> <span class="s">&quot;manage&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="v4">
<h4>迁移到 v4 的步骤<a class="headerlink" href="#v4" title="永久链接至标题">¶</a></h4>
<p>如上所述，从 v4 开始，scope 有自己的定义，并且可以选择被 resource 引用。
在 v4 之前，scopes 始终包含在 resource 中。</p>
<p>要迁移到 v4，您需要拆分 scope 和 resource 注册，通常首先注册所有 scope
（例如，使用 <code class="docutils literal notranslate"><span class="pre">AddInMemoryApiScopes</span></code> 方法），然后注册 API resources（如果有）。
然后 API  resources 将按名称引用先前注册的 scope。</p>
</div>
</div>
</div>
<span id="document-topics/clients"></span><div class="section" id="id1">
<h2>定义客户端<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>客户端表示可以从您的 IdentityServer 请求令牌的应用程序。</p>
<p>详细信息各不相同，但您通常会为客户端定义以下通用设置：</p>
<ul class="simple">
<li><p>唯一的客户端 ID</p></li>
<li><p>密钥（如果需要的话）</p></li>
<li><p>允许与令牌服务的交互（称为授权类型）</p></li>
<li><p>身份和/或访问令牌被发送到的网络位置（称为重定向 URI）</p></li>
<li><p>允许客户端访问的 scopes（又名 resources）列表</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>在运行时，通过 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code> 的实现来检索客户端。 这允许从任意数据源（如配置文件或数据库）加载它们。 对于本文档，我们将使用客户端存储的内存版本。 您可以通过 <code class="docutils literal notranslate"><span class="pre">AddInMemoryClients</span></code> 扩展方法在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中连接内存存储。</p>
</div>
<div class="section" id="id2">
<h3>定义服务器到服务器通信的客户端<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>在这种情况下，没有交互式用户存在 —— 服务（又名客户端）想要与 API（又名 scope）通信:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Clients</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span> <span class="n">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Client</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">new</span> <span class="n">Client</span>
            <span class="p">{</span>
                <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;service.client&quot;</span><span class="p">,</span>
                <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

                <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
                <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;api2.read_only&quot;</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="api">
<h3>定义用于使用身份验证和委托 API 访问的交互式应用程序<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h3>
<p>交互式应用程序（例如 Web 应用程序或原生桌面/移动）应用程序使用授权码流程。
此流程为您提供最佳安全性，因为访问令牌仅通过后端渠道调用传输（并允许您访问刷新令牌）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">interactiveClient</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;interactive&quot;</span><span class="p">,</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>
    <span class="n">AllowOfflineAccess</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">},</span>

    <span class="n">RedirectUris</span> <span class="p">=</span>           <span class="p">{</span> <span class="s">&quot;http://localhost:21402/signin-oidc&quot;</span> <span class="p">},</span>
    <span class="n">PostLogoutRedirectUris</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;http://localhost:21402/&quot;</span> <span class="p">},</span>
    <span class="n">FrontChannelLogoutUri</span> <span class="p">=</span>    <span class="s">&quot;http://localhost:21402/signout-oidc&quot;</span><span class="p">,</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">OpenId</span><span class="p">,</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Profile</span><span class="p">,</span>
        <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">StandardScopes</span><span class="p">.</span><span class="n">Email</span><span class="p">,</span>

        <span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;api2.read_only&quot;</span>
    <span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请参阅 <a class="reference internal" href="index.html#refgranttypes"><span class="std std-ref">grant types</span></a> 主题，了解有关为您的客户端选择正确的授权类型的更多信息。</p>
</div>
</div>
<div class="section" id="appsettings-json">
<h3>在 appsettings.json 中定义客户端<a class="headerlink" href="#appsettings-json" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AddInMemoryClients</span></code> 扩展方法还支持从 ASP.NET Core 配置文件添加客户端。 这允许您直接从 appsettings.json 文件定义静态客户端:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;IdentityServer&quot;</span><span class="p">:</span> <span class="p">{</span>
  <span class="s">&quot;IssuerUri&quot;</span><span class="p">:</span> <span class="s">&quot;urn:sso.company.com&quot;</span><span class="p">,</span>
  <span class="s">&quot;Clients&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s">&quot;Enabled&quot;</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
      <span class="s">&quot;ClientId&quot;</span><span class="p">:</span> <span class="s">&quot;local-dev&quot;</span><span class="p">,</span>
      <span class="s">&quot;ClientName&quot;</span><span class="p">:</span> <span class="s">&quot;Local Development&quot;</span><span class="p">,</span>
      <span class="s">&quot;ClientSecrets&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="p">{</span> <span class="s">&quot;Value&quot;</span><span class="p">:</span> <span class="s">&quot;&lt;插入编码为 Base64 字符串的密钥的 Sha256 哈希&gt;&quot;</span> <span class="p">}</span> <span class="p">],</span>
      <span class="s">&quot;AllowedGrantTypes&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="s">&quot;client_credentials&quot;</span> <span class="p">],</span>
      <span class="s">&quot;AllowedScopes&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="s">&quot;api1&quot;</span> <span class="p">],</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后将配置部分传递给 <code class="docutils literal notranslate"><span class="pre">AddInMemoryClients</span></code> 方法:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">AddInMemoryClients</span><span class="p">(</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="s">&quot;IdentityServer:Clients&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/signin"></span><div class="section" id="id1">
<h2>登录<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>为了让 IdentityServer 代表用户颁发令牌，该用户必须登录到 IdentityServer。</p>
<div class="section" id="cookie">
<h3>Cookie 认证<a class="headerlink" href="#cookie" title="永久链接至标题">¶</a></h3>
<p>使用由 ASP.NET Core 的 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/cookie">cookie 身份验证</a> 处理程序管理的 cookie 跟踪身份验证。</p>
<dl class="simple">
<dt>IdentityServer 注册了两个 cookie 处理程序（一个用于身份验证会话，另一个用于临时外部 cookie）。</dt><dd><p>默认情况下使用它们，如果您想手动引用它们，您可以从 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants</span></code> 类（ <code class="docutils literal notranslate"><span class="pre">DefaultCookieAuthenticationScheme</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ExternalCookieAuthenticationScheme</span></code> ）中获取它们的名称。</p>
</dd>
</dl>
<p>仅公开这些 cookie 的基本设置（过期和滑动），但如果您需要更多控制，您可以注册自己的 cookie 处理程序。
当使用来自 ASP.NET Core 的 <code class="docutils literal notranslate"><span class="pre">AddAuthentication</span></code> 时，IdentityServer 使用与 <code class="docutils literal notranslate"><span class="pre">AuthenticationOptions</span></code> 上配置的 <code class="docutils literal notranslate"><span class="pre">DefaultAuthenticateScheme</span></code> 相匹配的任何 cookie 处理程序。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>除了身份验证 cookie 之外，IdentityServer 还将发布一个额外的 cookie，默认名称为“idsrv.session”。 此 cookie 派生自 主身份验证 cookie，它用于 <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">注销时基于浏览器的 JavaScript 客户端</span></a> 的检查会话端点。 它与身份验证 cookie 保持同步，并在用户注销时删除。</p>
</div>
</div>
<div class="section" id="id3">
<h3>覆盖 cookie 处理程序配置<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>如果您希望使用自己的 cookie 身份验证处理程序，则必须自己配置它。
这必须在 DI 中注册 IdentityServer（使用 <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code>）之后在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中完成。
例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddInMemoryClients</span><span class="p">(</span><span class="n">Clients</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
    <span class="p">.</span><span class="n">AddInMemoryIdentityResources</span><span class="p">(</span><span class="n">Resources</span><span class="p">.</span><span class="n">GetIdentityResources</span><span class="p">())</span>
    <span class="p">.</span><span class="n">AddInMemoryApiResources</span><span class="p">(</span><span class="n">Resources</span><span class="p">.</span><span class="n">GetApiResources</span><span class="p">())</span>
    <span class="p">.</span><span class="n">AddDeveloperSigningCredential</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddTestUsers</span><span class="p">(</span><span class="n">TestUsers</span><span class="p">.</span><span class="n">Users</span><span class="p">);</span>

<span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="s">&quot;MyCookie&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddCookie</span><span class="p">(</span><span class="s">&quot;MyCookie&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ExpireTimeSpan</span> <span class="p">=</span> <span class="p">...;</span>
    <span class="p">});</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>IdentityServer 使用自定义方案（通过常量 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.DefaultCookieAuthenticationScheme</span></code>）在内部调用 <code class="docutils literal notranslate"><span class="pre">AddAuthentication</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddCookie</span></code>，因此要覆盖它们，您必须在 <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code> 之后进行相同的调用。</p>
</div>
</div>
<div class="section" id="id4">
<h3>登录用户界面和身份管理系统<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 不提供任何用于用户身份验证的用户界面或用户数据库。
这些是您自己应该提供或开发的东西。</p>
<p>如果您需要一个基本 UI（登录、注销、同意和管理授权）的起点，
您可以使用我们的 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">快速入门 UI</a>。</p>
<p>快速入门 UI 根据内存数据库对用户进行身份验证。 您可以使用对真实用户存储的访问权限来替换这些位。
我们有使用 <a class="reference internal" href="index.html#refaspnetidentityquickstart"><span class="std std-ref">ASP.NET Identity</span></a> 的示例。</p>
</div>
<div class="section" id="id5">
<h3>登录工作流程<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>当 IdentityServer 在授权端点收到请求并且用户未通过身份验证时，用户将被重定向到配置的登录页面。
您必须通过 <a class="reference internal" href="index.html#refoptions"><span class="std std-ref">选项</span></a> 上的 <code class="docutils literal notranslate"><span class="pre">UserInteraction</span></code> 设置（默认为 <code class="docutils literal notranslate"><span class="pre">/account/login</span></code>）将登录页面的路径告知 IdentityServer。
将传递一个 <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> 参数，通知您的登录页面，一旦登录完成，用户应该被重定向到该页面。</p>
<img alt="_images/signin_flow.png" src="_images/signin_flow.png" />
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>通过 <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> 参数请注意 <a class="reference external" href="https://en.wikipedia.org/wiki/URL_redirection#Security_issues">开放式重定向攻击</a>。 您应该验证 <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> 指的是众所周知的位置。 请参阅 API 的 <a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">interaction service</span></a> 以验证 <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> 参数。</p>
</div>
</div>
<div class="section" id="id7">
<h3>登录上下文<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>在您的登录页面上，您可能需要有关请求上下文的信息以自定义登录体验
（例如客户端、提示参数、IdP 提示或其他内容）。
这是通过 <a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">interaction service</span></a> 上的 <code class="docutils literal notranslate"><span class="pre">GetAuthorizationContextAsync</span></code> API 提供的。</p>
</div>
<div class="section" id="id8">
<h3>颁发 cookie 和声明<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>ASP.NET Core 的 <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code> 上有与身份验证相关的扩展方法，用于发出身份验证 cookie 并让用户登录。
使用的身份验证方案必须与您使用的 cookie 处理程序匹配（见上文）。</p>
<p>当您登录用户时，您必须至少发布一个 <code class="docutils literal notranslate"><span class="pre">sub</span></code> 声明和一个 <code class="docutils literal notranslate"><span class="pre">name</span></code> 声明。
IdentityServer 还在 HttpContext 上提供了一些 SignInAsync 扩展方法，以使其更方便。</p>
<p>您还可以选择发出 <code class="docutils literal notranslate"><span class="pre">idp</span></code> 声明（用于身份提供者名称）、<code class="docutils literal notranslate"><span class="pre">amr</span></code> 声明（用于使用的身份验证方法）和/或 <code class="docutils literal notranslate"><span class="pre">auth_time</span></code> 声明（用于纪元时间 用户通过身份验证）。
如果您不提供这些，则 IdentityServer 将提供默认值。</p>
</div>
</div>
<span id="document-topics/signin_external_providers"></span><div class="section" id="id1">
<h2>使用外部身份提供商登录<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>ASP.NET Core 有一种灵活的方式来处理外部身份验证。 这涉及几个步骤。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您使用的是 ASP.NET Identity，许多底层技术细节对您来说是隐藏的。 建议您还阅读 Microsoft <a class="reference external" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/social/">文档</a> 并执行 ASP.NET Identity <a class="reference internal" href="index.html#refaspnetidentityquickstart"><span class="std std-ref">快速入门</span></a>。</p>
</div>
<div class="section" id="id3">
<h3>为外部提供商添加身份验证处理程序<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>与外部提供者对话所需的协议实现封装在 <em>authentication handler</em> 中。
一些提供商使用专有协议（例如 Facebook 等社交提供商），一些提供商使用标准协议，例如 OpenID Connect、WS-Federation 或 SAML2p。</p>
<p>有关添加外部身份验证和配置它的分步说明，请参阅此 <a class="reference internal" href="index.html#refexternalauthenticationquickstart"><span class="std std-ref">快速入门</span></a>。</p>
</div>
<div class="section" id="cookie">
<h3>Cookie 的作用<a class="headerlink" href="#cookie" title="永久链接至标题">¶</a></h3>
<p>外部身份验证处理程序的一个选项称为 <code class="docutils literal notranslate"><span class="pre">SignInScheme</span></code>，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddGoogle</span><span class="p">(</span><span class="s">&quot;Google&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="s">&quot;要使用的 cookie 处理程序方案&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>登录方案指定 将临时存储外部身份验证结果的 cookie 处理程序 的名称，
例如，由外部提供商发送的声明。
这是必要的，因为在您完成外部身份验证过程之前，通常会涉及几个重定向。</p>
<p>鉴于这是一种常见的做法，IdentityServer 专门为此外部提供程序工作流注册了一个 cookie 处理程序。
该方案通过 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.ExternalCookieAuthenticationScheme</span></code> 常量表示。
如果您要使用我们的外部 cookie 处理程序，那么对于上面的 <code class="docutils literal notranslate"><span class="pre">SignInScheme</span></code>，您需要将值分配为 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.ExternalCookieAuthenticationScheme</span></code> 常量:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddGoogle</span><span class="p">(</span><span class="s">&quot;Google&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>您也可以注册自己的自定义 cookie 处理程序，如下所示:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddCookie</span><span class="p">(</span><span class="s">&quot;你的自定义方案&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddGoogle</span><span class="p">(</span><span class="s">&quot;Google&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">SignInScheme</span> <span class="p">=</span> <span class="s">&quot;你的自定义方案&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">;</span>
    <span class="p">})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>对于特殊场景，您还可以短路外部 cookie 机制，将外部用户直接转发到主 cookie 处理程序。 这通常涉及处理外部处理程序上的事件，以确保您从外部身份源执行正确的声明转换。</p>
</div>
</div>
<div class="section" id="id4">
<h3>触发身份验证处理程序<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>您可以通过 HttpContext 上的 <code class="docutils literal notranslate"><span class="pre">ChallengeAsync</span></code> 扩展方法（或使用 MVC <code class="docutils literal notranslate"><span class="pre">ChallengeResult</span></code>）调用外部身份验证处理程序。</p>
<p>您通常希望将一些选项传递给 challenge 操作，例如 回调页面的路径和簿记提供者的名称，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">callbackUrl</span> <span class="p">=</span> <span class="n">Url</span><span class="p">.</span><span class="n">Action</span><span class="p">(</span><span class="s">&quot;ExternalLoginCallback&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">props</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AuthenticationProperties</span>
<span class="p">{</span>
    <span class="n">RedirectUri</span> <span class="p">=</span> <span class="n">callbackUrl</span><span class="p">,</span>
    <span class="n">Items</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;scheme&quot;</span><span class="p">,</span> <span class="n">provider</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;returnUrl&quot;</span><span class="p">,</span> <span class="n">returnUrl</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">return</span> <span class="nf">Challenge</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="n">props</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>处理回调并登录用户<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>在回调页面上，您的典型任务是：</p>
<ul class="simple">
<li><p>检查外部提供者返回的身份。</p></li>
<li><p>决定如何与该用户打交道。 根据这是新用户还是回访用户的事实，这可能会有所不同。</p></li>
<li><p>新用户在被允许进入之前可能需要额外的步骤和 UI。</p></li>
<li><p>可能会创建一个链接到外部提供商的新内部用户帐户。</p></li>
<li><p>存储您想要保留的外部声明。</p></li>
<li><p>删除临时cookie</p></li>
<li><p>登录用户</p></li>
</ul>
<p><strong>检查外部身份</strong>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 从临时 cookie 中读取外部身份</span>
<span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">AuthenticateAsync</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">?.</span><span class="n">Succeeded</span> <span class="p">!=</span> <span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;外部认证错误&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 检索外部用户的声明</span>
<span class="kt">var</span> <span class="n">externalUser</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">Principal</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">externalUser</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;外部认证错误&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 检索外部用户的声明</span>
<span class="kt">var</span> <span class="n">claims</span> <span class="p">=</span> <span class="n">externalUser</span><span class="p">.</span><span class="n">Claims</span><span class="p">.</span><span class="n">ToList</span><span class="p">();</span>

<span class="c1">// 尝试确定外部用户的唯一 ID —— 最常见的声明类型是 sub 声明和 NameIdentifier，</span>
<span class="c1">// 具体取决于外部提供者，可能会使用其他一些声明类型</span>
<span class="kt">var</span> <span class="n">userIdClaim</span> <span class="p">=</span> <span class="n">claims</span><span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Type</span> <span class="p">==</span> <span class="n">JwtClaimTypes</span><span class="p">.</span><span class="n">Subject</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">userIdClaim</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">userIdClaim</span> <span class="p">=</span> <span class="n">claims</span><span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Type</span> <span class="p">==</span> <span class="n">ClaimTypes</span><span class="p">.</span><span class="n">NameIdentifier</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">userIdClaim</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;未知 userid&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">externalUserId</span> <span class="p">=</span> <span class="n">userIdClaim</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">externalProvider</span> <span class="p">=</span> <span class="n">userIdClaim</span><span class="p">.</span><span class="n">Issuer</span><span class="p">;</span>

<span class="c1">// 使用 externalProvider 和 externalUserId 查找您的用户，或配置新用户</span>
</pre></div>
</div>
<p><strong>清理和登录</strong>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 为用户颁发身份验证 cookie</span>
<span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignInAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">IdentityServerUser</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">SubjectId</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DisplayName</span> <span class="p">=</span> <span class="n">user</span><span class="p">.</span><span class="n">Username</span><span class="p">,</span>
    <span class="n">IdentityProvider</span> <span class="p">=</span> <span class="n">provider</span><span class="p">,</span>
    <span class="n">AdditionalClaims</span> <span class="p">=</span> <span class="n">additionalClaims</span><span class="p">,</span>
    <span class="n">AuthenticationTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span>
<span class="p">});</span>

<span class="c1">// 删除外部身份验证期间使用的临时 cookie</span>
<span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignOutAsync</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">);</span>

<span class="c1">// 验证返回 URL 并重定向回授权端点或本地页面</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_interaction</span><span class="p">.</span><span class="n">IsValidReturnUrl</span><span class="p">(</span><span class="n">returnUrl</span><span class="p">)</span> <span class="p">||</span> <span class="n">Url</span><span class="p">.</span><span class="n">IsLocalUrl</span><span class="p">(</span><span class="n">returnUrl</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">Redirect</span><span class="p">(</span><span class="n">returnUrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nf">Redirect</span><span class="p">(</span><span class="s">&quot;~/&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="url-isecuredataformat">
<h3>状态、URL 长度和 ISecureDataFormat<a class="headerlink" href="#url-isecuredataformat" title="永久链接至标题">¶</a></h3>
<p>当重定向到外部提供程序进行登录时，来自客户端应用程序的状态必须经常往返。
这意味着在离开客户端之前捕获状态并保留直到用户返回到客户端应用程序。
许多协议，包括 OpenID Connect，允许将某种状态作为参数作为请求的一部分传递，身份提供者将在响应中返回该状态。
ASP.NET Core 提供的 OpenID Connect 身份验证处理程序利用了协议的这一特性，这就是它实现上述 <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> 特性的方式。</p>
<p>在请求参数中存储状态的问题是请求 URL 可能变得太大（超过 2000 个字符的常见限制）。
OpenID Connect 身份验证处理程序确实提供了一个可扩展点来将状态存储在您的服务器中，而不是存储在请求 URL 中。
您可以通过实现 <code class="docutils literal notranslate"><span class="pre">ISecureDataFormat&lt;AuthenticationProperties&gt;</span></code> 并在 <a class="reference external" href="https://github.com/aspnet/AspNetCore/blob/main/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectOptions.cs#L249">OpenIdConnectOptions</a> 上配置它来自己实现。</p>
<p>幸运的是，IdentityServer 为您提供了一个实现，由在 DI 容器中注册的 <code class="docutils literal notranslate"><span class="pre">IDistributedCache</span></code> 实现支持（例如标准的 <code class="docutils literal notranslate"><span class="pre">MemoryDistributedCache</span></code>）。
要使用 IdentityServer 提供的安全数据格式实现，只需在配置 DI 时调用 <code class="docutils literal notranslate"><span class="pre">IServiceCollection</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">AddOidcStateDataFormatterCache</span></code> 扩展方法。
如果没有传递参数，那么所有配置的 OpenID Connect 处理程序将使用 IdentityServer 提供的安全数据格式实现:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 配置 OpenIdConnect 处理程序以将状态参数持久化到服务器端 IDistributedCache。</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddOidcStateDataFormatterCache</span><span class="p">();</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;demoidsrv&quot;</span><span class="p">,</span> <span class="s">&quot;IdentityServer&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;aad&quot;</span><span class="p">,</span> <span class="s">&quot;Azure AD&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;adfs&quot;</span><span class="p">,</span> <span class="s">&quot;ADFS&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果只配置特定的方案，则将这些方案作为参数传递:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 配置 OpenIdConnect 处理程序以将状态参数持久化到服务器端 IDistributedCache。</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddOidcStateDataFormatterCache</span><span class="p">(</span><span class="s">&quot;aad&quot;</span><span class="p">,</span> <span class="s">&quot;demoidsrv&quot;</span><span class="p">);</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;demoidsrv&quot;</span><span class="p">,</span> <span class="s">&quot;IdentityServer&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;aad&quot;</span><span class="p">,</span> <span class="s">&quot;Azure AD&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">AddOpenIdConnect</span><span class="p">(</span><span class="s">&quot;adfs&quot;</span><span class="p">,</span> <span class="s">&quot;ADFS&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/windows"></span><div class="section" id="windows">
<h2>Windows 身份验证<a class="headerlink" href="#windows" title="永久链接至标题">¶</a></h2>
<p>您可以通过多种方式在 ASP.NET Core（以及 IdentityServer）中启用 Windows 身份验证。</p>
<ul class="simple">
<li><p>在 Windows 上使用 IIS 托管（进程内和进程外）</p></li>
<li><p>在 Windows 上使用 HTTP.SYS 托管</p></li>
<li><p>在任何使用协商身份验证处理程序的平台上（在 ASP.NET Core 3.0 中添加）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>我们只有 IIS 托管的文档。 如果您想为文档做出贡献，请打开一个 PR。 谢谢！</p>
</div>
<div class="section" id="iis-windows">
<h3>在使用 IIS 托管的 Windows 上<a class="headerlink" href="#iis-windows" title="永久链接至标题">¶</a></h3>
<p>当托管在 IIS 中时，典型的 <code class="docutils literal notranslate"><span class="pre">CreateDefaultBuilder</span></code> 主机设置支持基于 IIS 的 Windows 身份验证。
确保在 <code class="docutils literal notranslate"><span class="pre">launchSettings.json</span></code> 或您的 IIS 配置中启用了 Windows 身份验证。</p>
<p>IIS 集成层会将 Windows 身份验证处理程序配置到可通过身份验证服务调用的 DI 中。
通常在 IdentityServer 中，建议禁用自动行为。</p>
<p>这是在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中完成的（详细信息取决于进程内与进程外托管）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 配置 IIS 进程外设置（参见 https://github.com/aspnet/AspNetCore/issues/14882）</span>
<span class="n">services</span><span class="p">.</span><span class="n">Configure</span><span class="p">&lt;</span><span class="n">IISOptions</span><span class="p">&gt;(</span><span class="n">iis</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">iis</span><span class="p">.</span><span class="n">AuthenticationDisplayName</span> <span class="p">=</span> <span class="s">&quot;Windows&quot;</span><span class="p">;</span>
    <span class="n">iis</span><span class="p">.</span><span class="n">AutomaticAuthentication</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// ..或配置 IIS 进程内设置</span>
<span class="n">services</span><span class="p">.</span><span class="n">Configure</span><span class="p">&lt;</span><span class="n">IISServerOptions</span><span class="p">&gt;(</span><span class="n">iis</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">iis</span><span class="p">.</span><span class="n">AuthenticationDisplayName</span> <span class="p">=</span> <span class="s">&quot;Windows&quot;</span><span class="p">;</span>
    <span class="n">iis</span><span class="p">.</span><span class="n">AutomaticAuthentication</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>您可以通过在 <code class="docutils literal notranslate"><span class="pre">Windows</span></code> 方案上调用 <code class="docutils literal notranslate"><span class="pre">ChallengeAsync</span></code> 来触发 Windows 身份验证（或者如果您想使用常量：<code class="docutils literal notranslate"><span class="pre">Microsoft.AspNetCore.Server.IISIntegration.IISDefaults.AuthenticationScheme</span></code>）。</p>
<p>这会将 <code class="docutils literal notranslate"><span class="pre">Www-Authenticate</span></code> 标头发送回浏览器，然后浏览器将重新加载当前的 URL，包括 Windows 身份。
当您在 <code class="docutils literal notranslate"><span class="pre">Windows</span></code> 方案上调用 <code class="docutils literal notranslate"><span class="pre">AuthenticateAsync</span></code> 并且返回的主体类型为 <code class="docutils literal notranslate"><span class="pre">WindowsPrincipal</span></code> 时，您可以判断 Windows 身份验证成功。</p>
<p>主体将具有用户和组 SID 以及 Windows 帐户名称等信息。
以下代码段显示了如何触发身份验证，如果成功，则将信息转换为 temp-Cookie 方法的标准 <code class="docutils literal notranslate"><span class="pre">ClaimsPrincipal</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="n">ChallengeWindowsAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">returnUrl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 查看是否已请求 Windows 身份验证并成功</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">AuthenticateAsync</span><span class="p">(</span><span class="s">&quot;Windows&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">?.</span><span class="n">Principal</span> <span class="k">is</span> <span class="n">WindowsPrincipal</span> <span class="n">wp</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 我们将发出外部 cookie，</span>
        <span class="c1">// 然后将用户重定向回外部回调，</span>
        <span class="c1">// 本质上，将 windows auth 视为与任何其他外部身份验证机制相同</span>
        <span class="kt">var</span> <span class="n">props</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AuthenticationProperties</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">RedirectUri</span> <span class="p">=</span> <span class="n">Url</span><span class="p">.</span><span class="n">Action</span><span class="p">(</span><span class="s">&quot;Callback&quot;</span><span class="p">),</span>
            <span class="n">Items</span> <span class="p">=</span>
            <span class="p">{</span>
                <span class="p">{</span> <span class="s">&quot;returnUrl&quot;</span><span class="p">,</span> <span class="n">returnUrl</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;scheme&quot;</span><span class="p">,</span> <span class="s">&quot;Windows&quot;</span> <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kt">var</span> <span class="n">id</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ClaimsIdentity</span><span class="p">(</span><span class="s">&quot;Windows&quot;</span><span class="p">);</span>

        <span class="c1">// sid 是一个很好的子值</span>
        <span class="n">id</span><span class="p">.</span><span class="n">AddClaim</span><span class="p">(</span><span class="k">new</span> <span class="n">Claim</span><span class="p">(</span><span class="n">JwtClaimTypes</span><span class="p">.</span><span class="n">Subject</span><span class="p">,</span> <span class="n">wp</span><span class="p">.</span><span class="n">FindFirst</span><span class="p">(</span><span class="n">ClaimTypes</span><span class="p">.</span><span class="n">PrimarySid</span><span class="p">).</span><span class="n">Value</span><span class="p">));</span>

        <span class="c1">// 帐户名称是我们最接近显示名称的名称</span>
        <span class="n">id</span><span class="p">.</span><span class="n">AddClaim</span><span class="p">(</span><span class="k">new</span> <span class="n">Claim</span><span class="p">(</span><span class="n">JwtClaimTypes</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">wp</span><span class="p">.</span><span class="n">Identity</span><span class="p">.</span><span class="n">Name</span><span class="p">));</span>

        <span class="c1">// 添加组作为声明 —— 如果组数太大，请小心</span>
        <span class="kt">var</span> <span class="n">wi</span> <span class="p">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">Identity</span> <span class="k">as</span> <span class="n">WindowsIdentity</span><span class="p">;</span>

        <span class="c1">// 将组 SID 转换为显示名称</span>
        <span class="kt">var</span> <span class="n">groups</span> <span class="p">=</span> <span class="n">wi</span><span class="p">.</span><span class="n">Groups</span><span class="p">.</span><span class="n">Translate</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">NTAccount</span><span class="p">));</span>
        <span class="kt">var</span> <span class="n">roles</span> <span class="p">=</span> <span class="n">groups</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Claim</span><span class="p">(</span><span class="n">JwtClaimTypes</span><span class="p">.</span><span class="n">Role</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">Value</span><span class="p">));</span>
        <span class="n">id</span><span class="p">.</span><span class="n">AddClaims</span><span class="p">(</span><span class="n">roles</span><span class="p">);</span>


        <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignInAsync</span><span class="p">(</span>
            <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">ExternalCookieAuthenticationScheme</span><span class="p">,</span>
            <span class="k">new</span> <span class="nf">ClaimsPrincipal</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
            <span class="n">props</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">Redirect</span><span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">RedirectUri</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// 触发 windows auth</span>
        <span class="c1">// 因为 windows auth 不支持重定向 uri，</span>
        <span class="c1">// 当我们调用 challenge 时会重新触发这个 URL</span>
        <span class="k">return</span> <span class="nf">Challenge</span><span class="p">(</span><span class="s">&quot;Windows&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/signout"></span><div class="section" id="id1">
<h2>注销<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>注销 IdentityServer 就像删除身份验证 cookie 一样简单，但是要进行完整的联合注销，我们还必须考虑将用户从客户端应用程序（甚至可能是上游身份提供商）中注销。</p>
<div class="section" id="cookie">
<h3>删除身份验证 cookie<a class="headerlink" href="#cookie" title="永久链接至标题">¶</a></h3>
<p>要删除身份验证 cookie，只需在 <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code> 上使用 <code class="docutils literal notranslate"><span class="pre">SignOutAsync</span></code> 扩展方法。
您将需要传递使用的方案（由 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.DefaultCookieAuthenticationScheme</span></code> 提供，除非您已更改它）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignOutAsync</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">DefaultCookieAuthenticationScheme</span><span class="p">);</span>
</pre></div>
</div>
<p>或者您可以使用 IdentityServer 提供的便捷扩展方法:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignOutAsync</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>通常，您应该提示用户注销（意味着需要 POST），否则攻击者可能会热链接到您的注销页面，从而导致用户自动注销。</p>
</div>
</div>
<div class="section" id="id2">
<h3>通知客户端用户已注销<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>作为注销过程的一部分，您需要确保通知客户端应用程序用户已注销。
IdentityServer 支持服务器测客户端（例如 MVC）的 <a class="reference external" href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">前端渠道</a> 规范，
服务器端客户端（例如 MVC）的 <a class="reference external" href="https://openid.net/specs/openid-connect-backchannel-1_0.html">后端渠道</a> 规范，
以及基于浏览器的 JavaScript 客户端（例如 SPA、React、Angular 等）的 <a class="reference external" href="https://openid.net/specs/openid-connect-session-1_0.html">会话管理</a> 规范。</p>
<p><strong>前端渠道 服务器端客户端</strong></p>
<p>要通过前端渠道规范从服务器端客户端应用程序中注销用户，IdentityServer 中的 <code class="docutils literal notranslate"><span class="pre">注销</span></code> 页面必须呈现一个 <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code> 以通知客户端用户已注销。
希望收到通知的客户端必须设置 <code class="docutils literal notranslate"><span class="pre">FrontChannelLogoutUri</span></code> 配置值。
IdentityServer 跟踪用户登录了哪些客户端，并在 <code class="docutils literal notranslate"><span class="pre">IIdentityServerInteractionService</span></code> （<a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">详情</span></a>）上提供了一个名为 <code class="docutils literal notranslate"><span class="pre">GetLogoutContextAsync</span></code> 的 API。
此 API 返回一个带有 <code class="docutils literal notranslate"><span class="pre">SignOutIFrameUrl</span></code> 属性的 <code class="docutils literal notranslate"><span class="pre">LogoutRequest</span></code> 对象，您的注销页面必须将其呈现到 <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code> 中。</p>
<p><strong>后端渠道 服务器端客户端</strong></p>
<p>要通过后端渠道规范从服务器端客户端应用程序注销用户，可以使用 <code class="docutils literal notranslate"><span class="pre">IBackChannelLogoutService</span></code> 服务。
当您的注销页面通过调用 <code class="docutils literal notranslate"><span class="pre">HttpContext.SignOutAsync</span></code> 删除用户的身份验证 cookie 时，IdentityServer 将自动使用此服务。
希望收到通知的客户端必须设置 <code class="docutils literal notranslate"><span class="pre">BackChannelLogoutUri</span></code> 配置值。</p>
<p><strong>基于浏览器的 JavaScript 客户端</strong></p>
<p>鉴于 <a class="reference external" href="https://openid.net/specs/openid-connect-session-1_0.html">会话管理</a>  规范是如何设计的，在 IdentityServer 中，您不需要做什么特殊的事情来通知这些客户端用户已注销。
但是，客户端必须对 <cite>check_session_iframe</cite> 执行监控，这是由 <a class="reference external" href="https://github.com/IdentityModel/oidc-client-js/">oidc-client JavaScript 库</a> 实现的。</p>
</div>
<div class="section" id="id7">
<h3>由客户端应用程序发起的注销<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>如果注销是由客户端应用程序发起的，那么客户端首先将用户重定向到 <a class="reference internal" href="index.html#refendsession"><span class="std std-ref">结束会话端点</span></a>。
结束会话端点的处理可能需要在重定向到注销页面的过程中维护一些临时状态（例如，客户端的注销后重定向 uri）。
此状态可能对注销页面有用，并且该状态的标识符通过 <cite>logoutId</cite> 参数传递到注销页面。</p>
<p><a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">交互服务</span></a> 上的 <code class="docutils literal notranslate"><span class="pre">GetLogoutContextAsync</span></code> API 可用于加载状态。
对 <code class="docutils literal notranslate"><span class="pre">LogoutRequest</span></code> 模型上下文类感兴趣的是 <code class="docutils literal notranslate"><span class="pre">ShowSignoutPrompt</span></code>，它指示注销请求是否已通过身份验证，因此不提示用户注销是安全的。</p>
<p>默认情况下，此状态作为通过 <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> 值传递的受保护数据结构进行管理。
如果您希望在结束会话端点和注销页面之间使用其他持久性，那么您可以实现 <code class="docutils literal notranslate"><span class="pre">IMessageStore&lt;LogoutMessage&gt;</span></code> 并在 DI 中注册实现。</p>
</div>
</div>
<span id="document-topics/signout_external_providers"></span><div class="section" id="id1">
<h2>注销外部身份提供商<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>当用户从 IdentityServer <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">注销</span></a> 时，如果他们使用了 <a class="reference internal" href="index.html#refexternalidentityproviders"><span class="std std-ref">外部身份提供商</span></a> 登录，则很可能还应该将他们重定向到注销外部提供商。
并非所有外部提供商都支持注销，因为这取决于他们支持的协议和功能。</p>
<p>检测用户是否必须重定向到外部身份提供商以进行注销，通常是通过使用在 IdentityServer 的 cookie 中发出的 <code class="docutils literal notranslate"><span class="pre">idp</span></code> 声明来完成的。
设置到此声明中的值是相应身份验证中间件的 <code class="docutils literal notranslate"><span class="pre">AuthenticationScheme</span></code>。
在注销时，将咨询此声明以了解是否需要外部注销。</p>
<p>由于正常注销工作流已经需要清理和状态管理，因此将用户重定向到外部身份提供者是有问题的。
完成 IdentityServer 的正常注销和清理过程的唯一方法是，从外部身份提供商请求在其注销后，将用户重定向回 IdentityServer。
并非所有外部提供商都支持注销后重定向，因为这取决于它们支持的协议和功能。</p>
<p>注销时的工作流程是撤销 IdentityServer 的身份验证 cookie，然后重定向到请求注销后重定向的外部提供商。
注销后重定向应保持 <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">此处</span></a> 描述的必要注销状态（即 <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> 参数值）。
要在外部提供商注销后重定向回 IdentityServer，例如，当使用 ASP.NET Core 的 <code class="docutils literal notranslate"><span class="pre">SignOutAsync</span></code> API 时，应在 <code class="docutils literal notranslate"><span class="pre">AuthenticationProperties</span></code> 上使用 <code class="docutils literal notranslate"><span class="pre">RedirectUri</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[HttpPost]</span>
<span class="na">[ValidateAntiForgeryToken]</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="n">Logout</span><span class="p">(</span><span class="n">LogoutInputModel</span> <span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 建立一个模型，以便注销页面知道要显示什么</span>
    <span class="kt">var</span> <span class="n">vm</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_account</span><span class="p">.</span><span class="n">BuildLoggedOutViewModelAsync</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">LogoutId</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">User</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">?.</span><span class="n">Identity</span><span class="p">.</span><span class="n">IsAuthenticated</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 删除本地认证cookie</span>
        <span class="k">await</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">SignOutAsync</span><span class="p">();</span>

        <span class="c1">// 引发注销事件</span>
        <span class="k">await</span> <span class="n">_events</span><span class="p">.</span><span class="n">RaiseAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">UserLogoutSuccessEvent</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">GetSubjectId</span><span class="p">(),</span> <span class="n">user</span><span class="p">.</span><span class="n">GetName</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="c1">// 检查我们是否需要在上游身份提供商处触发注销</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vm</span><span class="p">.</span><span class="n">TriggerExternalSignout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 构建一个返回 URL，以便上游提供商在用户注销后重定向回我们。</span>
        <span class="c1">// 这样我们就可以完成单点注销处理。</span>
        <span class="kt">string</span> <span class="n">url</span> <span class="p">=</span> <span class="n">Url</span><span class="p">.</span><span class="n">Action</span><span class="p">(</span><span class="s">&quot;Logout&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">logoutId</span> <span class="p">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">LogoutId</span> <span class="p">});</span>

        <span class="c1">// 这将触发重定向到外部提供商以进行注销</span>
        <span class="k">return</span> <span class="nf">SignOut</span><span class="p">(</span><span class="k">new</span> <span class="n">AuthenticationProperties</span> <span class="p">{</span> <span class="n">RedirectUri</span> <span class="p">=</span> <span class="n">url</span> <span class="p">},</span> <span class="n">vm</span><span class="p">.</span><span class="n">ExternalAuthenticationScheme</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nf">View</span><span class="p">(</span><span class="s">&quot;LoggedOut&quot;</span><span class="p">,</span> <span class="n">vm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一旦用户从外部提供商注销，然后重定向回来，IdentityServer 上的正常注销处理就应该执行，这包括处理 <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> 并进行所有必要的清理。</p>
</div>
<span id="document-topics/signout_federated"></span><div class="section" id="id1">
<h2>联合注销<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>联合注销是指用户使用外部身份提供商登录 IdentityServer，然后用户通过 IdentityServer 未知的工作流注销该外部身份提供商的情景。
当用户退出时，IdentityServer 会收到通知，以便它可以让用户注销 IdentityServer 和所有使用 IdentityServer 的应用程序。</p>
<p>并非所有外部身份提供商都支持联合注销，但支持联合注销的提供商将提供一种机制来通知客户端用户已注销。
此通知通常以来请求的形式出现在外部身份提供商的 <code class="docutils literal notranslate"><span class="pre">注销</span></code> 页面的 <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code> 中。
IdentityServer 随后必须通知它的所有客户端（如 <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">此处</span></a> 所述），通常也是以来请求的形式从外部身份提供商的 <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code> 中的发出通知。</p>
<p>使联合注销成为一种特殊情况（与正常的 <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">注销</span></a> 相比）的原因是，联合注销请求不属于 IdentityServer 中的正常注销端点。
事实上，每个外部 IdentityProvider 在您的 IdentityServer 主机中都有一个不同的端点。
这是因为每个外部身份提供商可能使用不同的协议，并且每个中间件侦听不同的端点。</p>
<p>所有这些因素的最终效果是，没有像我们在正常注销工作流中那样呈现 <code class="docutils literal notranslate"><span class="pre">注销</span></code> 页面，
这意味着我们错过了 IdentityServer 客户端的注销通知。
我们必须为每个联合注销端点添加代码，以呈现实现联合注销所需的通知。</p>
<p>幸运的是 IdentityServer 已经包含了此代码。
当请求进入 IdentityServer 并调用外部身份验证提供商的处理程序时，IdentityServer 会检测这些是否是联合注销请求，如果是，它将自动呈现与 <a class="reference internal" href="index.html#refsignout"><span class="std std-ref">此处描述的注销</span></a> 相同的 <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code>。
简而言之，自动支持联合注销。</p>
</div>
<span id="document-topics/federation_gateway"></span><div class="section" id="id1">
<h2>联合网关<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>一种常见的体系结构是所谓的联合网关。 在这种方法中，IdentityServer 充当一个或多个外部身份提供商的网关。</p>
<img alt="_images/federation_gateway.png" src="_images/federation_gateway.png" />
<p>这种体系结构有以下优点</p>
<ul class="simple">
<li><p>您的应用程序只需要知道一个令牌服务（网关），并且不需要了解有关连接到外部提供商的所有详细信息。 这也意味着您可以添加或更改这些外部提供商，而无需更新您的应用程序。</p></li>
<li><p>您可以控制网关（与某些外部服务提供商相反）—— 这意味着您可以对其进行任何更改，并可以保护您的应用程序免受这些外部提供商可能对其自己的服务所做的更改。</p></li>
<li><p>大多数外部提供商只支持一组固定的声明和声明类型 —— 中间有一个网关允许对来自提供商的响应进行后处理以转换/添加/修改特定于域的身份信息。</p></li>
<li><p>一些提供商不支持访问令牌（例如社交提供者）—— 因为网关知道你的 API，它可以根据外部身份发布访问令牌。</p></li>
<li><p>一些提供商根据您连接到他们的应用程序数量收费。 网关充当外部提供商的单个应用程序。 在内部，您可以根据需要连接任意数量的应用程序。</p></li>
<li><p>一些提供商使用专有协议或对标准协议进行专有修改 —— 使用网关，您只需要处理一个地方。</p></li>
<li><p>强制每个身份验证（内部或外部）都通过一个地方，这在身份映射方面为您提供了极大的灵活性，为您的所有应用程序提供了稳定的身份，并可以处理新的需求</p></li>
</ul>
<p>换句话说 —— 拥有联合网关可以让您对身份基础设施进行大量控制。 由于您的用户身份是您最重要的资产之一，我们建议您控制网关。</p>
<div class="section" id="id2">
<h3>执行<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>我们的 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">快速启动 UI</a> 利用了以下一些功能。
另请查看 <a class="reference internal" href="index.html#refexternalauthenticationquickstart"><span class="std std-ref">外部身份验证快速入门</span></a> 和有关 <a class="reference internal" href="index.html#refexternalidentityproviders"><span class="std std-ref">外部提供商</span></a> 的文档。</p>
<ul class="simple">
<li><p>您可以通过向 IdentityServer 应用程序添加身份验证处理程序来添加对外部身份提供商的支持。</p></li>
<li><p>您可以通过调用 <code class="docutils literal notranslate"><span class="pre">IAuthenticationSchemeProvider</span></code> 以编程方式查询这些外部提供商。 这允许根据注册的外部提供商动态呈现您的登录页面。</p></li>
<li><p>我们的客户端配置模型允许在每个客户端的基础上限制可用的提供商（使用 <code class="docutils literal notranslate"><span class="pre">IdentityProviderRestrictions</span></code> 属性）。</p></li>
<li><p>您还可以使用客户端上的 <code class="docutils literal notranslate"><span class="pre">EnableLocalLogin</span></code> 属性来告诉您的 UI 是否应呈现 用户名/密码 输入。</p></li>
<li><p>我们的快速入门 UI 通过一次回调（请参阅“AccountController”类中的“ExternalLoginCallback”）来传递所有外部身份验证调用。 这允许单点进行后处理。</p></li>
</ul>
</div>
</div>
<span id="document-topics/consent"></span><div class="section" id="id1">
<h2>同意<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在授权请求期间，如果 IdentityServer 需要用户同意，浏览器将被重定向到同意页面。</p>
<p>同意用于允许最终用户授予客户端对资源（<a class="reference internal" href="index.html#refidentityresource"><span class="std std-ref">identity</span></a> 或 <a class="reference internal" href="index.html#refapiresource"><span class="std std-ref">API</span></a>）的访问权限。
这通常只对第三方客户端是必需的，并且可以在 <a class="reference internal" href="index.html#refclient"><span class="std std-ref">客户端设置</span></a> 上为每个客户端启用/禁用。</p>
<div class="section" id="id2">
<h3>同意页面<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>为了让用户同意，托管应用程序必须提供同意页面。
<a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">快速启动</a> 有一个同意页面的基本实现。</p>
<p>同意页面通常会呈现当前用户的显示名称，
请求访问的客户端的显示名称，
客户端的 Logo，
有关客户端的更多信息的链接
以及客户端请求访问的资源列表。
允许用户表明他们的同意应该被“记住”也是很常见的，这样以后就不会为同一客户端再次提示他们了。</p>
<p>一旦用户提供了同意，同意页面必须通知 IdentityServer 同意，然后浏览器必须重定向回授权端点。</p>
</div>
<div class="section" id="id4">
<h3>授权上下文<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 将一个 <cite>returnUrl</cite> 参数（可在 <a class="reference internal" href="index.html#refoptions"><span class="std std-ref">用户交互选项</span></a> 上配置）传递到包含授权请求参数的同意页面。
这些参数提供同意页面的上下文，可以在 <a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">交互服务</span></a> 的帮助下读取。
<code class="docutils literal notranslate"><span class="pre">GetAuthorizationContextAsync</span></code> API 将返回一个 <code class="docutils literal notranslate"><span class="pre">AuthorizationRequest</span></code> 的实例。</p>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 接口获取有关客户端或资源的其他详细信息。</p>
</div>
<div class="section" id="identityserver">
<h3>将同意结果通知 IdentityServer<a class="headerlink" href="#identityserver" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">交互服务</span></a> 上的 <code class="docutils literal notranslate"><span class="pre">GrantConsentAsync</span></code> API 允许同意页面通知 IdentityServer 同意的结果（也可能是拒绝客户端访问）。</p>
<p>IdentityServer 将暂时保留同意的结果。
默认情况下，此持久性使用 cookie，因为它只需要持续足够长的时间即可将结果传送回授权端点。
这种临时持久性不同于用于“记住我的同意”功能的持久性（授权端点为用户维持“记住我的同意”）。
如果您希望在同意页面和授权重定向之间使用其他持久性，那么您可以实现 <code class="docutils literal notranslate"><span class="pre">IMessageStore&lt;ConsentResponse&gt;</span></code> 并在 DI 中注册实现。</p>
</div>
<div class="section" id="id5">
<h3>将用户返回到授权端点<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>一旦同意页面将结果通知 IdentityServer，用户就可以被重定向回 <cite>returnUrl</cite>。
您的同意页面应通过验证 <cite>returnUrl</cite> 是否有效来防止打开重定向。
这可以通过在 <a class="reference internal" href="index.html#refinteractionservice"><span class="std std-ref">交互服务</span></a> 上调用 <code class="docutils literal notranslate"><span class="pre">IsValidReturnUrl</span></code> 来完成。
此外，如果 <code class="docutils literal notranslate"><span class="pre">GetAuthorizationContextAsync</span></code> 返回非空结果，那么您也可以相信 <cite>returnUrl</cite> 是有效的。</p>
</div>
</div>
<span id="document-topics/apis"></span><div class="section" id="api">
<h2>保护 API<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 默认以 <a class="reference external" href="https://tools.ietf.org/html/rfc7519">JWT</a> （JSON Web 令牌）格式发布访问令牌。</p>
<p>现在每个相关平台都支持验证 JWT 令牌，可以在 <a class="reference external" href="https://jwt.io">此处</a> 找到一个很好的 JWT 库列表。
流行的类库如:</p>
<ul class="simple">
<li><p>用于 ASP.NET Core 的 <a class="reference external" href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer/">JWT bearer 身份验证处理程序</a></p></li>
<li><p>用于 Katana 的 <a class="reference external" href="https://www.nuget.org/packages/Microsoft.Owin.Security.Jwt">JWT bearer 身份验证中间件</a></p></li>
</ul>
<p>保护基于 ASP.NET Core 的 API 只是添加 JWT bearer 身份验证处理程序的问题:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="n">JwtBearerDefaults</span><span class="p">.</span><span class="n">AuthenticationScheme</span><span class="p">)</span>
            <span class="p">.</span><span class="n">AddJwtBearer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="c1">// 您的 IdentityServer 的基地址</span>
                <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://demo.identityserver.io&quot;</span><span class="p">;</span>

                <span class="c1">// 如果您使用的是 API 资源，可以在此处指定名称</span>
                <span class="n">options</span><span class="p">.</span><span class="n">Audience</span> <span class="p">=</span> <span class="s">&quot;resource1&quot;</span><span class="p">;</span>

                <span class="c1">// 默认情况下 IdentityServer 发出一个 typ 标头，建议额外检查</span>
                <span class="n">options</span><span class="p">.</span><span class="n">TokenValidationParameters</span><span class="p">.</span><span class="n">ValidTypes</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;at+jwt&quot;</span> <span class="p">};</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您没有使用受众声明，您可以通过 <code class="docutils literal notranslate"><span class="pre">options.TokenValidationParameters.ValidateAudience</span> <span class="pre">=</span> <span class="pre">false;</span></code> 关闭受众检查。 有关资源、范围、受众和授权的更多信息，请参见 <a class="reference internal" href="index.html#refapiresources"><span class="std std-ref">此处</span></a>。</p>
</div>
<div class="section" id="id3">
<h3>验证引用令牌<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>如果您使用引用令牌，则需要一个实现 <a class="reference external" href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 令牌自省</a> 的身份验证处理程序，例如 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel.AspNetCore.OAuth2Introspection">这样</a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddOAuth2Introspection</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="n">Constants</span><span class="p">.</span><span class="n">Authority</span><span class="p">;</span>

        <span class="c1">// 这映射到 API 资源名称和密钥</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;resource1&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>支持 JWT 和引用令牌<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>您可以设置 ASP.NET Core 以根据传入的令牌分派到正确的处理程序，有关更多信息，请参阅 <a class="reference external" href="https://leastprivilege.com/2020/07/06/flexible-access-token-validation-in-asp-net-core/">这篇</a> 博客文章。
在这种情况下，您设置一个默认处理程序和一些转发逻辑，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">)</span>

    <span class="c1">// JWT 令牌</span>
    <span class="p">.</span><span class="n">AddJwtBearer</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="n">Constants</span><span class="p">.</span><span class="n">Authority</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Audience</span> <span class="p">=</span> <span class="s">&quot;resource1&quot;</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">TokenValidationParameters</span><span class="p">.</span><span class="n">ValidTypes</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;at+jwt&quot;</span> <span class="p">};</span>

        <span class="c1">// 如果令牌不包含点，则为引用令牌</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ForwardDefaultSelector</span> <span class="p">=</span> <span class="n">Selector</span><span class="p">.</span><span class="n">ForwardReferenceToken</span><span class="p">(</span><span class="s">&quot;introspection&quot;</span><span class="p">);</span>
    <span class="p">})</span>

    <span class="c1">// 引用令牌</span>
    <span class="p">.</span><span class="n">AddOAuth2Introspection</span><span class="p">(</span><span class="s">&quot;introspection&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="n">Constants</span><span class="p">.</span><span class="n">Authority</span><span class="p">;</span>

        <span class="n">options</span><span class="p">.</span><span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;resource1&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/deployment"></span><div class="section" id="id1">
<h2>部署<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>您的身份服务器 <cite>只是</cite> 一个包含 IdentityServer 中间件的标准 ASP.NET Core 应用程序。
请先阅读有关发布和部署的 Microsoft 官方 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/publishing">文档</a>
（尤其是有关负载平衡器和代理的 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-2.2#scenarios-and-use-cases">部分</a>）。</p>
<div class="section" id="id4">
<h3>典型架构<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>通常，您将设计 IdentityServer 部署以实现高可用性:</p>
<img alt="_images/deployment.png" src="_images/deployment.png" />
<p>IdentityServer 本身是无状态的，不需要服务器关联 —— 但需要在实例之间共享数据。</p>
</div>
<div class="section" id="id5">
<h3>配置数据<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>这通常包括:</p>
<ul class="simple">
<li><p>资源</p></li>
<li><p>客户端</p></li>
<li><p>启动配置，例如 密钥材料、外部供应商设置等…</p></li>
</ul>
<p>您存储该数据的方式取决于您的环境。 在配置数据很少更改的情况下，我们建议使用内存存储和代码或配置文件。</p>
<p>在高度动态的环境（例如 Saas）中，我们建议使用数据库或配置服务来动态加载配置。</p>
<p>IdentityServer 支持开箱即用的代码配置和配置文件（参见 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">此处</a>）。
对于数据库，我们提供对基于 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.EntityFramework">Entity Framework Core</a> 的数据库的支持。</p>
<p>您还可以通过实现 <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code> 来构建自己的配置存储。</p>
</div>
<div class="section" id="id7">
<h3>密钥材料<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>启动配置的另一个重要部分是您的密钥材料，有关密钥材料和密码学的更多详细信息，请参见 <a class="reference internal" href="index.html#refcrypto"><span class="std std-ref">此处</span></a>。</p>
</div>
<div class="section" id="id8">
<h3>操作数据<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>对于某些操作，IdentityServer 需要一个持久化存储来保持状态，这包括:</p>
<ul class="simple">
<li><p>颁发授权码</p></li>
<li><p>颁发引用令牌和刷新令牌</p></li>
<li><p>存储同意</p></li>
</ul>
<p>您可以使用传统数据库来存储操作数据，也可以使用具有持久性功能（如 Redis）的缓存。
上面提到的 EF Core 实现也支持操作数据。</p>
<p>您还可以通过实现 <code class="docutils literal notranslate"><span class="pre">IPersistedGrantStore</span></code> 来实现对您自己的自定义存储机制的支持 —— 默认情况下，IdentityServer 注入内存版本。</p>
</div>
<div class="section" id="asp-net-core">
<h3>ASP.NET Core 数据保护<a class="headerlink" href="#asp-net-core" title="永久链接至标题">¶</a></h3>
<p>ASP.NET Core 本身需要共享密钥材料来保护敏感数据，如 cookie、状态字符串等。
请参阅官方文档 <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/">这里</a>。</p>
<p>如果可能的话，您可以重用上述持久性存储之一，也可以使用一些简单的东西，例如共享文件。</p>
</div>
<div class="section" id="id10">
<h3>ASP.NET Core 分布式缓存<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>某些组件依赖于 ASP.NET Core 分布式缓存。 为了在多服务器环境中工作，需要正确设置。
<a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed/">官方文档</a> 描述了几个选项。</p>
<p>以下组件依赖于 <code class="docutils literal notranslate"><span class="pre">IDistributedCache</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">services.AddOidcStateDataFormatterCache()</span></code> 配置 OpenIdConnect 处理程序以将状态参数持久化到服务器端 <code class="docutils literal notranslate"><span class="pre">IDistributedCache</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DefaultReplayCache</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DistributedDeviceFlowThrottlingService</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DistributedCacheAuthorizationParametersMessageStore</span></code></p></li>
</ul>
</div>
</div>
<span id="document-topics/logging"></span><div class="section" id="id1">
<h2>日志<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 使用 ASP.NET Core 提供的标准日志记录工具。
Microsoft <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging">文档</a> 有一个很好的介绍和内置日志提供程序的描述。</p>
<p>我们大致遵循 Microsoft 的日志级别使用指南：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Trace</span></code> 用于仅对开发人员解决问题有价值的信息。 这些消息可能包含敏感的应用程序数据，如令牌，不应在生产环境中启用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Debug</span></code> 用于遵循内部流程并理解做出某些决定的原因。 在开发和调试期间有短期的用处。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Information</span></code> 用于跟踪应用程序的一般流程。 这些日志通常具有一些长期价值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Warning</span></code> 用于应用程序流中的异常或意外事件。 这些可能包括不会导致应用程序停止但可能需要调查的错误或其他情况。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Error</span></code> 用于无法处理的错误和异常。 示例：协议请求验证失败。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Critical</span></code> 用于需要立即关注的故障。 示例：缺少存储实现、无效的密钥材料…</p></li>
</ul>
<div class="section" id="serilog">
<h3>Serilog 的设置<a class="headerlink" href="#serilog" title="永久链接至标题">¶</a></h3>
<p>我们个人非常喜欢 <a class="reference external" href="https://serilog.net/">Serilog</a> 和 <code class="docutils literal notranslate"><span class="pre">Serilog.AspNetCore</span></code> 包。 试一试:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Activity</span><span class="p">.</span><span class="n">DefaultIdFormat</span> <span class="p">=</span> <span class="n">ActivityIdFormat</span><span class="p">.</span><span class="n">W3C</span><span class="p">;</span>

        <span class="n">Log</span><span class="p">.</span><span class="n">Logger</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LoggerConfiguration</span><span class="p">()</span>
            <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="n">Debug</span><span class="p">()</span>
            <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="n">Override</span><span class="p">(</span><span class="s">&quot;Microsoft&quot;</span><span class="p">,</span> <span class="n">LogEventLevel</span><span class="p">.</span><span class="n">Warning</span><span class="p">)</span>
            <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="n">Override</span><span class="p">(</span><span class="s">&quot;Microsoft.Hosting.Lifetime&quot;</span><span class="p">,</span> <span class="n">LogEventLevel</span><span class="p">.</span><span class="n">Information</span><span class="p">)</span>
            <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="n">Override</span><span class="p">(</span><span class="s">&quot;System&quot;</span><span class="p">,</span> <span class="n">LogEventLevel</span><span class="p">.</span><span class="n">Warning</span><span class="p">)</span>
            <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="n">Override</span><span class="p">(</span><span class="s">&quot;Microsoft.AspNetCore.Authentication&quot;</span><span class="p">,</span> <span class="n">LogEventLevel</span><span class="p">.</span><span class="n">Information</span><span class="p">)</span>
            <span class="p">.</span><span class="n">Enrich</span><span class="p">.</span><span class="n">FromLogContext</span><span class="p">()</span>
            <span class="p">.</span><span class="n">WriteTo</span><span class="p">.</span><span class="n">Console</span><span class="p">(</span><span class="n">outputTemplate</span><span class="p">:</span> <span class="s">&quot;[{Timestamp:HH:mm:ss} {Level}] {SourceContext}{NewLine}{Message:lj}{NewLine}{Exception}{NewLine}&quot;</span><span class="p">,</span> <span class="n">theme</span><span class="p">:</span> <span class="n">AnsiConsoleTheme</span><span class="p">.</span><span class="n">Code</span><span class="p">)</span>
            <span class="p">.</span><span class="n">CreateLogger</span><span class="p">();</span>

        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">Log</span><span class="p">.</span><span class="n">Information</span><span class="p">(</span><span class="s">&quot;Starting host...&quot;</span><span class="p">);</span>
            <span class="n">CreateHostBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">Build</span><span class="p">().</span><span class="n">Run</span><span class="p">();</span>
            <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Log</span><span class="p">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">&quot;Host terminated unexpectedly.&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="n">Log</span><span class="p">.</span><span class="n">CloseAndFlush</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IHostBuilder</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">Microsoft</span><span class="p">.</span><span class="n">Extensions</span><span class="p">.</span><span class="n">Hosting</span><span class="p">.</span><span class="n">Host</span><span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="p">.</span><span class="n">UseSerilog</span><span class="p">()</span>
            <span class="p">.</span><span class="n">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webBuilder</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">webBuilder</span><span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
            <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/events"></span><div class="section" id="id1">
<h2>事件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>虽然日志记录是更低级别的 “printf” 样式 —— 但事件表示有关 IdentityServer 中某些操作的更高级别信息。
事件是结构化数据，包括事件 ID、成功/失败信息、类别和详细信息。
这使得查询和分析它们并提取可用于进一步处理的有用信息变得容易。</p>
<p>事件与诸如 <a class="reference external" href="https://www.elastic.co/webinars/introduction-elk-stack">ELK</a>、 <a class="reference external" href="https://getseq.net/">Seq</a> 或 <a class="reference external" href="https://www.splunk.com/">Splunk</a> 之类的事件存储配合得很好。</p>
<div class="section" id="id2">
<h3>发出事件<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>默认情况下没有打开事件 —— 但可以在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 方法中全局配置，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Events</span><span class="p">.</span><span class="n">RaiseSuccessEvents</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Events</span><span class="p">.</span><span class="n">RaiseFailureEvents</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Events</span><span class="p">.</span><span class="n">RaiseErrorEvents</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>要发出事件，请使用 DI 容器中的 <code class="docutils literal notranslate"><span class="pre">IEventService</span></code> 并调用 <code class="docutils literal notranslate"><span class="pre">RaiseAsync</span></code> 方法，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="n">Login</span><span class="p">(</span><span class="n">LoginInputModel</span> <span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_users</span><span class="p">.</span><span class="n">ValidateCredentials</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">Username</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">Password</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 发出带有 subject ID 和 username 的身份验证 cookie</span>
        <span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="n">_users</span><span class="p">.</span><span class="n">FindByUsername</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">Username</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">_events</span><span class="p">.</span><span class="n">RaiseAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">UserLoginSuccessEvent</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">Username</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">SubjectId</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">Username</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">_events</span><span class="p">.</span><span class="n">RaiseAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">UserLoginFailureEvent</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">Username</span><span class="p">,</span> <span class="s">&quot;invalid credentials&quot;</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sinks">
<h3>自定义 sinks<a class="headerlink" href="#sinks" title="永久链接至标题">¶</a></h3>
<p>我们的默认事件接收器将简单地将事件类序列化为 JSON，并将其转发到 ASP.NET Core 日志记录系统。
如果要连接到自定义事件存储，请实现 <code class="docutils literal notranslate"><span class="pre">IEventSink</span></code> 接口并将其注册到 DI。</p>
<p>以下示例使用 <a class="reference external" href="https://getseq.net/">Seq</a> 来发出事件:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span> <span class="k">public</span> <span class="k">class</span> <span class="nc">SeqEventSink</span> <span class="p">:</span> <span class="n">IEventSink</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Logger</span> <span class="n">_log</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">SeqEventSink</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_log</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LoggerConfiguration</span><span class="p">()</span>
            <span class="p">.</span><span class="n">WriteTo</span><span class="p">.</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;http://localhost:5341&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">CreateLogger</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span> <span class="nf">PersistAsync</span><span class="p">(</span><span class="n">Event</span> <span class="n">evt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="p">.</span><span class="n">EventType</span> <span class="p">==</span> <span class="n">EventTypes</span><span class="p">.</span><span class="n">Success</span> <span class="p">||</span>
            <span class="n">evt</span><span class="p">.</span><span class="n">EventType</span> <span class="p">==</span> <span class="n">EventTypes</span><span class="p">.</span><span class="n">Information</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_log</span><span class="p">.</span><span class="n">Information</span><span class="p">(</span><span class="s">&quot;{Name} ({Id}), Details: {@details}&quot;</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">_log</span><span class="p">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;{Name} ({Id}), Details: {@details}&quot;</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span>
                <span class="n">evt</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">Serilog.Sinks.Seq</span></code> 包添加到您的主机以使上述代码工作。</p>
</div>
<div class="section" id="id4">
<h3>内置事件<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 中定义了以下事件:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ApiAuthenticationFailureEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">ApiAuthenticationSuccessEvent</span></code></dt><dd><p>在内省端点处为成功/失败的 API 身份验证引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientAuthenticationSuccessEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">ClientAuthenticationFailureEvent</span></code></dt><dd><p>在令牌端点处为成功/失败的客户端身份验证引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TokenIssuedSuccessEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">TokenIssuedFailureEvent</span></code></dt><dd><p>为尝试请求身份令牌、访问令牌、刷新令牌和授权代码的成功/失败引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TokenIntrospectionSuccessEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">TokenIntrospectionFailureEvent</span></code></dt><dd><p>为成功的令牌自省请求引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TokenRevokedSuccessEvent</span></code></dt><dd><p>为成功的令牌吊销请求引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserLoginSuccessEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">UserLoginFailureEvent</span></code></dt><dd><p>由成功/失败的用户登录的快速入门 UI 引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserLogoutSuccessEvent</span></code></dt><dd><p>为成功的注销请求引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ConsentGrantedEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">ConsentDeniedEvent</span></code></dt><dd><p>在同意 UI 中引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UnhandledExceptionEvent</span></code></dt><dd><p>为未处理的异常引发。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DeviceAuthorizationFailureEvent</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">DeviceAuthorizationSuccessEvent</span></code></dt><dd><p>为成功/失败的设备授权请求引发。</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h3>自定义事件<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>您可以创建自己的事件并通过我们的基础设施发出它们。</p>
<p>您需要从我们的基础 <code class="docutils literal notranslate"><span class="pre">Event</span></code> 类派生，该类注入上下文信息，如 activity ID、timestamp 等。
然后您的派生类可以添加特定于事件上下文的任意数据字段:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">UserLoginFailureEvent</span> <span class="p">:</span> <span class="n">Event</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">UserLoginFailureEvent</span><span class="p">(</span><span class="kt">string</span> <span class="n">username</span><span class="p">,</span> <span class="kt">string</span> <span class="n">error</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">EventCategories</span><span class="p">.</span><span class="n">Authentication</span><span class="p">,</span>
                <span class="s">&quot;User Login Failure&quot;</span><span class="p">,</span>
                <span class="n">EventTypes</span><span class="p">.</span><span class="n">Failure</span><span class="p">,</span>
                <span class="n">EventIds</span><span class="p">.</span><span class="n">UserLoginFailure</span><span class="p">,</span>
                <span class="n">error</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Username</span> <span class="p">=</span> <span class="n">username</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Username</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/crypto"></span><div class="section" id="https">
<h2>密码学、密钥和 HTTPS<a class="headerlink" href="#https" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 依靠几种加密机制来完成其工作。</p>
<div class="section" id="id1">
<h3>令牌签名和验证<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 需要一个非对称密钥对来签名和验证 JWT。
此密钥材料可以打包为证书，也可以打包为原始密钥。
支持 RSA 和 ECDSA 密钥，支持的签名算法有：RS256、RS384、RS512、PS256、PS384、PS512、ES256、ES384 和 ES512。</p>
<p>您可以同时使用多个签名密钥，但每种算法仅支持一个签名密钥。
您注册的第一个签名密钥被视为默认签名密钥。</p>
<p><a class="reference internal" href="index.html#refclient"><span class="std std-ref">客户端</span></a> 和 <a class="reference internal" href="index.html#refapiresource"><span class="std std-ref">API 资源</span></a> 都可以表达对签名算法的偏好。
如果您为多个 API 资源请求一个令牌，则所有资源都需要就至少一种允许的签名算法达成一致。</p>
<p>签名密钥和相应的验证部分的加载是通过 <code class="docutils literal notranslate"><span class="pre">ISigningCredentialStore</span></code> 和 <code class="docutils literal notranslate"><span class="pre">IValidationKeysStore</span></code> 的实现来完成的。
如果您想自定义密钥的加载，您可以实现这些接口并将它们注册到 DI。</p>
<p>DI 构建器扩展有几个方便的方法来设置签名和验证密钥 —— 请参阅 <a class="reference internal" href="index.html#refstartupkeymaterial"><span class="std std-ref">此处</span></a>。</p>
</div>
<div class="section" id="id2">
<h3>签名密钥滚动更新<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>虽然您一次只能使用一个签名密钥，但您可以向发现文档发布多个验证密钥。
这对于密钥滚动更新很有用。</p>
<p>简而言之，滚动更新通常是这样工作的：</p>
<ol class="arabic simple">
<li><p>您请求/创建新的密钥材料</p></li>
<li><p>除了当前的验证密钥之外，您还可以发布新的验证密钥。 您可以使用 <code class="docutils literal notranslate"><span class="pre">AddValidationKey</span></code> 构建器扩展方法进行此操作。</p></li>
<li><p>所有客户端和 API 现在都有机会在下次更新发现文档的本地副本时了解新密钥</p></li>
<li><p>经过一段时间（例如 24 小时）后，所有客户端和 API 现在都应该同时接受旧的和新的密钥材料</p></li>
<li><p>旧的密钥材料您想保留多久就保留多久，也许您有需要验证的长期令牌</p></li>
<li><p>当旧密钥材料不再使用时将其报废</p></li>
<li><p>所有客户端和 API 将在下次更新发现文档的本地副本时“忘记”旧密钥</p></li>
</ol>
<p>这要求客户端和 API 使用发现文档，并且还具有定期刷新其配置的功能。</p>
<p>Brock 写了一篇关于密钥轮换的更详细的 <a class="reference external" href="https://brockallen.com/2019/08/09/identityserver-and-signing-key-rotation/">博客文章</a>，
还创建了一个 <a class="reference external" href="https://www.identityserver.com/products/keymanagement">商业组件</a>，可以自动处理所有这些细节。</p>
</div>
<div class="section" id="id5">
<h3>数据保护<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>ASP.NET Core 中的 Cookie 身份验证（或 MVC 中的 anti-forgery）使用 ASP.NET Core 数据保护功能。
根据您的部署方案，这可能需要额外的配置。 有关更多信息，请参阅 Microsoft <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/configuration/overview">文档</a>。</p>
</div>
<div class="section" id="id7">
<h3>HTTPS<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>我们不强制使用 HTTPS，但对于生产环境，与 IdentityServer 的每次交互都是强制性的。</p>
</div>
</div>
<span id="document-topics/grant_types"></span><div class="section" id="id1">
<h2>授权类型<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>OpenID Connect 和 OAuth 2.0 规范定义了所谓的授权类型（通常也称为流程 —— 或协议流程）。
授权类型指定客户端如何与令牌服务交互。</p>
<p>您需要通过 <code class="docutils literal notranslate"><span class="pre">Client</span></code> 配置上的 <code class="docutils literal notranslate"><span class="pre">AllowedGrantTypes</span></code> 属性指定客户端可以使用哪些授权类型。
这允许锁定 给定客户端所允许的 协议交互。</p>
<p>客户端可以配置为使用多种授权类型（例如，用于以用户为中心的操作的授权码流程 和 用于服务器到服务器通信的客户端凭据）。
<code class="docutils literal notranslate"><span class="pre">GrantTypes</span></code> 类可用于从典型的授权类型组合中进行选择:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Client</span><span class="p">.</span><span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">CodeAndClientCredentials</span><span class="p">;</span>
</pre></div>
</div>
<p>您还可以手动指定授权类型列表:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Client</span><span class="p">.</span><span class="n">AllowedGrantTypes</span> <span class="p">=</span>
<span class="p">{</span>
    <span class="n">GrantType</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>
    <span class="n">GrantType</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
    <span class="s">&quot;my_custom_grant_type&quot;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>虽然 IdentityServer 支持所有标准授权类型，但对于常见的应用场景，您实际上只需要了解其中的两种。</p>
<div class="section" id="id2">
<h3>机器到机器通信<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>这是最简单的通信类型。 始终代表客户端请求令牌，不存在交互式用户。</p>
<p>在这种情况下，您使用 <code class="docutils literal notranslate"><span class="pre">client</span> <span class="pre">credentials</span></code> 授权类型向令牌端点发送令牌请求。
客户端通常必须使用其客户端 ID 和密钥对令牌端点进行身份验证。</p>
<p>有关如何使用它的示例，请参阅 <a class="reference internal" href="index.html#refclientcredentialsquickstart"><span class="std std-ref">客户端凭据快速入门</span></a>。</p>
</div>
<div class="section" id="id3">
<h3>交互式客户端<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>这是最常见的客户端场景类型：具有交互式用户的 Web 应用程序、SPA 或原生/移动应用程序。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您不关心所有技术细节，请随意跳至摘要。</p>
</div>
<p>针对此类客户端，设计了 <code class="docutils literal notranslate"><span class="pre">authorization</span> <span class="pre">code</span></code> 流程。 该流程包含两个物理操作：</p>
<ul class="simple">
<li><p>通过浏览器的前端渠道步骤，所有”交互式“事情都会发生，例如 登录页面、同意等。此步骤产生一个代表前端渠道操作结果的授权码。</p></li>
<li><p>一个后端渠道步骤，其中步骤 1 中的授权码与请求的令牌交换。 机密客户端此时需要进行身份验证。</p></li>
</ul>
<p>此流程具有以下安全属性：</p>
<ul class="simple">
<li><p>没有数据（除了基本上是随机字符串的授权码）通过浏览器渠道泄露</p></li>
<li><p>授权码只能使用一次</p></li>
<li><p>只有在（对于机密客户端 —— 稍后会详细介绍）客户端密钥已知时，授权码才能转换为令牌</p></li>
</ul>
<p>这听起来很不错 —— 仍然有一个叫做 <a class="reference external" href="https://nat.sakimura.org/2016/01/25/cut-and-pasted-code-attack-in-oauth-2-0-rfc6749/">代码替换攻击</a> 的问题。
对此，有两种现代缓解技术：</p>
<p><strong>OpenID Connect 混合流程</strong></p>
<p>此流程使用 <code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">id_token</span></code> 的响应类型来向响应添加额外的身份标识。 此令牌已签名并受到保护以防止替换。
此外，它还通过 <code class="docutils literal notranslate"><span class="pre">c_hash</span></code> 声明包含代码的哈希值。 这允许检查您是否确实获得了正确的代码（专家称之为分离签名）。</p>
<p>这解决了问题，但有以下缺点：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_token</span></code> 通过前端渠道传输，可能会泄露额外的（个人身份）数据</p></li>
<li><p>所有缓解步骤（例如加密）都需要由客户端实施。 这导致更复杂的客户端库实现。</p></li>
</ul>
<p><strong>RFC 7636 - Proof Key for Code Exchange (PKCE)</strong></p>
<p>这实质上为授权码流程引入了每个请求的密钥（请阅读 <a class="reference external" href="https://tools.ietf.org/html/rfc7636">此处</a> 的详细信息）。
为此，客户端所必须要实现的就是创建一个随机字符串并使用 SHA256 对其进行哈希。</p>
<p>这也解决了替换问题，因为客户端可以证明它是前后渠道上的同一个客户端，并且具有以下附加优势：</p>
<ul class="simple">
<li><p>与混合流程相比，客户端实现非常简单</p></li>
<li><p>它还解决了公共客户端没有静态密钥的问题</p></li>
<li><p>不需要额外的前端渠道响应伪像</p></li>
</ul>
<p><strong>总结</strong></p>
<p>交互式客户端应使用基于授权码的流程。 为了防止代码替换，应该使用混合流程或 PKCE。
如果 PKCE 可用，这是解决问题的更简单的方法。</p>
<p>PKCE 已经是对 <a class="reference external" href="https://tools.ietf.org/html/rfc8252#section-6">原生</a> 应用程序
和 <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-03#section-4">SPAs</a> 的官方推荐
—— 随着 ASP.NET Core 3 的发布，OpenID Connect 处理程序也默认支持。</p>
<p>以下是如何配置交互式客户端:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;...&quot;</span><span class="p">,</span>

    <span class="c1">// 为机密客户端设置客户端密钥</span>
    <span class="n">ClientSecret</span> <span class="p">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>

    <span class="c1">// ...或为公共客户端关闭</span>
    <span class="n">RequireClientSecret</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span>
    <span class="n">RequirePkce</span> <span class="p">=</span> <span class="k">true</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>没有浏览器或输入设备受限的交互式客户端<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>此授权类型在 <a class="reference external" href="https://tools.ietf.org/html/rfc8628">RFC 8628</a> 中有详细说明。</p>
<p>此流程将用户身份验证和同意外包给外部设备（例如智能手机）。
它通常由没有真正的键盘（如电视、游戏机…）并且可以请求身份和 API 资源的设备使用。</p>
</div>
<div class="section" id="id8">
<h3>自定义场景<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>扩展授权允许使用新的授权类型扩展令牌端点。 有关更多详细信息，请参阅 <a class="reference internal" href="index.html#refextensiongrants"><span class="std std-ref">此内容</span></a>。</p>
</div>
</div>
<span id="document-topics/client_authentication"></span><div class="section" id="id1">
<h2>客户端认证<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在某些情况下，客户端需要使用 IdentityServer 进行身份验证，例如</p>
<ul class="simple">
<li><p>机密应用程序（又名客户端）在令牌端点请求令牌</p></li>
<li><p>在内省端点验证参考令牌的 API</p></li>
</ul>
<p>为此，您可以将密钥列表分配给客户端或 API 资源。</p>
<p>密钥解析和验证是身份服务器中的一个扩展点，开箱即用，
它支持共享秘密以及通过基本身份验证标头或 POST 正文传输共享秘密。</p>
<div class="section" id="id2">
<h3>创建共享密钥<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>以下代码设置哈希共享密钥:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">secret</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">());</span>
</pre></div>
</div>
<p>这个密钥现在可以分配给 <code class="docutils literal notranslate"><span class="pre">客户端</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code>。
Notice that both do not only support a single secret, but multiple. This is useful for secret rollover and rotation:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Secret</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">secret</span> <span class="p">},</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
    <span class="n">AllowedScopes</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;api2&quot;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>事实上，您还可以为密钥分配描述和到期日期。
描述将用于日志记录，以及强制执行密钥生命周期的到期日期:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">secret</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span>
    <span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">(),</span>
    <span class="s">&quot;2016 secret&quot;</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">DateTime</span><span class="p">(</span><span class="m">2016</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">31</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>使用共享密钥进行身份验证<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>您可以将客户端 ID/密钥组合作为 POST 正文的一部分发送:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">token</span>

<span class="n">client_id</span><span class="p">=</span><span class="n">client1</span><span class="p">&amp;</span>
<span class="n">client_secret</span><span class="p">=</span><span class="n">secret</span><span class="p">&amp;</span>
<span class="p">...</span>
</pre></div>
</div>
<p>..或者作为一个基本的认证头:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">token</span>

<span class="n">Authorization</span><span class="p">:</span> <span class="n">Basic</span> <span class="n">xxxxx</span>

<span class="p">...</span>
</pre></div>
</div>
<p>您可以使用以下 C# 代码手动创建基本身份验证标头:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">credentials</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0}:{1}&quot;</span><span class="p">,</span> <span class="n">clientId</span><span class="p">,</span> <span class="n">clientSecret</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">headerValue</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToBase64String</span><span class="p">(</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">credentials</span><span class="p">));</span>

<span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
<span class="n">client</span><span class="p">.</span><span class="n">DefaultRequestHeaders</span><span class="p">.</span><span class="n">Authorization</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AuthenticationHeaderValue</span><span class="p">(</span><span class="s">&quot;Basic&quot;</span><span class="p">,</span> <span class="n">headerValue</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/IdentityModel/IdentityModel">IdentityModel</a> 库有名为 <code class="docutils literal notranslate"><span class="pre">TokenClient</span></code> 和 <code class="docutils literal notranslate"><span class="pre">IntrospectionClient</span></code> 的辅助类，它们封装了身份验证和协议消息。</p>
</div>
<div class="section" id="id4">
<h3>使用非对称密钥进行身份验证<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>There are other techniques to authenticate clients, e.g. based on public/private key cryptography.
IdentityServer includes support for private key JWT client secrets (see <a class="reference external" href="https://tools.ietf.org/html/rfc7523">RFC 7523</a>
and <a class="reference external" href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">here</a>).</p>
<p>Secret extensibility typically consists of three things:</p>
<ul class="simple">
<li><p>a secret definition</p></li>
<li><p>a secret parser that knows how to extract the secret from the incoming request</p></li>
<li><p>a secret validator that knows how to validate the parsed secret based on the definition</p></li>
</ul>
<p>Secret parsers and validators are implementations of the <code class="docutils literal notranslate"><span class="pre">ISecretParser</span></code> and <code class="docutils literal notranslate"><span class="pre">ISecretValidator</span></code> interfaces.
To make them available to IdentityServer, you need to register them with the DI container, e.g.:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">AddSecretParser</span><span class="p">&lt;</span><span class="n">JwtBearerClientAssertionSecretParser</span><span class="p">&gt;()</span>
<span class="n">builder</span><span class="p">.</span><span class="n">AddSecretValidator</span><span class="p">&lt;</span><span class="n">PrivateKeyJwtSecretValidator</span><span class="p">&gt;()</span>
</pre></div>
</div>
<p>Our default private key JWT secret validator expects the full (leaf) certificate as base64 on the secret definition
or an ESA/EC JSON web key:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client.jwt&quot;</span><span class="p">,</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="n">Secret</span>
        <span class="p">{</span>
            <span class="n">Type</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">SecretTypes</span><span class="p">.</span><span class="n">X509CertificateBase64</span><span class="p">,</span>
            <span class="n">Value</span> <span class="p">=</span> <span class="s">&quot;MIIDATCCAe2gAwIBAgIQoHUYAquk9rBJcq8W+F0FAzAJBgUrDgMCHQUAMBIxEDAOBgNVBAMTB0RldlJvb3QwHhcNMTAwMTIwMjMwMDAwWhcNMjAwMTIwMjMwMDAwWjARMQ8wDQYDVQQDEwZDbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDSaY4x1eXqjHF1iXQcF3pbFrIbmNw19w/IdOQxbavmuPbhY7jX0IORu/GQiHjmhqWt8F4G7KGLhXLC1j7rXdDmxXRyVJBZBTEaSYukuX7zGeUXscdpgODLQVay/0hUGz54aDZPAhtBHaYbog+yH10sCXgV1Mxtzx3dGelA6pPwiAmXwFxjJ1HGsS/hdbt+vgXhdlzud3ZSfyI/TJAnFeKxsmbJUyqMfoBl1zFKG4MOvgHhBjekp+r8gYNGknMYu9JDFr1ue0wylaw9UwG8ZXAkYmYbn2wN/CpJl3gJgX42/9g87uLvtVAmz5L+rZQTlS1ibv54ScR2lcRpGQiQav/LAgMBAAGjXDBaMBMGA1UdJQQMMAoGCCsGAQUFBwMCMEMGA1UdAQQ8MDqAENIWANpX5DZ3bX3WvoDfy0GhFDASMRAwDgYDVQQDEwdEZXZSb290ghAsWTt7E82DjU1E1p427Qj2MAkGBSsOAwIdBQADggEBADLje0qbqGVPaZHINLn+WSM2czZk0b5NG80btp7arjgDYoWBIe2TSOkkApTRhLPfmZTsaiI3Ro/64q+Dk3z3Kt7w+grHqu5nYhsn7xQFAQUf3y2KcJnRdIEk0jrLM4vgIzYdXsoC6YO+9QnlkNqcN36Y8IpSVSTda6gRKvGXiAhu42e2Qey/WNMFOL+YzMXGt/nDHL/qRKsuXBOarIb++43DV3YnxGTx22llhOnPpuZ9/gnNY7KLjODaiEciKhaKqt/b57mTEz4jTF4kIg6BP03MUfDXeVlM1Qf1jB43G2QQ19n5lUiqTpmQkcfLfyci2uBZ8BkOhXr3Vk9HIk/xBXQ=&quot;</span>
        <span class="p">}</span>
        <span class="k">new</span> <span class="n">Secret</span>
        <span class="p">{</span>
            <span class="n">Type</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">SecretTypes</span><span class="p">.</span><span class="n">JsonWebKey</span><span class="p">,</span>
            <span class="n">Value</span> <span class="p">=</span> <span class="s">&quot;{&#39;e&#39;:&#39;AQAB&#39;,&#39;kid&#39;:&#39;ZzAjSnraU3bkWGnnAqLapYGpTyNfLbjbzgAPbbW2GEA&#39;,&#39;kty&#39;:&#39;RSA&#39;,&#39;n&#39;:&#39;wWwQFtSzeRjjerpEM5Rmqz_DsNaZ9S1Bw6UbZkDLowuuTCjBWUax0vBMMxdy6XjEEK4Oq9lKMvx9JzjmeJf1knoqSNrox3Ka0rnxXpNAz6sATvme8p9mTXyp0cX4lF4U2J54xa2_S9NF5QWvpXvBeC4GAJx7QaSw4zrUkrc6XyaAiFnLhQEwKJCwUw4NOqIuYvYp_IXhw-5Ti_icDlZS-282PcccnBeOcX7vc21pozibIdmZJKqXNsL1Ibx5Nkx1F1jLnekJAmdaACDjYRLL_6n3W4wUp19UvzB1lGtXcJKLLkqB6YDiZNu16OSiSprfmrRXvYmvD8m6Fnl5aetgKw&#39;}&quot;</span>
        <span class="p">}</span>
    <span class="p">},</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span><span class="p">,</span> <span class="s">&quot;api2&quot;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/extension_grants"></span><div class="section" id="id1">
<h2>扩展授权<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>OAuth 2.0 定义了令牌端点的标准授权类型，例如 <code class="docutils literal notranslate"><span class="pre">password</span></code>、<code class="docutils literal notranslate"><span class="pre">authorization_code</span></code> 和 <code class="docutils literal notranslate"><span class="pre">refresh_token</span></code>。 扩展授权是一种添加对非标准令牌发行方案（如令牌转换、委派或自定义凭据）的支持的方法。</p>
<p>您可以通过实现 <code class="docutils literal notranslate"><span class="pre">IExtensionGrantValidator</span></code> 接口来添加对其他授权类型的支持:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IExtensionGrantValidator</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 处理自定义授权请求。</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;request&quot;&gt;验证上下文。&lt;/param&gt;</span>
    <span class="n">Task</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="n">ExtensionGrantValidationContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 返回此验证器可以处理的授权类型</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;value&gt;</span>
    <span class="c1">/// 授权类型。</span>
    <span class="c1">/// &lt;/value&gt;</span>
    <span class="kt">string</span> <span class="n">GrantType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ExtensionGrantValidationContext</span></code> 对象使您可以访问：</p>
<ul class="simple">
<li><p>传入的令牌请求 —— 众所周知的验证值，以及任何自定义值（通过 <code class="docutils literal notranslate"><span class="pre">Raw</span></code> 集合）</p></li>
<li><p>结果 —— 错误或成功</p></li>
<li><p>自定义响应参数</p></li>
</ul>
<p>要注册扩展授权，请将其添加到 DI:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">AddExtensionGrantValidator</span><span class="p">&lt;</span><span class="n">MyExtensionsGrantValidator</span><span class="p">&gt;();</span>
</pre></div>
</div>
<div class="section" id="id2">
<h3>示例：使用扩展授权的简单委托<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>想象以下场景 —— 前端客户端使用通过交互流程（例如混合流程）获取的令牌调用中间层 API。
这个中间层 API (API 1) 现在想要代表交互式用户调用后端 API (API 2)：</p>
<img alt="_images/delegation.png" src="_images/delegation.png" />
<p>换句话说，中间层 API (API 1) 需要一个包含用户身份的访问令牌，但具有后端 API (API 2) 的范围。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可能听说过 <em>穷人的委托</em> 一词，其中来自前端的访问令牌只是简单地转发到后端。 这有一些缺点，例如 <em>API 2</em> 现在必须接受 <em>API 1</em> 范围，这将允许用户直接调用 <em>API 2</em>。 此外 —— 您可能希望在令牌中添加一些特定于委托的声明，例如 调用路径是通过 <em>API 1</em> 的事实。</p>
</div>
<p><strong>实现扩展授权</strong></p>
<p>前端会将令牌发送到 API 1，现在这个令牌需要在 IdentityServer 上与 API 2 的新令牌交换。</p>
<p>在网络上，对交换令牌服务的调用可能如下所示:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">token</span>

<span class="n">grant_type</span><span class="p">=</span><span class="n">delegation</span><span class="p">&amp;</span>
<span class="n">scope</span><span class="p">=</span><span class="n">api2</span><span class="p">&amp;</span>
<span class="n">token</span><span class="p">=...&amp;</span>
<span class="n">client_id</span><span class="p">=</span><span class="n">api1</span><span class="p">.</span><span class="n">client</span>
<span class="n">client_secret</span><span class="p">=</span><span class="n">secret</span>
</pre></div>
</div>
<p>扩展授权验证器的工作是通过验证传入的令牌来处理该请求，并返回代表新令牌的结果:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">DelegationGrantValidator</span> <span class="p">:</span> <span class="n">IExtensionGrantValidator</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ITokenValidator</span> <span class="n">_validator</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">DelegationGrantValidator</span><span class="p">(</span><span class="n">ITokenValidator</span> <span class="n">validator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_validator</span> <span class="p">=</span> <span class="n">validator</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">GrantType</span> <span class="p">=&gt;</span> <span class="s">&quot;delegation&quot;</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="n">ExtensionGrantValidationContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">userToken</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Raw</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">userToken</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">GrantValidationResult</span><span class="p">(</span><span class="n">TokenRequestErrors</span><span class="p">.</span><span class="n">InvalidGrant</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_validator</span><span class="p">.</span><span class="n">ValidateAccessTokenAsync</span><span class="p">(</span><span class="n">userToken</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">GrantValidationResult</span><span class="p">(</span><span class="n">TokenRequestErrors</span><span class="p">.</span><span class="n">InvalidGrant</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 获取用户身份</span>
        <span class="kt">var</span> <span class="n">sub</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">Claims</span><span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Type</span> <span class="p">==</span> <span class="s">&quot;sub&quot;</span><span class="p">).</span><span class="n">Value</span><span class="p">;</span>

        <span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">GrantValidationResult</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">GrantType</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不要忘记向 DI 注册验证器。</p>
<p><strong>注册委托客户端</strong></p>
<p>您需要在 IdentityServer 中进行客户端注册，以允许客户端使用此新扩展授权，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;api1.client&quot;</span><span class="p">,</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Secret</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span>
    <span class="p">},</span>

    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;delegation&quot;</span> <span class="p">},</span>

    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="s">&quot;api2&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>调用令牌端点</strong></p>
<p>在 API 1 中，您现在可以自己构建 HTTP 负载，或使用 <em>IdentityModel</em> 帮助程序库:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TokenResponse</span><span class="p">&gt;</span> <span class="n">DelegateAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">userToken</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="n">_httpClientFactory</span><span class="p">.</span><span class="n">CreateClient</span><span class="p">();</span>
    <span class="c1">// 或者</span>
    <span class="c1">// var client = new HttpClient();</span>

    <span class="c1">// 向令牌端点发送自定义授权，返回响应</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">RequestTokenAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">TokenRequest</span>
    <span class="p">{</span>
        <span class="n">Address</span> <span class="p">=</span> <span class="n">disco</span><span class="p">.</span><span class="n">TokenEndpoint</span><span class="p">,</span>
        <span class="n">GrantType</span> <span class="p">=</span> <span class="s">&quot;delegation&quot;</span><span class="p">,</span>

        <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;api1.client&quot;</span><span class="p">,</span>
        <span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">,</span>

        <span class="n">Parameters</span> <span class="p">=</span>
        <span class="p">{</span>
            <span class="p">{</span> <span class="s">&quot;scope&quot;</span><span class="p">,</span> <span class="s">&quot;api2&quot;</span> <span class="p">},</span>
            <span class="p">{</span> <span class="s">&quot;token&quot;</span><span class="p">,</span> <span class="n">userToken</span><span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TokenResponse.AccessToken</span></code> 现在将包含委托访问令牌。</p>
</div>
</div>
<span id="document-topics/resource_owner"></span><div class="section" id="id1">
<h2>资源所有者密码验证<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>如果要使用 OAuth 2.0 资源所有者密码凭据授予（又名 <code class="docutils literal notranslate"><span class="pre">password</span></code>），则需要实现并注册 <code class="docutils literal notranslate"><span class="pre">IResourceOwnerPasswordValidator</span></code> 接口:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IResourceOwnerPasswordValidator</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 验证资源所有者密码凭据</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;context&quot;&gt;上下文。&lt;/param&gt;</span>
    <span class="n">Task</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="n">ResourceOwnerPasswordValidationContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在上下文中，您会发现已经解析的协议参数，如 <code class="docutils literal notranslate"><span class="pre">UserName</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Password</span></code>，如果您想查看其他输入数据，还会找到原始请求。</p>
<p>然后你的工作是实现密码验证并相应地在上下文中设置 <code class="docutils literal notranslate"><span class="pre">Result</span></code>。 请参阅 <a class="reference internal" href="index.html#refgrantvalidationresult"><span class="std std-ref">GrantValidationResult</span></a> 文档。</p>
</div>
<span id="document-topics/refresh_tokens"></span><div class="section" id="id1">
<h2>刷新令牌<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>由于访问令牌的生命周期有限，刷新令牌允许在没有用户交互的情况下请求新的访问令牌。</p>
<p>以下流支持刷新令牌：授权代码、混合和资源所有者密码凭证流。
客户端需要通过将 <code class="docutils literal notranslate"><span class="pre">AllowOfflineAccess</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">true</span></code> ，明确授权请求刷新令牌。</p>
<div class="section" id="id2">
<h3>其他客户端设置<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">AbsoluteRefreshTokenLifetime</span></code></dt><dd><p>刷新令牌的最长生命周期（以秒为单位）。 默认为 2592000 秒 / 30 天。 0 允许刷新令牌，当与 <code class="docutils literal notranslate"><span class="pre">RefreshTokenExpiration</span> <span class="pre">=</span> <span class="pre">Sliding</span></code> 一起使用时，仅在经过 SlidingRefreshTokenLifetime 后过期。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SlidingRefreshTokenLifetime</span></code></dt><dd><p>刷新令牌的滑动生命周期（以秒为单位）。 默认为 1296000 秒 / 15</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RefreshTokenUsage</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ReUse</span></code> 刷新令牌时刷新令牌句柄将保持不变</p>
<p><code class="docutils literal notranslate"><span class="pre">OneTimeOnly</span></code> 刷新令牌时将更新刷新令牌句柄</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RefreshTokenExpiration</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">Absolute</span></code> 刷新令牌将在固定时间点（由 AbsoluteRefreshTokenLifetime 指定）到期。 这是默认设置。</p>
<p><code class="docutils literal notranslate"><span class="pre">Sliding</span></code> 刷新令牌时，刷新令牌的生命周期将更新（按 SlidingRefreshTokenLifetime 中指定的数量）。 生命周期不会超过 <cite>AbsoluteRefreshTokenLifetime</cite>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UpdateAccessTokenClaimsOnRefresh</span></code></dt><dd><p>获取或设置一个值，该值指示是否应在刷新令牌请求时更新访问令牌（及其声明）。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>公共客户端（没有客户端密钥的客户端）应该轮换他们的刷新令牌。 将 <code class="docutils literal notranslate"><span class="pre">RefreshTokenUsage</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">OneTimeOnly</span></code>。</p>
</div>
</div>
<div class="section" id="id3">
<h3>请求刷新令牌<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>您可以通过向 scope 参数添加一个名为 <code class="docutils literal notranslate"><span class="pre">offline_access</span></code> 的范围来请求刷新令牌。</p>
</div>
<div class="section" id="id4">
<h3>使用刷新令牌请求访问令牌<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>要获取新的访问令牌，请将刷新令牌发送到令牌端点。
这将产生一个新的令牌响应，其中包含一个新的访问令牌及其过期时间，并且可能还会产生一个新的刷新令牌，具体取决于客户端配置（见上文）。</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">token</span>

    <span class="n">client_id</span><span class="p">=</span><span class="n">client</span><span class="p">&amp;</span>
    <span class="n">client_secret</span><span class="p">=</span><span class="n">secret</span><span class="p">&amp;</span>
    <span class="n">grant_type</span><span class="p">=</span><span class="n">refresh_token</span><span class="p">&amp;</span>
    <span class="n">refresh_token</span><span class="p">=</span><span class="n">hdh922</span>
</pre></div>
</div>
<p>(删除了表单编码并添加了换行符以提高可读性)</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问令牌端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/token.html">文档</a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>刷新令牌必须有效，否则会返回 invalid_grant 错误。 默认情况下，refresh_token 只能使用一次。 使用已使用的 refresh_token 将导致 invalid_grant 错误。</p>
</div>
</div>
<div class="section" id="id6">
<h3>自定义刷新令牌行为<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>所有刷新令牌处理都在 <code class="docutils literal notranslate"><span class="pre">DefaultRefreshTokenService``（这是</span> <span class="pre">``IRefreshTokenService</span></code> 接口的默认实现）中实现:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IRefreshTokenService</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 验证刷新令牌。</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="n">TokenValidationResult</span><span class="p">&gt;</span> <span class="n">ValidateRefreshTokenAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">token</span><span class="p">,</span> <span class="n">Client</span> <span class="n">client</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 创建刷新令牌。</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">CreateRefreshTokenAsync</span><span class="p">(</span><span class="n">ClaimsPrincipal</span> <span class="n">subject</span><span class="p">,</span> <span class="n">Token</span> <span class="n">accessToken</span><span class="p">,</span> <span class="n">Client</span> <span class="n">client</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 更新刷新令牌。</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">UpdateRefreshTokenAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">handle</span><span class="p">,</span> <span class="n">RefreshToken</span> <span class="n">refreshToken</span><span class="p">,</span> <span class="n">Client</span> <span class="n">client</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>刷新令牌处理的逻辑相当复杂，我们不建议从头开始实现接口，
除非你完全知道自己在做什么。
如果要自定义某些行为，更建议从默认实现派生并首先调用基本检查。</p>
<p>您可能想要做的最常见的定制是如何处理刷新令牌重放。
这适用于令牌使用已设置为仅一次的情况，但同一令牌被多次发送。
这可能指向刷新令牌的重放攻击，或者指向错误的客户端代码，如逻辑错误或竞争条件。</p>
<p>需要注意的是，刷新令牌永远不会在数据库中删除。
一旦被使用，<code class="docutils literal notranslate"><span class="pre">ConsumedTime</span></code> 属性将被设置。
如果收到一个已经被消费的令牌，默认服务将调用一个名为 <code class="docutils literal notranslate"><span class="pre">AcceptConsumedTokenAsync</span></code> 的虚拟方法。</p>
<p>默认实现将拒绝请求，但在这里您可以实现自定义逻辑，如宽限期，
或撤销额外的刷新或访问令牌。</p>
</div>
</div>
<span id="document-topics/reference_tokens"></span><div class="section" id="id1">
<h2>引用令牌<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>访问令牌可以有两种形式 - 独立的或引用的。</p>
<p>JWT 令牌将是一个自包含的访问令牌 - 它是一种受保护的数据结构，具有声明和过期时间。
一旦 API 了解了密钥材料，它就可以验证自包含的令牌，而无需与发行者进行通信。
这使得 JWT 难以撤销。 它们将一直有效，直到到期。</p>
<p>使用引用令牌时 - IdentityServer 会将令牌的内容存储在数据存储中，并且只会将此令牌的唯一标识符返回给客户端。
然后，接收此引用的 API 必须打开与 IdentityServer 的反向通道通信以验证令牌。</p>
<img alt="_images/reference_tokens.png" src="_images/reference_tokens.png" />
<p>您可以使用以下设置切换客户端的令牌类型:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">client</span><span class="p">.</span><span class="n">AccessTokenType</span> <span class="p">=</span> <span class="n">AccessTokenType</span><span class="p">.</span><span class="n">Reference</span><span class="p">;</span>
</pre></div>
</div>
<p>IdentityServer 提供了 OAuth 2.0 自省规范的实现，它允许 API 取消引用令牌。
您可以使用我们专用的 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel.AspNetCore.OAuth2Introspection">自省处理程序</a>
或使用可以验证 JWT 和引用令牌的 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.AccessTokenValidation">Identity Server 身份验证处理程序</a>。</p>
<p>自省端点需要身份验证 - 由于自省端点的客户端是一个 API，您可以在 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 上配置密钥:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">api</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ApiResource</span><span class="p">(</span><span class="s">&quot;api1&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ApiSecrets</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Secret</span><span class="p">(</span><span class="s">&quot;secret&quot;</span><span class="p">.</span><span class="n">Sha256</span><span class="p">())</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有关如何为 API 配置 IdentityServer 身份验证中间件的更多信息，请参阅 <a class="reference internal" href="index.html#refprotectingapis"><span class="std std-ref">此处</span></a>。</p>
</div>
<span id="document-topics/persisted_grants"></span><div class="section" id="id1">
<h2>持久授权<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>许多授权类型需要在 IdentityServer 中持久化。
其中包括授权代码、刷新令牌、参考令牌和记住的用户同意。
在 IdentityServer 内部，这些授权的默认存储位于称为持久授权存储的公共存储中。</p>
<div class="section" id="id2">
<h3>持久授权<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>持久授权是维护授权值的数据类型。
它具有以下属性：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Key</span></code></dt><dd><p>存储中持久授权的唯一标识符。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Type</span></code></dt><dd><p>授权的类型。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SubjectId</span></code></dt><dd><p>授予所属的主体 ID。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientId</span></code></dt><dd><p>为其创建授权的客户端标识符。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>用户分配给授权或被授权设备的描述。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CreationTime</span></code></dt><dd><p>创建授权的日期/时间。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Expiration</span></code></dt><dd><p>授权到期。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ConsumedTime</span></code></dt><dd><p>授权 <code class="docutils literal notranslate"><span class="pre">已消耗</span></code> 的日期/时间（见下文）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Data</span></code></dt><dd><p>授权特定的序列化数据。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">Data</span></code> 属性包含所有值（以及更多）的副本，并且被 IdentityServer 认为是权威的，因此默认情况下，上述值被认为是信息性的只读值。</p>
</div>
<p>存在于存储中，没有 <code class="docutils literal notranslate"><span class="pre">ConsumedTime</span></code> 且仍在 <code class="docutils literal notranslate"><span class="pre">Expiration</span></code> 内的记录，表示授权的有效性。
设置这两个值中的任何一个，或者从存储中删除记录，都可以有效地撤销授权。</p>
</div>
<div class="section" id="id3">
<h3>授权消费<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>某些授权类型只能一次性使用（根据定义或配置）。
一旦它们被 <code class="docutils literal notranslate"><span class="pre">使用</span></code>，而不是删除记录，<code class="docutils literal notranslate"><span class="pre">ConsumedTime</span></code> 值被设置在数据库中，将它们标记为已被使用。
这种 <code class="docutils literal notranslate"><span class="pre">软删除</span></code> 允许自定义实现 在允许重新使用授权方面 具有灵活性（通常在很短的时间内），
或用于风险评估和威胁缓解方案（检测到可疑活动）以撤销访问。
对于刷新令牌，此类自定义逻辑将在 <code class="docutils literal notranslate"><span class="pre">IRefreshTokenService</span></code> 中执行。</p>
</div>
<div class="section" id="id4">
<h3>持久授权服务<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>直接使用授权存储可能级别太低。
因此，提供了一个名为 <code class="docutils literal notranslate"><span class="pre">IPersistedGrantService</span></code> 的更高级别的服务。
它将不同的授权类型抽象并聚合到一个概念中，并允许查询和撤销用户的持久授权。</p>
<p>它包含以下 API：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetAllGrantsAsync</span></code></dt><dd><p>根据主体 ID 获取用户的所有授权。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RemoveAllGrantsAsync</span></code></dt><dd><p>根据主体 id 和可选的客户端 id 和/或会话 id 从存储中删除授权。</p>
</dd>
</dl>
</div>
</div>
<span id="document-topics/pop"></span><div class="section" id="id1">
<h2>访问令牌所有权证明<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>默认情况下，OAuth 访问令牌称为 <em>bearer</em> 令牌。 这意味着它们不受客户的约束，任何拥有令牌的人都可以使用它（与现金相比）。</p>
<p><em>所有权证明 Proof-of-Possession (short PoP)</em> 令牌绑定到请求令牌的客户端。 如果该令牌泄漏，则其他任何人都无法使用它（与信用卡相比 - 至少在理想世界中如此）。</p>
<p>有关更多历史和动机，请参阅 <a class="reference external" href="https://leastprivilege.com/2020/01/15/oauth-2-0-the-long-road-to-proof-of-possession-access-tokens/">此</a> 博客文章。</p>
<p>IdentityServer 通过使用 <a class="reference internal" href="index.html#refmutualtls"><span class="std std-ref">Mutual TLS 机制</span></a> 支持 PoP 令牌。</p>
</div>
<span id="document-topics/mtls"></span><div class="section" id="mutual-tls">
<h2>Mutual TLS<a class="headerlink" href="#mutual-tls" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 中的双向 TLS 支持允许两个功能：</p>
<ul class="simple">
<li><p>使用 TLS X.509 客户端证书对 IdentityServer 端点进行客户端身份验证</p></li>
<li><p>使用 TLS X.509 客户端证书将访问令牌绑定到客户端</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>有关更多信息，请参阅 <a class="reference external" href="https://tools.ietf.org/html/rfc8705">“OAuth 2.0 Mutual-TLS 客户端身份验证和证书绑定访问令牌”</a> 规范</p>
</div>
<p>设置 MTLS 涉及几个步骤。</p>
<div class="section" id="id1">
<h3>服务器设置<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>托管层有责任对客户端证书进行实际验证。
IdentityServer 然后将使用该信息将证书与客户端相关联，并将证书信息嵌入到访问令牌中。</p>
<p>根据您使用的服务器，这些步骤是不同的。 有关更多信息，请参阅 <a class="reference external" href="https://leastprivilege.com/2020/02/07/mutual-tls-and-proof-of-possession-access-tokens-part-1-setup/">此</a> 博客文章。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><a class="reference external" href="https://github.com/FiloSottile/mkcert">mkcert</a> 是一个很好的工具，用于为开发目的创建证书。</p>
</div>
</div>
<div class="section" id="asp-net-core">
<h3>ASP.NET Core 设置<a class="headerlink" href="#asp-net-core" title="永久链接至标题">¶</a></h3>
<p>根据服务器设置，ASP.NET Core 主机接收客户端证书的方式不同。 而对于 IIS 和纯 Kestrel 托管，没有额外的步骤，
通常，您在应用程序服务器前面有一个反向代理。</p>
<p>这意味着除了典型的转发头处理之外，您还需要处理包含客户端证书的头。
为此，在中间件管道的开头添加对 <code class="docutils literal notranslate"><span class="pre">app.UseCertificateForwarding();</span></code> 的调用。</p>
<p>代理传输证书的确切格式没有标准化，这就是为什么您需要注册一个回调来进行实际的标头解析。
Microsoft <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.1">文档</a> 展示了 Azure Web 应用程序如何工作。</p>
<p>如果您使用的是 Nginx（我们发现它是最灵活的托管选项），您需要在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中注册以下服务</p>
<blockquote>
<div><p>services.AddCertificateForwarding(options =&gt;
{</p>
<blockquote>
<div><p>// 标头名称可能会有所不同，具体取决于您的 nginx 配置
options.CertificateHeader = “X-SSL-CERT”;</p>
<p>options.HeaderConverter = (headerValue) =&gt;
{</p>
<blockquote>
<div><p>X509Certificate2 clientCertificate = null;</p>
<p>if(!string.IsNullOrWhiteSpace(headerValue))
{</p>
<blockquote>
<div><p>var bytes = Encoding.UTF8.GetBytes(Uri.UnescapeDataString(headerValue));
clientCertificate = new X509Certificate2(bytes);</p>
</div></blockquote>
<p>}</p>
<p>return clientCertificate;</p>
</div></blockquote>
<p>};</p>
</div></blockquote>
<p>});</p>
</div></blockquote>
<p>一旦加载了证书，您还需要设置身份验证处理程序。
在这种情况下，我们希望支持自签名证书，因此是 <code class="docutils literal notranslate"><span class="pre">CertificateType.All</span></code> 并且没有吊销检查。
这些设置在您的环境中可能会有所不同:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">()</span>
    <span class="p">.</span><span class="n">AddCertificate</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">AllowedCertificateTypes</span> <span class="p">=</span> <span class="n">CertificateTypes</span><span class="p">.</span><span class="n">All</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">RevocationMode</span> <span class="p">=</span> <span class="n">X509RevocationMode</span><span class="p">.</span><span class="n">NoCheck</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="identityserver-setup">
<h3>IdentityServer setup<a class="headerlink" href="#identityserver-setup" title="永久链接至标题">¶</a></h3>
<p>下一步是在 IdentityServer 中启用 MTLS。 为此，您需要指定您在最后一步中设置的证书身份验证处理程序的名称（默认为 <code class="docutils literal notranslate"><span class="pre">Certificate</span></code>），
和 MTLS 托管策略。</p>
<p>在 IdentityServer 中，双向 TLS 端点可以通过三种方式配置（假设 IdentityServer 在 <code class="docutils literal notranslate"><span class="pre">https://identityserver.io</span></code> 上运行：</p>
<ul class="simple">
<li><p>基于路径 - 位于路径 <code class="docutils literal notranslate"><span class="pre">~/connect/mtls</span></code> 下的端点，例如 <code class="docutils literal notranslate"><span class="pre">https://identityserver.io/connect/mtls/token</span></code>。</p></li>
<li><p>基于子域名 - 端点位于主服务器的子域名上，例如 <code class="docutils literal notranslate"><span class="pre">https://mtls.identityserver.io/connect/token</span></code>。</p></li>
<li><p>基于域名 - 端点位于不同的域名中，例如 <code class="docutils literal notranslate"><span class="pre">https://identityserver-mtls.io</span></code>。</p></li>
</ul>
<p>例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">MutualTls</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">MutualTls</span><span class="p">.</span><span class="n">ClientCertificateAuthenticationScheme</span> <span class="p">=</span> <span class="s">&quot;Certificate&quot;</span><span class="p">;</span>

    <span class="c1">// 使用子域名托管</span>
    <span class="n">options</span><span class="p">.</span><span class="n">MutualTls</span><span class="p">.</span><span class="n">DomainName</span> <span class="p">=</span> <span class="s">&quot;mtls&quot;</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>IdentityServer 的发现文档反映了这些端点：</p>
<img alt="_images/mtls_endpoints.png" src="_images/mtls_endpoints.png" />
</div>
<div class="section" id="id4">
<h3>客户端认证<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>客户端可以使用 X.509 客户端证书作为 IdentityServer 中端点的身份验证机制。</p>
<p>为此，您需要将客户端证书与 IdentityServer 中的客户端相关联。
使用 <a class="reference internal" href="index.html#refstartup"><span class="std std-ref">IdentityServer builder</span></a> 将服务添加到 DI，其中包含一个默认实现来执行基于指纹或通用名称的操作:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">AddMutualTlsSecretValidators</span><span class="p">();</span>
</pre></div>
</div>
<p>最后，对于 <a class="reference internal" href="index.html#refclient"><span class="std std-ref">client 配置</span></a> 添加到 <code class="docutils literal notranslate"><span class="pre">ClientSecrets</span></code> 集合的机密类型为 <code class="docutils literal notranslate"><span class="pre">SecretTypes.X509CertificateName</span></code>。
如果您希望通过证书识别名验证客户端，或者 <code class="docutils literal notranslate"><span class="pre">SecretTypes.X509CertificateThumbprint</span></code> 如果您希望通过证书指纹验证客户端。</p>
<p>例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mtls&quot;</span><span class="p">,</span>
    <span class="n">AllowedGrantTypes</span> <span class="p">=</span> <span class="n">GrantTypes</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span>
    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;api1&quot;</span> <span class="p">}</span>
    <span class="n">ClientSecrets</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="c1">// 基于名称</span>
        <span class="k">new</span> <span class="nf">Secret</span><span class="p">(</span><span class="s">@&quot;CN=mtls.test, OU=ROO\ballen@roo, O=mkcert development certificate&quot;</span><span class="p">,</span> <span class="s">&quot;mtls.test&quot;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Type</span> <span class="p">=</span> <span class="n">SecretTypes</span><span class="p">.</span><span class="n">X509CertificateName</span>
        <span class="p">},</span>
        <span class="c1">// 或基于指纹</span>
        <span class="c1">//new Secret(&quot;bca0d040847f843c5ee0fa6eb494837470155868&quot;, &quot;mtls.test&quot;)</span>
        <span class="c1">//{</span>
        <span class="c1">//    Type = SecretTypes.X509CertificateThumbprint</span>
        <span class="c1">//},</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="identityserver">
<h4>使用客户端证书对 IdentityServer 进行身份验证<a class="headerlink" href="#identityserver" title="永久链接至标题">¶</a></h4>
<p>编写客户端以连接到 IdentityServer 时，<code class="docutils literal notranslate"><span class="pre">SocketsHttpHandler``（或</span> <span class="pre">``HttpClientHandler</span></code> 如果您使用的是较旧的 .NET Framework 版本）
类提供了一种方便的机制来将客户端证书添加到传出请求中。</p>
<p>然后使用 HttpClient 进行 HTTP 调用（包括使用各种 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 扩展方法）
将在 TLS 通道上执行客户端证书认证。</p>
<p>例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TokenResponse</span><span class="p">&gt;</span> <span class="n">RequestTokenAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SocketsHttpHandler</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">cert</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509Certificate2</span><span class="p">(</span><span class="s">&quot;client.p12&quot;</span><span class="p">,</span> <span class="s">&quot;password&quot;</span><span class="p">);</span>
    <span class="n">handler</span><span class="p">.</span><span class="n">SslOptions</span><span class="p">.</span><span class="n">ClientCertificates</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509CertificateCollection</span> <span class="p">{</span> <span class="n">cert</span> <span class="p">};</span>

    <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">disco</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetDiscoveryDocumentAsync</span><span class="p">(</span><span class="n">Constants</span><span class="p">.</span><span class="n">Authority</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">RequestClientCredentialsTokenAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">ClientCredentialsTokenRequest</span>
    <span class="p">{</span>
        <span class="n">Address</span> <span class="p">=</span> <span class="n">disco</span>
                        <span class="p">.</span><span class="n">TryGetValue</span><span class="p">(</span><span class="n">OidcConstants</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">MtlsEndpointAliases</span><span class="p">)</span>
                        <span class="p">.</span><span class="n">Value</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">OidcConstants</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">TokenEndpoint</span><span class="p">)</span>
                        <span class="p">.</span><span class="n">ToString</span><span class="p">(),</span>

        <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;mtls&quot;</span><span class="p">,</span>
        <span class="n">Scope</span> <span class="p">=</span> <span class="s">&quot;api1&quot;</span>
    <span class="p">});</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h3>发送方受限访问令牌<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>每当客户端使用客户端证书向 IdentityServer 进行身份验证时，该证书的指纹将嵌入访问令牌中。</p>
<p>在对 API 进行身份验证时，客户端可以使用 X.509 客户端证书作为发送方受限访问令牌的机制。
使用这些受发送方约束的访问令牌要求客户端使用与 IdentityServer 相同的 X.509 客户端证书对 API 进行身份验证。</p>
<div class="section" id="id6">
<h4>确认声明<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>当客户端获得访问令牌并通过双向 TLS 进行身份验证时，IdentityServer 在访问令牌中发出确认声明（或 <code class="docutils literal notranslate"><span class="pre">cnf</span></code>）。
此值是用于向 IdentityServer 进行身份验证的客户端证书指纹的哈希值。</p>
<p>可以在解码访问令牌的屏幕截图中看到此值：</p>
<img alt="_images/mtls_access_token_with_cnf.png" src="_images/mtls_access_token_with_cnf.png" />
<p>然后，API 将使用此值来确保 API 中使用的客户端证书与访问令牌中的确认值匹配。</p>
</div>
<div class="section" id="api">
<h4>在 API 中验证和接受客户端证书<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h4>
<p>如上所述，对于 IdentityServer 中的客户端身份验证，在 API 中，Web 服务器应在 TLS 层执行客户端证书验证。</p>
<p>此外，API 托管应用程序将需要一种机制来接受客户端证书，以便获取指纹以执行确认声明验证。
下面是如何为访问令牌和客户端证书配置 ASP.NET Core 中的 API 的示例:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthentication</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AddIdentityServerAuthentication</span><span class="p">(</span><span class="s">&quot;token&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">Authority</span> <span class="p">=</span> <span class="s">&quot;https://identityserver.io&quot;</span><span class="p">;</span>
        <span class="n">options</span><span class="p">.</span><span class="n">ApiName</span> <span class="p">=</span> <span class="s">&quot;api1&quot;</span><span class="p">;</span>

    <span class="p">})</span>
    <span class="p">.</span><span class="n">AddCertificate</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">options</span><span class="p">.</span><span class="n">AllowedCertificateTypes</span> <span class="p">=</span> <span class="n">CertificateTypes</span><span class="p">.</span><span class="n">All</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>最后，需要一种在身份验证中间件之后运行的机制来验证客户端证书并将指纹与访问令牌中的 <code class="docutils literal notranslate"><span class="pre">cnf</span></code> 进行比较。</p>
<p>下面是一个检查声明的简单中间件:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ConfirmationValidationMiddlewareOptions</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">CertificateSchemeName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="n">CertificateAuthenticationDefaults</span><span class="p">.</span><span class="n">AuthenticationScheme</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">JwtBearerSchemeName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="n">JwtBearerDefaults</span><span class="p">.</span><span class="n">AuthenticationScheme</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 此中间件根据当前客户端的 X.509 客户端证书的指纹验证 cnf 声明（如果存在）</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ConfirmationValidationMiddleware</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">RequestDelegate</span> <span class="n">_next</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConfirmationValidationMiddlewareOptions</span> <span class="n">_options</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">ConfirmationValidationMiddleware</span><span class="p">(</span><span class="n">RequestDelegate</span> <span class="n">next</span><span class="p">,</span> <span class="n">ConfirmationValidationMiddlewareOptions</span> <span class="n">options</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">_options</span> <span class="p">=</span> <span class="n">options</span> <span class="p">??</span> <span class="k">new</span> <span class="n">ConfirmationValidationMiddlewareOptions</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">HttpContext</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">User</span><span class="p">.</span><span class="n">Identity</span><span class="p">.</span><span class="n">IsAuthenticated</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">cnfJson</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">User</span><span class="p">.</span><span class="n">FindFirst</span><span class="p">(</span><span class="s">&quot;cnf&quot;</span><span class="p">)?.</span><span class="n">Value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">String</span><span class="p">.</span><span class="n">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">cnfJson</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">certResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">ctx</span><span class="p">.</span><span class="n">AuthenticateAsync</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">CertificateSchemeName</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(!</span><span class="n">certResult</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">await</span> <span class="n">ctx</span><span class="p">.</span><span class="n">ChallengeAsync</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">CertificateSchemeName</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">var</span> <span class="n">certificate</span> <span class="p">=</span> <span class="k">await</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Connection</span><span class="p">.</span><span class="n">GetClientCertificateAsync</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">thumbprint</span> <span class="p">=</span> <span class="n">Base64UrlTextEncoder</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="n">certificate</span><span class="p">.</span><span class="n">GetCertHash</span><span class="p">(</span><span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA256</span><span class="p">));</span>

                <span class="kt">var</span> <span class="n">cnf</span> <span class="p">=</span> <span class="n">JObject</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">cnfJson</span><span class="p">);</span>
                <span class="kt">var</span> <span class="n">sha256</span> <span class="p">=</span> <span class="n">cnf</span><span class="p">.</span><span class="n">Value</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">&quot;x5t#S256&quot;</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">sha256</span><span class="p">)</span> <span class="p">||</span>
                    <span class="p">!</span><span class="n">thumbprint</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">sha256</span><span class="p">,</span> <span class="n">StringComparison</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">await</span> <span class="n">ctx</span><span class="p">.</span><span class="n">ChallengeAsync</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">JwtBearerSchemeName</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">await</span> <span class="nf">_next</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>以下是 API 的示例管道:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="p">.</span><span class="n">UseForwardedHeaders</span><span class="p">(</span><span class="k">new</span> <span class="n">ForwardedHeadersOptions</span>
    <span class="p">{</span>
        <span class="n">ForwardedHeaders</span> <span class="p">=</span> <span class="n">ForwardedHeaders</span><span class="p">.</span><span class="n">XForwardedFor</span> <span class="p">|</span> <span class="n">ForwardedHeaders</span><span class="p">.</span><span class="n">XForwardedProto</span>
    <span class="p">});</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseCertificateForwarding</span><span class="p">();</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseRouting</span><span class="p">();</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseAuthentication</span><span class="p">();</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">ConfirmationValidationMiddleware</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">ConfirmationValidationMiddlewareOptions</span>
<span class="p">{</span>
    <span class="n">CertificateSchemeName</span> <span class="p">=</span> <span class="n">CertificateAuthenticationDefaults</span><span class="p">.</span><span class="n">AuthenticationScheme</span><span class="p">,</span>
    <span class="n">JwtBearerSchemeName</span> <span class="p">=</span> <span class="s">&quot;token&quot;</span>
<span class="p">});</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseAuthorization</span><span class="p">();</span>

<span class="n">app</span><span class="p">.</span><span class="n">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="n">MapControllers</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>一旦上述中间件成功，那么调用者就已经通过发送者约束的访问令牌进行了身份验证。</p>
</div>
<div class="section" id="id7">
<h4>自省和确认声明<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>当访问令牌是 JWT 时，确认声明作为声明包含在令牌中。
使用引用令牌时，访问令牌所代表的声明必须通过自省获得。
IdentityServer 中的自省端点将为通过双向 TLS 获得的引用令牌返回一个 <code class="docutils literal notranslate"><span class="pre">cnf</span></code> 声明。</p>
</div>
</div>
<div class="section" id="id8">
<h3>临时客户端证书<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>您还可以使用 IdentityServer MTLS 支持来创建受发送方约束的访问令牌，而无需使用客户端证书进行客户端身份验证。
这对于您已经拥有不想更改的客户端机密的情况非常有用，例如 共享秘密，或更好的私钥 JWT。</p>
<p>尽管如此，如果存在客户端证书，则可以将确认声明嵌入到传出访问令牌中。 并且只要客户端使用相同的客户端证书
请求令牌并调用 API，这将为您提供所需的所有权证明属性。</p>
<p>为此，在选项中启用以下设置:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// 其他设置</span>

    <span class="n">options</span><span class="p">.</span><span class="n">MutualTls</span><span class="p">.</span><span class="n">AlwaysEmitConfirmationClaim</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="section" id="id9">
<h4>使用临时证书请求令牌<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>在这种情况下，客户端使用 <em>某些</em> 客户端机密（以下示例中的共享机密），但将附加客户端证书附加到令牌请求。
由于此证书不需要在令牌服务处与客户端相关联，因此可以即时创建:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">X509Certificate2</span> <span class="nf">CreateClientCertificate</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">X500DistinguishedName</span> <span class="n">distinguishedName</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X500DistinguishedName</span><span class="p">(</span><span class="s">$&quot;CN={name}&quot;</span><span class="p">);</span>

    <span class="k">using</span> <span class="p">(</span><span class="n">RSA</span> <span class="n">rsa</span> <span class="p">=</span> <span class="n">RSA</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="m">2048</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">request</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CertificateRequest</span><span class="p">(</span><span class="n">distinguishedName</span><span class="p">,</span> <span class="n">rsa</span><span class="p">,</span> <span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA256</span><span class="p">,</span><span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span>

        <span class="n">request</span><span class="p">.</span><span class="n">CertificateExtensions</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span>
            <span class="k">new</span> <span class="nf">X509KeyUsageExtension</span><span class="p">(</span><span class="n">X509KeyUsageFlags</span><span class="p">.</span><span class="n">DataEncipherment</span> <span class="p">|</span> <span class="n">X509KeyUsageFlags</span><span class="p">.</span><span class="n">KeyEncipherment</span> <span class="p">|</span> <span class="n">X509KeyUsageFlags</span><span class="p">.</span><span class="n">DigitalSignature</span> <span class="p">,</span> <span class="k">false</span><span class="p">));</span>

        <span class="n">request</span><span class="p">.</span><span class="n">CertificateExtensions</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span>
            <span class="k">new</span> <span class="nf">X509EnhancedKeyUsageExtension</span><span class="p">(</span>
                <span class="k">new</span> <span class="n">OidCollection</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Oid</span><span class="p">(</span><span class="s">&quot;1.3.6.1.5.5.7.3.2&quot;</span><span class="p">)</span> <span class="p">},</span> <span class="k">false</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">CreateSelfSigned</span><span class="p">(</span><span class="k">new</span> <span class="n">DateTimeOffset</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(-</span><span class="m">1</span><span class="p">)),</span> <span class="k">new</span> <span class="n">DateTimeOffset</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(</span><span class="m">10</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后除了已经设置的客户端密钥之外，还使用此客户端证书:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TokenResponse</span><span class="p">&gt;</span> <span class="n">RequestTokenAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">(</span><span class="n">GetHandler</span><span class="p">(</span><span class="n">ClientCertificate</span><span class="p">));</span>

    <span class="kt">var</span> <span class="n">disco</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetDiscoveryDocumentAsync</span><span class="p">(</span><span class="s">&quot;https://identityserver.local&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">disco</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">endpoint</span> <span class="p">=</span> <span class="n">disco</span>
        <span class="p">.</span><span class="n">TryGetValue</span><span class="p">(</span><span class="n">OidcConstants</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">MtlsEndpointAliases</span><span class="p">)</span>
        <span class="p">.</span><span class="n">Value</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">OidcConstants</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">TokenEndpoint</span><span class="p">)</span>
        <span class="p">.</span><span class="n">ToString</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">RequestClientCredentialsTokenAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">ClientCredentialsTokenRequest</span>
    <span class="p">{</span>
        <span class="n">Address</span> <span class="p">=</span> <span class="n">endpoint</span><span class="p">,</span>

        <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;client&quot;</span><span class="p">,</span>
        <span class="n">ClientSecret</span> <span class="p">=</span> <span class="s">&quot;secret&quot;</span><span class="p">,</span>
        <span class="n">Scope</span> <span class="p">=</span> <span class="s">&quot;api1&quot;</span>
    <span class="p">});</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsError</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SocketsHttpHandler</span> <span class="nf">GetHandler</span><span class="p">(</span><span class="n">X509Certificate2</span> <span class="n">certificate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SocketsHttpHandler</span><span class="p">();</span>
    <span class="n">handler</span><span class="p">.</span><span class="n">SslOptions</span><span class="p">.</span><span class="n">ClientCertificates</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509CertificateCollection</span> <span class="p">{</span> <span class="n">certificate</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-topics/request_object"></span><div class="section" id="id1">
<h2>授权请求对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>您可以将授权请求的参数作为单独的查询字符串 键/值 对提供，而不是将它们打包在签名的 JWT 中。
这使得参数可以防篡改，并且您可以对已在前端通道上的客户端进行身份验证。</p>
<p>您可以通过值或通过引用授权端点来传输它们 - 有关更多详细信息，请参阅 <a class="reference external" href="https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests">规范</a>。</p>
<p>IdentityServer 要求对请求 JWT 进行签名。 我们支持 X509 证书和 JSON Web 密钥，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="n">ClientId</span> <span class="p">=</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span>

    <span class="c1">// 将此设置为 true 以仅接受签名请求</span>
    <span class="n">RequireRequestObject</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>

    <span class="n">ClientSecrets</span> <span class="p">=</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="n">Secret</span>
        <span class="p">{</span>
            <span class="c1">// X509 证书 base64 编码</span>
            <span class="n">Type</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">SecretTypes</span><span class="p">.</span><span class="n">X509CertificateBase64</span><span class="p">,</span>
            <span class="n">Value</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToBase64String</span><span class="p">(</span><span class="n">cert</span><span class="p">.</span><span class="n">Export</span><span class="p">(</span><span class="n">X509ContentType</span><span class="p">.</span><span class="n">Cert</span><span class="p">))</span>
        <span class="p">},</span>
        <span class="k">new</span> <span class="n">Secret</span>
        <span class="p">{</span>
            <span class="c1">// RSA 密钥作为 JWK</span>
            <span class="n">Type</span> <span class="p">=</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">SecretTypes</span><span class="p">.</span><span class="n">JsonWebKey</span><span class="p">,</span>
            <span class="n">Value</span> <span class="p">=</span>
                <span class="s">&quot;{&#39;e&#39;:&#39;AQAB&#39;,&#39;kid&#39;:&#39;ZzAjSnraU3bkWGnnAqLapYGpTyNfLbjbzgAPbbW2GEA&#39;,&#39;kty&#39;:&#39;RSA&#39;,&#39;n&#39;:&#39;wWwQFtSzeRjjerpEM5Rmqz_DsNaZ9S1Bw6UbZkDLowuuTCjBWUax0vBMMxdy6XjEEK4Oq9lKMvx9JzjmeJf1knoqSNrox3Ka0rnxXpNAz6sATvme8p9mTXyp0cX4lF4U2J54xa2_S9NF5QWvpXvBeC4GAJx7QaSw4zrUkrc6XyaAiFnLhQEwKJCwUw4NOqIuYvYp_IXhw-5Ti_icDlZS-282PcccnBeOcX7vc21pozibIdmZJKqXNsL1Ibx5Nkx1F1jLnekJAmdaACDjYRLL_6n3W4wUp19UvzB1lGtXcJKLLkqB6YDiZNu16OSiSprfmrRXvYmvD8m6Fnl5aetgKw&#39;}&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Microsoft.IdentityModel.Tokens.JsonWebKeyConverter 有各种帮助程序将密钥转换为 JWK</p>
</div>
<div class="section" id="jwts">
<h3>通过引用传递请求 JWTs<a class="headerlink" href="#jwts" title="永久链接至标题">¶</a></h3>
<p>如果使用 <code class="docutils literal notranslate"><span class="pre">request_uri</span></code> 参数，IdentityServer 将发出一个传出的 HTTP 调用以从指定的 URL 获取 JWT。</p>
<p>您可以自定义用于此传出连接的 HTTP 客户端，例如 添加缓存或重试逻辑（例如通过 Polly 库）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">AddJwtRequestUriHttpClient</span><span class="p">(</span><span class="n">client</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">client</span><span class="p">.</span><span class="n">Timeout</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
<span class="p">})</span>
    <span class="p">.</span><span class="n">AddTransientHttpErrorPolicy</span><span class="p">(</span><span class="n">policy</span> <span class="p">=&gt;</span> <span class="n">policy</span><span class="p">.</span><span class="n">WaitAndRetryAsync</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span>
    <span class="p">{</span>
        <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">),</span>
        <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">2</span><span class="p">),</span>
        <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
    <span class="p">}));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>默认情况下禁用请求 URI 处理。 在 <span class="xref std std-ref">IdentityServer Options &lt;refOptions&gt;`</span> 下的 <a href="#id3"><span class="problematic" id="id4">``</span></a>Endpoints` 上启用。 另请参阅 JAR <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-23#section-10.4">规范</a> 中的安全注意事项。</p>
</div>
</div>
<div class="section" id="id6">
<h3>访问请求对象数据<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>您可以通过两种方式从请求对象中访问经过验证的数据</p>
<ul class="simple">
<li><p>无论您在哪里可以访问 <code class="docutils literal notranslate"><span class="pre">ValidatedAuthorizeRequest</span></code>，<code class="docutils literal notranslate"><span class="pre">RequestObjectValues</span></code> 字典都会保存值</p></li>
<li><p>在 UI 代码中，您可以调用 <code class="docutils literal notranslate"><span class="pre">IIdentityServerInteractionService.GetAuthorizationContextAsync</span></code>，生成的 <code class="docutils literal notranslate"><span class="pre">AuthorizationRequest</span></code> 对象也包含 <code class="docutils literal notranslate"><span class="pre">RequestObjectValues</span></code> 字典</p></li>
</ul>
</div>
</div>
<span id="document-topics/custom_token_request_validation"></span><div class="section" id="id1">
<h2>自定义令牌请求验证和颁发<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>您可以在令牌端点处将自定义代码作为令牌颁发管道的一部分运行。
这允许，例如</p>
<ul class="simple">
<li><p>添加额外的验证逻辑</p></li>
<li><p>动态更改某些参数（如令牌寿命）</p></li>
</ul>
<p>为此，实现（并注册）``ICustomTokenRequestValidator`` 接口:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 允许在令牌请求中插入自定义验证逻辑</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">ICustomTokenRequestValidator</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 令牌请求的自定义验证逻辑。</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;context&quot;&gt;上下文。&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;</span>
    <span class="c1">/// 验证结果</span>
    <span class="c1">/// &lt;/returns&gt;</span>
    <span class="n">Task</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="n">CustomTokenRequestValidationContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上下文对象使您可以访问：</p>
<ul class="simple">
<li><p>添加自定义响应参数</p></li>
<li><p>返回错误和错误描述</p></li>
<li><p>修改请求参数，例如 访问令牌生命周期和类型、客户端声明和确认方法</p></li>
</ul>
<p>您可以使用配置构建器上的 <code class="docutils literal notranslate"><span class="pre">AddCustomTokenRequestValidator</span></code> 扩展方法注册验证器的实现。</p>
</div>
<span id="document-topics/cors"></span><div class="section" id="cors">
<h2>CORS<a class="headerlink" href="#cors" title="永久链接至标题">¶</a></h2>
<p>IdentityServer 中的许多端点将通过基于 JavaScript 的客户端的 Ajax 调用进行访问。
鉴于 IdentityServer 很可能托管在与这些客户端不同的源上，这意味着 <a class="reference external" href="http://www.html5rocks.com/en/tutorials/cors/">跨源资源共享</a> (CORS) 将需要进行配置。</p>
<div class="section" id="id2">
<h3>基于客户端的 CORS 配置<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>配置 CORS 的一种方法是在 <a class="reference internal" href="index.html#refclient"><span class="std std-ref">客户端配置</span></a> 上使用 <code class="docutils literal notranslate"><span class="pre">AllowedCorsOrigins</span></code> 集合。
只需将客户端的源添加到集合中，IdentityServer 中的默认配置将参考这些值以允许来自源的跨源调用。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>确保在配置 CORS 时使用源（而不是 URL）。 例如： <code class="docutils literal notranslate"><span class="pre">https://foo:123/</span></code> 是一个 URL，而 <code class="docutils literal notranslate"><span class="pre">https://foo:123</span></code> 是一个来源。</p>
</div>
<p>如果您使用我们提供的“内存中”或基于 EF 的客户端配置，则将使用此默认 CORS 实现。
如果您定义自己的 <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code>，那么您将需要实现您自己的自定义 CORS 策略服务（见下文）。</p>
</div>
<div class="section" id="id3">
<h3>自定义 Cors 策略服务<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 允许托管应用程序实现 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 以完全控制 CORS 策略。</p>
<p>要实现的单一方法是： <code class="docutils literal notranslate"><span class="pre">Task&lt;bool&gt;</span> <span class="pre">IsOriginAllowedAsync(string</span> <span class="pre">origin)</span></code>。
如果允许 <cite>origin</cite>，则返回 <cite>true</cite>，否则返回 <cite>false</cite>。</p>
<p>实现后，只需在 DI 中注册实现，IdentityServer 就会使用您的自定义实现。</p>
<p><strong>DefaultCorsPolicyService</strong></p>
<p>如果您只是希望对一组允许的来源进行硬编码，那么您可以使用一个名为 <code class="docutils literal notranslate"><span class="pre">DefaultCorsPolicyService</span></code> 的预构建 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 实现。
这将在 DI 中配置为单例，并使用其 <code class="docutils literal notranslate"><span class="pre">AllowedOrigins</span></code> 集合进行硬编码，或将标志 <code class="docutils literal notranslate"><span class="pre">AllowAll</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">true</span></code> 以允许所有来源。
例如，在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddSingleton</span><span class="p">&lt;</span><span class="n">ICorsPolicyService</span><span class="p">&gt;((</span><span class="n">container</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">logger</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">DefaultCorsPolicyService</span><span class="p">&gt;&gt;();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">DefaultCorsPolicyService</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AllowedOrigins</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;https://foo&quot;</span><span class="p">,</span> <span class="s">&quot;https://bar&quot;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>谨慎使用 <code class="docutils literal notranslate"><span class="pre">AllowAll</span></code>。</p>
</div>
</div>
<div class="section" id="identityserver-cors-asp-net-cores-cors">
<h3>将 IdentityServer CORS 策略与 ASP.NET Cores CORS 策略混合使用<a class="headerlink" href="#identityserver-cors-asp-net-cores-cors" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 使用来自 ASP.NET Core 的 CORS 中间件来提供其 CORS 实现。
托管 IdentityServer 的应用程序可能也需要 CORS 用于其自己的自定义端点。
一般来说，两者应该在同一个应用程序中一起工作。</p>
<p>您的代码应使用 ASP.NET Core 中记录的 CORS 功能，而不考虑 IdentityServer。
这意味着您应该像往常一样定义策略并注册中间件。
如果您的应用程序在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中定义了策略，那么这些策略应该在您使用它们的相同位置继续工作（在您配置 CORS 中间件的位置或在您的控制器代码中使用 MVC <code class="docutils literal notranslate"><span class="pre">EnableCors</span></code> 属性的位置） ）。
相反，如果您在使用 CORS 中间件时定义内联策略（通过策略构建器回调），那么它也应该继续正常工作。</p>
<p>使用 ASP.NET Core CORS 服务和 IdentityServer 之间可能存在冲突的一种情况是，如果您决定创建自定义 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyProvider</span></code>。
鉴于 ASP.NET Core 的 CORS 服务和中间件的设计，IdentityServer 实现了自己的自定义 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyProvider</span></code> 并将其注册到 DI 系统中。
幸运的是，IdentityServer 实现旨在使用装饰器模式来包装任何已在 DI 中注册的现有 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyProvider</span></code>。
这意味着您还可以实现 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyProvider</span></code>，但它只需要在 DI 中的 IdentityServer 之前注册（例如在 <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> 中）。</p>
</div>
</div>
<span id="document-topics/discovery"></span><div class="section" id="id1">
<h2>发现<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>发现文档可以在 <em>https://baseaddress/.well-known/openid-configuration</em> 找到。
它包含有关 IdentityServer 的端点、密钥材料和功能的信息。</p>
<p>默认情况下，所有信息都包含在发现文档中，但通过使用配置选项，您可以隐藏个别部分，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">ShowIdentityScopes</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">ShowApiScopes</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">ShowClaims</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">ShowExtensionGrantTypes</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="section" id="id2">
<h3>扩展发现<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>您可以向发现文档添加自定义条目，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">CustomEntries</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;my_setting&quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">);</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">CustomEntries</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;my_complex_setting&quot;</span><span class="p">,</span>
        <span class="k">new</span>
        <span class="p">{</span>
            <span class="n">foo</span> <span class="p">=</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="s">&quot;bar&quot;</span>
        <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>当您添加以 ~/ 开头的自定义值时，它将扩展为 IdentityServer 基地址下方的绝对路径，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">CustomEntries</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;my_custom_endpoint&quot;</span><span class="p">,</span> <span class="s">&quot;~/custom&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>如果您想完全控制发现（和 jwks）文档的呈现，您可以实现 <code class="docutils literal notranslate"><span class="pre">IDiscoveryResponseGenerator</span></code> 接口（或派生自我们的默认实现）。</p>
</div>
</div>
<span id="document-topics/add_apis"></span><div class="section" id="api">
<h2>添加更多 API 端点<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h2>
<p>向托管 IdentityServer 的应用程序添加额外的 API 端点是一种常见的情况。
这些端点通常由 IdentityServer 本身保护。</p>
<p>对于简单的场景，我们给你一些帮助。 请参阅高级部分以了解更多内部管道。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以通过使用我们的 <code class="docutils literal notranslate"><span class="pre">IdentityServerAuthentication</span></code> 处理程序或微软的 <code class="docutils literal notranslate"><span class="pre">JwtBearer</span></code> 处理程序来实现相同的目的。 但不建议这样做，因为它需要更多配置并创建对可能导致未来更新冲突的外部库的依赖。</p>
</div>
<p>首先将您的 API 注册为 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code>，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ApiResource</span><span class="p">&gt;</span> <span class="n">Apis</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ApiResource</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="c1">// 本地API</span>
    <span class="k">new</span> <span class="nf">ApiResource</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">LocalApi</span><span class="p">.</span><span class="n">ScopeName</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
<p>..并让您的客户访问此 API，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Client</span>
<span class="p">{</span>
    <span class="c1">// 省略其余部分</span>
    <span class="n">AllowedScopes</span> <span class="p">=</span> <span class="p">{</span> <span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">LocalApi</span><span class="p">.</span><span class="n">ScopeName</span> <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.LocalApi.ScopeName</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">IdentityServerApi</span></code>。</p>
</div>
<p>要为本地 API 启用令牌验证，请将以下内容添加到您的 IdentityServer 启动中:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddLocalApiAuthentication</span><span class="p">();</span>
</pre></div>
</div>
<p>为了保护 API 控制器，使用 <code class="docutils literal notranslate"><span class="pre">LocalApi.PolicyName</span></code> 策略用 <code class="docutils literal notranslate"><span class="pre">Authorize</span></code> 属性修饰它:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Route(&quot;localApi&quot;)]</span>
<span class="na">[Authorize(LocalApi.PolicyName)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">LocalApiController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IActionResult</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 省略</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后，授权客户端可以为 <code class="docutils literal notranslate"><span class="pre">IdentityServerApi</span></code> 范围请求令牌并使用它来调用 API。</p>
<div class="section" id="id1">
<h3>发现<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>如果需要，您还可以将端点添加到发现文档中，例如像这样:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">Discovery</span><span class="p">.</span><span class="n">CustomEntries</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;local_api&quot;</span><span class="p">,</span> <span class="s">&quot;~/localapi&quot;</span><span class="p">);</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>高级<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>在幕后， <code class="docutils literal notranslate"><span class="pre">AddLocalApiAuthentication</span></code> 助手做了几件事：</p>
<ul class="simple">
<li><p>添加一个身份验证处理程序，它使用 IdentityServer 的内置令牌验证引擎来验证传入的令牌（此处理程序的名称是 <code class="docutils literal notranslate"><span class="pre">IdentityServerAccessToken</span></code> 或 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.LocalApi.AuthenticationScheme</span></code>）</p></li>
<li><p>将身份验证处理程序配置为在值为 <code class="docutils literal notranslate"><span class="pre">IdentityServerApi</span></code> 的访问令牌中要求范围声明</p></li>
<li><p>设置一个授权策略来检查值 <code class="docutils literal notranslate"><span class="pre">IdentityServerApi</span></code> 的范围声明</p></li>
</ul>
<p>这涵盖了最常见的场景。 您可以通过以下方式自定义此行为：</p>
<ul>
<li><dl class="simple">
<dt>通过调用 <code class="docutils literal notranslate"><span class="pre">services.AddAuthentication().AddLocalApi(...)</span></code> 自己添加身份验证处理程序</dt><dd><ul class="simple">
<li><p>通过这种方式，您可以自己指定所需的范围名称，或者（完全不指定范围）接受来自当前 IdentityServer 实例的任何令牌</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>使用自定义策略或代码在您的控制器中进行您自己的范围验证/授权，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAuthorization</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">options</span><span class="p">.</span><span class="n">AddPolicy</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">LocalApi</span><span class="p">.</span><span class="n">PolicyName</span><span class="p">,</span> <span class="n">policy</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">policy</span><span class="p">.</span><span class="n">AddAuthenticationSchemes</span><span class="p">(</span><span class="n">IdentityServerConstants</span><span class="p">.</span><span class="n">LocalApi</span><span class="p">.</span><span class="n">AuthenticationScheme</span><span class="p">);</span>
        <span class="n">policy</span><span class="p">.</span><span class="n">RequireAuthenticatedUser</span><span class="p">();</span>
        <span class="c1">// 定制需求</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id3">
<h3>声明转换<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>您可以提供回调以在验证后转换传入令牌的声明。
要么使用辅助方法，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddLocalApiAuthentication</span><span class="p">(</span><span class="n">principal</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">principal</span><span class="p">.</span><span class="n">Identities</span><span class="p">.</span><span class="n">First</span><span class="p">().</span><span class="n">AddClaim</span><span class="p">(</span><span class="k">new</span> <span class="n">Claim</span><span class="p">(</span><span class="s">&quot;additional_claim&quot;</span><span class="p">,</span> <span class="s">&quot;additional_value&quot;</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="n">principal</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>…或者如果您手动添加身份验证处理程序，则在选项上实现事件。</p>
</div>
</div>
<span id="document-topics/add_protocols"></span><div class="section" id="id1">
<h2>添加新协议<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>除了对 OpenID Connect 和 OAuth 2.0 的内置支持之外，IdentityServer4 还允许添加对其他协议的支持。</p>
<p>您可以添加这些额外的协议端点作为中间件或使用例如 MVC 控制器。
在这两种情况下，您都可以访问 ASP.NET Core DI 系统，该系统允许重用我们的内部服务，例如访问客户端定义或密钥材料。</p>
<p>添加 WS-Federation 支持的示例可以在 <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.WsFederation">这里</a> 找到。</p>
<div class="section" id="id3">
<h3>典型的身份验证工作流程<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>身份验证请求通常是这样工作的：</p>
<ul class="simple">
<li><p>身份验证请求到达协议端点</p></li>
<li><p>协议端点进行输入验证</p></li>
<li><dl class="simple">
<dt>重定向到登录页面，返回 URL 设置回协议端点（如果用户是匿名的）</dt><dd><ul>
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">IIdentityServerInteractionService</span></code> 访问当前请求的详细信息</p></li>
<li><p>用户身份验证（本地或通过外部身份验证中间件）</p></li>
<li><p>用户登录</p></li>
<li><p>重定向回协议端点</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>创建协议响应（令牌创建并重定向回客户端）</p></li>
</ul>
</div>
<div class="section" id="identityserver">
<h3>有用的 IdentityServer 服务<a class="headerlink" href="#identityserver" title="永久链接至标题">¶</a></h3>
<p>为了实现上述工作流程，需要与 IdentityServer 的一些交互点。</p>
<p><strong>访问配置并重定向到登录页面</strong></p>
<p>您可以通过注入 <code class="docutils literal notranslate"><span class="pre">IdentityServerOptions</span></code> 来访问 IdentityServer 配置
类到您的代码中。 这，例如 具有登录页面的配置路径:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">returnUrl</span> <span class="p">=</span> <span class="n">Url</span><span class="p">.</span><span class="n">Action</span><span class="p">(</span><span class="s">&quot;Index&quot;</span><span class="p">);</span>
<span class="n">returnUrl</span> <span class="p">=</span> <span class="n">returnUrl</span><span class="p">.</span><span class="n">AddQueryString</span><span class="p">(</span><span class="n">Request</span><span class="p">.</span><span class="n">QueryString</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">loginUrl</span> <span class="p">=</span> <span class="n">_options</span><span class="p">.</span><span class="n">UserInteraction</span><span class="p">.</span><span class="n">LoginUrl</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="n">loginUrl</span><span class="p">.</span><span class="n">AddQueryString</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">UserInteraction</span><span class="p">.</span><span class="n">LoginReturnUrlParameter</span><span class="p">,</span> <span class="n">returnUrl</span><span class="p">);</span>

<span class="k">return</span> <span class="nf">Redirect</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>登录页面与当前协议请求的交互</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IIdentityServerInteractionService</span></code> 支持将协议返回 URL 转换为经过解析和验证的上下文对象:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_interaction</span><span class="p">.</span><span class="n">GetAuthorizationContextAsync</span><span class="p">(</span><span class="n">returnUrl</span><span class="p">);</span>
</pre></div>
</div>
<p>默认情况下，交互服务仅理解 OpenID Connect 协议消息。
要扩展支持，您可以编写自己的 <code class="docutils literal notranslate"><span class="pre">IReturnUrlParser</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IReturnUrlParser</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">IsValidReturnUrl</span><span class="p">(</span><span class="kt">string</span> <span class="n">returnUrl</span><span class="p">);</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="n">AuthorizationRequest</span><span class="p">&gt;</span> <span class="n">ParseAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">returnUrl</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>..然后在DI中注册解析器:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">&lt;</span><span class="n">IReturnUrlParser</span><span class="p">,</span> <span class="n">WsFederationReturnUrlParser</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>这允许登录页面获取诸如客户端配置和其他协议参数之类的信息。</p>
<p><strong>访问用于创建协议响应的配置和密钥材料</strong></p>
<p>通过将 <code class="docutils literal notranslate"><span class="pre">IKeyMaterialService</span></code> 注入您的代码，您可以访问配置的签名凭证和验证密钥:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">credential</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_keys</span><span class="p">.</span><span class="n">GetSigningCredentialsAsync</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">key</span> <span class="p">=</span> <span class="n">credential</span><span class="p">.</span><span class="n">Key</span> <span class="k">as</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">IdentityModel</span><span class="p">.</span><span class="n">Tokens</span><span class="p">.</span><span class="n">X509SecurityKey</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">descriptor</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SecurityTokenDescriptor</span>
<span class="p">{</span>
    <span class="n">AppliesToAddress</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">Client</span><span class="p">.</span><span class="n">ClientId</span><span class="p">,</span>
    <span class="n">Lifetime</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lifetime</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">AddSeconds</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">Client</span><span class="p">.</span><span class="n">IdentityTokenLifetime</span><span class="p">)),</span>
    <span class="n">ReplyToAddress</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">Client</span><span class="p">.</span><span class="n">RedirectUris</span><span class="p">.</span><span class="n">First</span><span class="p">(),</span>
    <span class="n">SigningCredentials</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509SigningCredentials</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">Certificate</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">RelyingParty</span><span class="p">.</span><span class="n">SignatureAlgorithm</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">RelyingParty</span><span class="p">.</span><span class="n">DigestAlgorithm</span><span class="p">),</span>
    <span class="n">Subject</span> <span class="p">=</span> <span class="n">outgoingSubject</span><span class="p">,</span>
    <span class="n">TokenIssuerName</span> <span class="p">=</span> <span class="n">_contextAccessor</span><span class="p">.</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">GetIdentityServerIssuerUri</span><span class="p">(),</span>
    <span class="n">TokenType</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">RelyingParty</span><span class="p">.</span><span class="n">TokenType</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<span id="document-topics/tools"></span><div class="section" id="id1">
<h2>工具<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">IdentityServerTools</span></code> 类是为 IdentityServer 编写可扩展性代码时可能需要的有用内部工具的集合。 要使用它，请将其注入您的代码中，例如 控制器:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="nf">MyController</span><span class="p">(</span><span class="n">IdentityServerTools</span> <span class="n">tools</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_tools</span> <span class="p">=</span> <span class="n">tools</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IssueJwtAsync</span></code> 方法允许使用 IdentityServer 令牌创建引擎创建 JWT 令牌。 <code class="docutils literal notranslate"><span class="pre">IssueClientJwtAsync</span></code> 是一个更简单的版本，
用于为服务器到服务器的通信创建令牌（例如，当您必须从代码中调用受 IdentityServer 保护的 API 时）:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="n">MyAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">token</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_tools</span><span class="p">.</span><span class="n">IssueClientJwtAsync</span><span class="p">(</span>
        <span class="n">clientId</span><span class="p">:</span> <span class="s">&quot;client_id&quot;</span><span class="p">,</span>
        <span class="n">lifetime</span><span class="p">:</span> <span class="m">3600</span><span class="p">,</span>
        <span class="n">audiences</span><span class="p">:</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;backend.api&quot;</span> <span class="p">});</span>

    <span class="c1">// 更多的代码</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-endpoints/discovery"></span><div class="section" id="id1">
<h2>发现端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>发现端点可用于检索有关您的 IdentityServer 的元数据 -
它返回诸如发行者名称、密钥材料、支持的范围等信息。有关更多详细信息，请参阅 <a class="reference external" href="https://openid.net/specs/openid-connect-discovery-1_0.html">规范</a>。
发现端点可通过相对于基地址的 <code class="docutils literal notranslate"><span class="pre">/.well-known/openid-configuration</span></code> 获得，例如:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="c1">//demo.identityserver.io/.well-known/openid-configuration</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问发现端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/discovery.html">文档</a>。</p>
</div>
</div>
<span id="document-endpoints/authorize"></span><div class="section" id="id1">
<h2>授权端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>授权端点可用于通过浏览器请求令牌或授权码。
此过程通常涉及最终用户的身份验证和可选的同意。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>IdentityServer 支持 OpenID Connect 和 OAuth 2.0 授权请求参数的子集。 有关完整列表，请参阅 <a href="#id3"><span class="problematic" id="id4">`此处&lt;https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest&gt;`_</span></a>。</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">client_id</span></code></dt><dd><p>客户端的标识符（必需）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>您可以提供一个子集或全部作为 JWT，而不是将所有参数作为单独的查询字符串参数提供</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_uri</span></code></dt><dd><p>包含请求参数的预打包 JWT 的 URL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scope</span></code></dt><dd><p>一个或多个已注册的范围（必需）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">redirect_uri</span></code></dt><dd><p>必须与该客户端允许的重定向 URI 之一完全匹配（必需）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">response_type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">id_token</span></code> 请求身份令牌（仅允许身份范围）</p>
<p><code class="docutils literal notranslate"><span class="pre">token</span></code> 请求访问令牌（仅允许资源范围）</p>
<p><code class="docutils literal notranslate"><span class="pre">id_token</span> <span class="pre">token</span></code> 请求身份令牌和访问令牌</p>
<p><code class="docutils literal notranslate"><span class="pre">code</span></code> 请求授权码</p>
<p><code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">id_token</span></code> 请求授权码和身份令牌</p>
<p><code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">id_token</span> <span class="pre">token</span></code> 请求授权码、身份令牌和访问令牌</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">response_mode</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">form_post</span></code> 将令牌响应作为表单发布而不是片段编码重定向发送（可选）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>identityserver 将在令牌响应上回显状态值，这是用于客户端和提供者之间的往返状态，关联请求和响应以及 CSRF/重放保护。 （推荐的）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nonce</span></code></dt><dd><p>identityserver 将回显身份令牌中的 nonce 值，这是为了重放保护）</p>
<p><em>对于通过隐式授权的身份令牌是必需的。</em></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prompt</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">none</span></code> 请求期间不会显示 UI。 如果这是不可能的（例如，因为用户必须登录或同意），则返回错误</p>
<p><code class="docutils literal notranslate"><span class="pre">login</span></code> 即使用户已经登录并且有一个有效的会话，也会显示登录 UI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_challenge</span></code></dt><dd><p>发送 PKCE 的代码质询</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_challenge_method</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">plain</span></code> 表示 challenge 使用纯文本（不推荐）
<code class="docutils literal notranslate"><span class="pre">S256</span></code> 表示 challenge 是用 SHA256 散列的</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">login_hint</span></code></dt><dd><p>可用于在登录页面预填用户名字段</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ui_locales</span></code></dt><dd><p>提供有关登录 UI 所需显示语言的提示</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_age</span></code></dt><dd><p>如果用户的登录会话超过最大期限（以秒为单位），将显示登录 UI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acr_values</span></code></dt><dd><p>允许传入额外的身份验证相关信息 - identityserver 特殊情况下以下专有 acr_values：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">idp:name_of_idp</span></code> 绕过登录/主域屏幕并将用户直接转发到选定的身份提供者（如果每个客户端配置允许）</p>
<p><code class="docutils literal notranslate"><span class="pre">tenant:name_of_tenant</span></code> 可用于将租户名称传递给登录 UI</p>
</div></blockquote>
</dd>
</dl>
<p><strong>例子</strong></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">GET</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">authorize</span><span class="p">?</span>
    <span class="n">client_id</span><span class="p">=</span><span class="n">client1</span><span class="p">&amp;</span>
    <span class="n">scope</span><span class="p">=</span><span class="n">openid</span> <span class="n">email</span> <span class="n">api1</span><span class="p">&amp;</span>
    <span class="n">response_type</span><span class="p">=</span><span class="n">id_token</span> <span class="n">token</span><span class="p">&amp;</span>
    <span class="n">redirect_uri</span><span class="p">=</span><span class="n">https</span><span class="p">:</span><span class="c1">//myapp/callback&amp;</span>
    <span class="n">state</span><span class="p">=</span><span class="n">abc</span><span class="p">&amp;</span>
    <span class="n">nonce</span><span class="p">=</span><span class="n">xyz</span>
</pre></div>
</div>
<p>（删除了 URL 编码，并添加了换行符以提高可读性）</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库以编程方式创建授权请求 .NET 代码。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/authorize.html">文档</a>。</p>
</div>
</div>
<span id="document-endpoints/token"></span><div class="section" id="id1">
<h2>令牌端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>令牌端点可用于以编程方式请求令牌。
它支持 <code class="docutils literal notranslate"><span class="pre">password</span></code>、<code class="docutils literal notranslate"><span class="pre">authorization_code</span></code>、<code class="docutils literal notranslate"><span class="pre">client_credentials</span></code>、<code class="docutils literal notranslate"><span class="pre">refresh_token</span></code> 和 <code class="docutils literal notranslate"><span class="pre">urn:ietf:params:oauth:grant-type:device_code</span></code> 授权类型。
此外，可以扩展令牌端点以支持扩展授权类型。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>IdentityServer 支持 OpenID Connect 和 OAuth 2.0 令牌请求参数的子集。 有关完整列表，请参阅 <a href="#id4"><span class="problematic" id="id5">`此处&lt;http://openid.net/specs/openid-connect-core-1_0.html#TokenRequest&gt;`_</span></a>。</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">client_id</span></code></dt><dd><p>客户端标识符（必需 - 在正文中或作为授权标头的一部分。）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">client_secret</span></code></dt><dd><p>客户端机密在帖子正文中，或作为基本身份验证标头。 可选的。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grant_type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">authorization_code</span></code>, <code class="docutils literal notranslate"><span class="pre">client_credentials</span></code>, <code class="docutils literal notranslate"><span class="pre">password</span></code>, <code class="docutils literal notranslate"><span class="pre">refresh_token</span></code>, <code class="docutils literal notranslate"><span class="pre">urn:ietf:params:oauth:grant-type:device_code</span></code> 或自定义</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scope</span></code></dt><dd><p>一个或多个注册范围。 如果未指定，则将发布所有明确允许的范围的令牌。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">redirect_uri</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">authorization_code</span></code> 授权类型所需</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt><dd><p>授权码（“authorization_code” 授权类型需要）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_verifier</span></code></dt><dd><p>PKCE 证明密钥</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">username</span></code></dt><dd><p>资源所有者用户名（ <code class="docutils literal notranslate"><span class="pre">password</span></code> 授权类型需要）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">password</span></code></dt><dd><p>资源所有者密码（ <code class="docutils literal notranslate"><span class="pre">password</span></code> 授权类型需要）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acr_values</span></code></dt><dd><p>允许为 <code class="docutils literal notranslate"><span class="pre">password</span></code> 授权类型传递额外的身份验证相关信息 - identityserver 特殊情况，以下专有 acr_values：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">idp:name_of_idp</span></code> 绕过登录/主域屏幕并将用户直接转发到选定的身份提供者（如果每个客户端配置允许）</p>
<p><code class="docutils literal notranslate"><span class="pre">tenant:name_of_tenant</span></code> 可用于将租户名称传递给令牌端点</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refresh_token</span></code></dt><dd><p>刷新令牌（ <code class="docutils literal notranslate"><span class="pre">refresh_token</span></code> 授予类型所需）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_code</span></code></dt><dd><p>设备代码（ <code class="docutils literal notranslate"><span class="pre">urn:ietf:params:oauth:grant-type:device_code</span></code> 授权类型需要）</p>
</dd>
</dl>
<div class="section" id="id2">
<h3>例子<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">token</span>
<span class="n">CONTENT</span><span class="p">-</span><span class="n">TYPE</span> <span class="n">application</span><span class="p">/</span><span class="n">x</span><span class="p">-</span><span class="n">www</span><span class="p">-</span><span class="n">form</span><span class="p">-</span><span class="n">urlencoded</span>

    <span class="n">client_id</span><span class="p">=</span><span class="n">client1</span><span class="p">&amp;</span>
    <span class="n">client_secret</span><span class="p">=</span><span class="n">secret</span><span class="p">&amp;</span>
    <span class="n">grant_type</span><span class="p">=</span><span class="n">authorization_code</span><span class="p">&amp;</span>
    <span class="n">code</span><span class="p">=</span><span class="n">hdh922</span><span class="p">&amp;</span>
    <span class="n">redirect_uri</span><span class="p">=</span><span class="n">https</span><span class="p">:</span><span class="c1">//myapp.com/callback</span>
</pre></div>
</div>
<p>（删除了表单编码并添加了换行符以提高可读性）</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问令牌端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/token.html">文档</a>。</p>
</div>
</div>
</div>
<span id="document-endpoints/userinfo"></span><div class="section" id="id1">
<h2>用户信息端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>用户信息端点可用于检索有关用户的身份信息（请参阅 <a class="reference external" href="http://openid.net/specs/openid-connect-core-1_0.html#UserInfo">规范</a>）。</p>
<p>调用者需要发送代表用户的有效访问令牌。
根据授予的范围，用户信息端点将返回映射的声明（至少需要 <code class="docutils literal notranslate"><span class="pre">openid</span></code> 范围）。</p>
<div class="section" id="id3">
<h3>例子<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">GET</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">userinfo</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Bearer</span> <span class="p">&lt;</span><span class="n">access_token</span><span class="p">&gt;</span>
</pre></div>
</div>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">HTTP</span><span class="p">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="n">OK</span>
<span class="n">Content</span><span class="p">-</span><span class="n">Type</span><span class="p">:</span> <span class="n">application</span><span class="p">/</span><span class="n">json</span>

<span class="p">{</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;248289761001&quot;</span><span class="p">,</span>
    <span class="s">&quot;name&quot;</span><span class="p">:</span> <span class="s">&quot;Bob Smith&quot;</span><span class="p">,</span>
    <span class="s">&quot;given_name&quot;</span><span class="p">:</span> <span class="s">&quot;Bob&quot;</span><span class="p">,</span>
    <span class="s">&quot;family_name&quot;</span><span class="p">:</span> <span class="s">&quot;Smith&quot;</span><span class="p">,</span>
    <span class="s">&quot;role&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s">&quot;user&quot;</span><span class="p">,</span>
        <span class="s">&quot;admin&quot;</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问 userinfo 端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/userinfo.html">文档</a>。</p>
</div>
</div>
</div>
<span id="document-endpoints/device_authorization"></span><div class="section" id="id1">
<h2>设备授权端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>设备授权端点可用于请求设备和用户代码。
该端点用于启动设备流授权过程。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>结束会话端点的 URL 可通过 <a class="reference internal" href="index.html#refdiscovery"><span class="std std-ref">发现文档</span></a> 获得。</p>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">client_id</span></code></dt><dd><p>客户端标识符（必需）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">client_secret</span></code></dt><dd><p>客户端密钥在 POST body 中，或作为基本身份验证标头。 可选的。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scope</span></code></dt><dd><p>一个或多个已注册的范围。 如果未指定，则将发布所有明确允许的范围的令牌。</p>
</dd>
</dl>
<div class="section" id="id2">
<h3>例子<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">deviceauthorization</span>

    <span class="n">client_id</span><span class="p">=</span><span class="n">client1</span><span class="p">&amp;</span>
    <span class="n">client_secret</span><span class="p">=</span><span class="n">secret</span><span class="p">&amp;</span>
    <span class="n">scope</span><span class="p">=</span><span class="n">openid</span> <span class="n">api1</span>
</pre></div>
</div>
<p>（删除了表单编码并添加了换行符以提高可读性）</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问设备授权端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/device_authorize.html">文档</a>。</p>
</div>
</div>
</div>
<span id="document-endpoints/introspection"></span><div class="section" id="id1">
<h2>自省端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>自省端点是 <a class="reference external" href="https://tools.ietf.org/html/rfc7662">RFC 7662</a> 的实现。</p>
<p>它可用于验证参考令牌（或 JWT，如果消费者不支持适当的 JWT 或加密库）。
自省端点需要身份验证 - 由于自省端点的客户端是一个 API，您可以在 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 上配置密钥。</p>
<div class="section" id="id2">
<h3>例子<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">introspect</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Basic</span> <span class="n">xxxyyy</span>

<span class="n">token</span><span class="p">=&lt;</span><span class="n">token</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>成功的响应将返回状态代码 200 以及活动或非活动令牌:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;active&quot;</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
    <span class="s">&quot;sub&quot;</span><span class="p">:</span> <span class="s">&quot;123&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>未知或过期的令牌将被标记为不活动:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s">&quot;active&quot;</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>无效请求将返回 400，未经授权的请求将返回 401。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问自省端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/introspection.html">文档</a>。</p>
</div>
</div>
</div>
<span id="document-endpoints/revocation"></span><div class="section" id="id1">
<h2>撤销端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>此端点允许撤销访问令牌（仅限参考令牌）和刷新令牌。
它实现了令牌撤销规范 <a href="#id4"><span class="problematic" id="id5">`（RFC 7009）&lt;https://tools.ietf.org/html/rfc7009&gt;`_</span></a>。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">token</span></code></dt><dd><p>要撤销的令牌（必需）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">token_type_hint</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">access_token</span></code> 或 <code class="docutils literal notranslate"><span class="pre">refresh_token</span></code> （可选）</p>
</dd>
</dl>
<div class="section" id="id2">
<h3>例子<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">POST</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">revocation</span> <span class="n">HTTP</span><span class="p">/</span><span class="m">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">server</span><span class="p">.</span><span class="n">example</span><span class="p">.</span><span class="n">com</span>
<span class="n">Content</span><span class="p">-</span><span class="n">Type</span><span class="p">:</span> <span class="n">application</span><span class="p">/</span><span class="n">x</span><span class="p">-</span><span class="n">www</span><span class="p">-</span><span class="n">form</span><span class="p">-</span><span class="n">urlencoded</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Basic</span> <span class="n">czZCaGRSa3F0MzpnWDFmQmF0M2JW</span>

<span class="n">token</span><span class="p">=</span><span class="m">45</span><span class="n">ghiukldjahdnhzdauz</span><span class="p">&amp;</span><span class="n">token_type_hint</span><span class="p">=</span><span class="n">refresh_token</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库从 .NET 代码以编程方式访问吊销端点。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/revocation.html">文档</a>。</p>
</div>
</div>
</div>
<span id="document-endpoints/endsession"></span><div class="section" id="id1">
<h2>结束会话端点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>结束会话端点可用于触发单点注销（请参阅 <a class="reference external" href="https://openid.net/specs/openid-connect-rpinitiated-1_0.html">规范</a>）。</p>
<p>要使用结束会话端点，客户端应用程序会将用户的浏览器重定向到结束会话 URL。
用户在会话期间通过浏览器登录的所有应用程序都可以参与注销。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>结束会话端点的 URL 可通过 <a class="reference internal" href="index.html#refdiscovery"><span class="std std-ref">发现文档</span></a> 获得。</p>
</div>
<div class="section" id="id3">
<h3>参数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p><strong>id_token_hint</strong></p>
<p>当用户被重定向到端点时，会提示他们是否真的要注销。
客户端发送从身份验证收到的原始 <em>id_token</em> 可以绕过此提示。
这作为名为 <code class="docutils literal notranslate"><span class="pre">id_token_hint</span></code> 的查询字符串参数传递。</p>
<p><strong>post_logout_redirect_uri</strong></p>
<p>如果传递了有效的 <code class="docutils literal notranslate"><span class="pre">id_token_hint</span></code>，则客户端还可以发送 <code class="docutils literal notranslate"><span class="pre">post_logout_redirect_uri</span></code> 参数。
这可用于允许用户在注销后重定向回客户端。
该值必须与客户端预配置的 <code class="docutils literal notranslate"><span class="pre">PostLogoutRedirectUris</span></code> 之一（ <a class="reference internal" href="index.html#refclient"><span class="std std-ref">client docs</span></a>）匹配。</p>
<p><strong>state</strong></p>
<p>如果传递了有效的 <code class="docutils literal notranslate"><span class="pre">post_logout_redirect_uri</span></code>，则客户端还可以发送 <code class="docutils literal notranslate"><span class="pre">state</span></code> 参数。
在用户重定向回客户端后，这将作为查询字符串参数返回给客户端。
这通常由客户端用于跨重定向来回状态。</p>
</div>
<div class="section" id="id4">
<h3>例子<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">GET</span> <span class="p">/</span><span class="n">connect</span><span class="p">/</span><span class="n">endsession</span><span class="p">?</span><span class="n">id_token_hint</span><span class="p">=</span><span class="n">eyJhbGciOiJSUzI1NiIsImtpZCI6IjdlOGFkZmMzMjU1OTEyNzI0ZDY4NWZmYmIwOThjNDEyIiwidHlwIjoiSldUIn0</span><span class="p">.</span><span class="n">eyJuYmYiOjE0OTE3NjUzMjEsImV4cCI6MTQ5MTc2NTYyMSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwIiwiYXVkIjoianNfb2lkYyIsIm5vbmNlIjoiYTQwNGFjN2NjYWEwNGFmNzkzNmJjYTkyNTJkYTRhODUiLCJpYXQiOjE0OTE3NjUzMjEsInNpZCI6IjI2YTYzNWVmOTQ2ZjRiZGU3ZWUzMzQ2ZjFmMWY1NTZjIiwic3ViIjoiODg0MjExMTMiLCJhdXRoX3RpbWUiOjE0OTE3NjUzMTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ</span><span class="p">.</span><span class="n">STzOWoeVYMtZdRAeRT95cMYEmClixWkmGwVH2Yyiks9BETotbSZiSfgE5kRh72kghN78N3</span><span class="p">-</span><span class="n">RgCTUmM2edB3bZx4H5ut3wWsBnZtQ2JLfhTwJAjaLE9Ykt68ovNJySbm8hjZhHzPWKh55jzshivQvTX0GdtlbcDoEA1oNONxHkpDIcr3pRoGi6YveEAFsGOeSQwzT76aId</span><span class="p">-</span><span class="n">rAALhFPkyKnVc</span><span class="p">-</span><span class="n">uB8IHtGNSyRWLFhwVqAdS3fRNO7iIs5hYRxeFSU7a5ZuUqZ6RRi</span><span class="p">-</span><span class="n">bcDhI</span><span class="p">-</span><span class="n">djKO5uAwiyhfpbpYcaY_TxXWoCmq8N8uAw9zqFsQUwcXymfOAi2UF3eFZt02hBu</span><span class="p">-</span><span class="n">shKA</span><span class="p">&amp;</span><span class="n">post_logout_redirect_uri</span><span class="p">=</span><span class="n">http</span><span class="p">%</span><span class="m">3</span><span class="n">A</span><span class="p">%</span><span class="m">2F</span><span class="p">%</span><span class="m">2F</span><span class="n">localhost</span><span class="p">%</span><span class="m">3</span><span class="n">A7017</span><span class="p">%</span><span class="m">2F</span><span class="n">index</span><span class="p">.</span><span class="n">html</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>您可以使用 <a class="reference external" href="https://github.com/IdentityModel/IdentityModel2">IdentityModel</a> 客户端库以编程方式创建 end_session 请求 .NET 代码。 有关更多信息，请查看 IdentityModel <a class="reference external" href="https://identitymodel.readthedocs.io/en/latest/client/end_session.html">文档</a>。</p>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-reference/options"></span><div class="section" id="identityserver-options">
<h2>IdentityServer Options<a class="headerlink" href="#identityserver-options" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IssuerUri</span></code></dt><dd><p>设置将出现在发现文档中的颁发者名称和颁发的 JWT 令牌。
建议不要设置此属性，它会根据客户端使用的主机名推断颁发者名称。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">LowerCaseIssuerUri</span></code></dt><dd><p>设置为 <code class="docutils literal notranslate"><span class="pre">false</span></code> 以保留 IssuerUri 的原始大小写。 默认为 <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AccessTokenJwtType</span></code></dt><dd><p>指定用于访问令牌的 JWT 类型标头的值（默认为 <code class="docutils literal notranslate"><span class="pre">at+jwt</span></code>）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EmitScopesAsSpaceDelimitedStringInJwt</span></code></dt><dd><p>指定 JWT 中的作用域是作为数组还是字符串发出</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EmitStaticAudienceClaim</span></code></dt><dd><p>发出带有发行者/资源格式的 <code class="docutils literal notranslate"><span class="pre">aud</span></code> 声明。 默认为 false。</p>
</dd>
</dl>
</li>
</ul>
<div class="section" id="endpoints">
<h3>Endpoints<a class="headerlink" href="#endpoints" title="永久链接至标题">¶</a></h3>
<p>允许启用/禁用单个端点，例如 令牌，授权，用户信息等。</p>
<p>默认情况下，所有端点都已启用，但您可以通过禁用不需要的端点来锁定服务器。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EnableJwtRequestUri</span></code></dt><dd><p>在授权端点上启用 JWT request_uri 处理。 默认为 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="discovery">
<h3>Discovery<a class="headerlink" href="#discovery" title="永久链接至标题">¶</a></h3>
<p>允许启用/禁用发现文档的各个部分，例如 端点、范围、声明、授权类型等。</p>
<p><code class="docutils literal notranslate"><span class="pre">CustomEntries</span></code> 字典允许向发现文档添加自定义元素。</p>
</div>
<div class="section" id="authentication">
<h3>Authentication<a class="headerlink" href="#authentication" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CookieAuthenticationScheme</span></code></dt><dd><p>设置主机配置的用于交互用户的cookie认证方案。 如果未设置，将从主机的默认身份验证方案中推断出该方案。 当 AddPolicyScheme 在主机中用作默认方案时，通常使用此设置。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CookieLifetime</span></code></dt><dd><p>身份验证 cookie 生存期（仅在使用 IdentityServer 提供的 cookie 处理程序时才有效）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CookieSlidingExpiration</span></code></dt><dd><p>指定 cookie 是否应该滑动（仅在使用 IdentityServer 提供的 cookie 处理程序时有效）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CookieSameSiteMode</span></code></dt><dd><p>为内部 cookie 指定 SameSite 模式。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RequireAuthenticatedUserForSignOutMessage</span></code></dt><dd><p>指示用户是否必须经过身份验证才能接受参数以结束会话端点。 默认为 false。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CheckSessionCookieName</span></code></dt><dd><p>用于检查会话端点的 cookie 的名称。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CheckSessionCookieDomain</span></code></dt><dd><p>用于检查会话端点的 cookie 的域。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CheckSessionCookieSameSiteMode</span></code></dt><dd><p>用于检查会话端点的 cookie 的 SameSite 模式。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RequireCspFrameSrcForSignout</span></code></dt><dd><p>如果设置，将需要在结束会话回调端点上发出 frame-src CSP 标头，该端点将 iframe 呈现给客户端以进行前端通道注销通知。 默认为 true。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="events">
<h3>Events<a class="headerlink" href="#events" title="永久链接至标题">¶</a></h3>
<p>允许配置是否以及哪些事件应该提交到注册的事件接收器。 有关事件的更多信息，请参见 <a class="reference internal" href="index.html#refevents"><span class="std std-ref">此处</span></a>。</p>
</div>
<div class="section" id="inputlengthrestrictions">
<h3>InputLengthRestrictions<a class="headerlink" href="#inputlengthrestrictions" title="永久链接至标题">¶</a></h3>
<p>允许对各种协议参数（如客户端 ID、范围、重定向 URI 等）设置长度限制。</p>
</div>
<div class="section" id="userinteraction">
<h3>UserInteraction<a class="headerlink" href="#userinteraction" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">LoginUrl</span></code>, <code class="docutils literal notranslate"><span class="pre">LogoutUrl</span></code>, <code class="docutils literal notranslate"><span class="pre">ConsentUrl</span></code>, <code class="docutils literal notranslate"><span class="pre">ErrorUrl</span></code>, <code class="docutils literal notranslate"><span class="pre">DeviceVerificationUrl</span></code></dt><dd><p>设置登录、注销、同意、错误和设备验证页面的 URL。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">LoginReturnUrlParameter</span></code></dt><dd><p>设置传递给登录页面的返回 URL 参数的名称。 默认为 <em>returnUrl</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">LogoutIdParameter</span></code></dt><dd><p>设置传递给注销页面的注销消息 id 参数的名称。 默认为 <em>logoutId</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ConsentReturnUrlParameter</span></code></dt><dd><p>设置传递给同意页面的返回 URL 参数的名称。 默认为 <em>returnUrl</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ErrorIdParameter</span></code></dt><dd><p>设置传递给错误页面的错误消息 id 参数的名称。 默认为 <em>errorId</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CustomRedirectReturnUrlParameter</span></code></dt><dd><p>设置从授权端点传递给自定义重定向的返回 URL 参数的名称。 默认为 <em>returnUrl</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DeviceVerificationUserCodeParameter</span></code></dt><dd><p>设置传递给设备验证页面的用户代码参数的名称。 默认为 <em>userCode</em>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CookieMessageThreshold</span></code></dt><dd><p>IdentityServer 和一些 UI 页面之间的某些交互需要 cookie 来传递状态和上下文（上面的任何页面都具有可配置的 “message id” 参数）。
由于浏览器对 cookie 的数量和大小有限制，此设置用于防止创建过多的 cookie。
该值设置将创建的任何类型的消息 cookie 的最大数量。
一旦达到限制，最旧的消息 cookie 将被清除。
这有效地指示了用户在使用 IdentityServer 时可以打开多少个选项卡。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="caching">
<h3>Caching<a class="headerlink" href="#caching" title="永久链接至标题">¶</a></h3>
<p>只有在启动时在服务配置中启用了相应的缓存时，这些设置才适用。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ClientStoreExpiration</span></code></dt><dd><p>从客户端存储加载的客户端配置的缓存持续时间。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ResourceStoreExpiration</span></code></dt><dd><p>从资源存储加载的身份和 API 资源配置的缓存持续时间。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="cors">
<h3>CORS<a class="headerlink" href="#cors" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 为其某些端点支持 CORS。
底层 CORS 实现由 ASP.NET Core 提供，因此它会自动注册到依赖注入系统中。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CorsPolicyName</span></code></dt><dd><p>将评估 CORS 请求到 IdentityServer 的 CORS 策略的名称（默认为 <code class="docutils literal notranslate"><span class="pre">IdentityServer4</span></code>）。
处理这个的策略提供者是根据在依赖注入系统中注册的 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 实现的。
如果您希望自定义允许连接的 CORS 源集，则建议您提供 <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> 的自定义实现。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CorsPaths</span></code></dt><dd><p>IdentityServer 中支持 CORS 的端点。
默认为发现、用户信息、令牌和撤销端点。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PreflightCacheDuration</span></code></dt><dd><p><cite>Nullable&lt;TimeSpan&gt;</cite> 指示要在预检 <cite>Access-Control-Max-Age</cite> 响应标头中使用的值。
默认为 <cite>null</cite> 表示没有在响应中设置缓存头。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="csp">
<h3>CSP (内容安全政策)<a class="headerlink" href="#csp" title="永久链接至标题">¶</a></h3>
<p>IdentityServer 在适当的情况下为某些响应发出 CSP 标头。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Level</span></code></dt><dd><p>要使用的 CSP 级别。 默认情况下使用 CSP 级别 2，但如果必须支持旧浏览器，则将其更改为 <code class="docutils literal notranslate"><span class="pre">CspLevel.One</span></code> 以适应它们。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddDeprecatedHeader</span></code></dt><dd><p>指示是否还应发出旧的 <code class="docutils literal notranslate"><span class="pre">X-Content-Security-Policy</span></code> CSP 标头（除了基于标准的标头值）。 默认为 true。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="device-flow">
<h3>Device Flow<a class="headerlink" href="#device-flow" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DefaultUserCodeType</span></code></dt><dd><p>要使用的用户代码类型，除非在客户端级别设置。 默认为 <em>Numeric</em>，一个 9 位代码。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Interval</span></code></dt><dd><p>定义令牌端点上允许的最小轮询间隔。 默认为 <em>5</em>。</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="mutual-tls">
<h3>Mutual TLS<a class="headerlink" href="#mutual-tls" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Enabled</span></code></dt><dd><p>指定是否应启用 MTLS 支持。 默认为 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ClientCertificateAuthenticationScheme</span></code></dt><dd><p>指定 X.509 客户端证书的身份验证处理程序的名称。 默认为 <code class="docutils literal notranslate"><span class="pre">&quot;Certificate&quot;</span></code>。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DomainName</span></code></dt><dd><p>指定用于运行 MTLS 端点的子域或完整域的名称（如果未设置，将使用基于路径的端点）。
使用简单字符串（例如 <code class="docutils literal notranslate"><span class="pre">mtls</span></code>）设置子域，使用完整域名（例如 <code class="docutils literal notranslate"><span class="pre">identityserver-mtls.io</span></code>）设置完整域名。
使用完整域名时，还需要将 <code class="docutils literal notranslate"><span class="pre">IssuerName</span></code> 设置为固定值。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AlwaysEmitConfirmationClaim</span></code></dt><dd><p>指定如果存在客户端证书，是否为访问令牌发出 cnf 声明。
通常，只有当客户端使用客户端证书进行身份验证时，才会发出 cnf 声明，
将此设置为 true，无论身份验证方法如何，都将设置声明。 （默认为 false）。</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<span id="document-reference/identity_resource"></span><div class="section" id="identity-resource">
<h2>Identity Resource<a class="headerlink" href="#identity-resource" title="永久链接至标题">¶</a></h2>
<p>This class models an identity resource.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Enabled</span></code></dt><dd><p>Indicates if this resource is enabled and can be requested. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Name</span></code></dt><dd><p>The unique name of the identity resource. This is the value a client will use for the scope parameter in the authorize request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DisplayName</span></code></dt><dd><p>This value will be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>This value will be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Required</span></code></dt><dd><p>Specifies whether the user can de-select the scope on the consent screen (if the consent screen wants to implement such a feature). Defaults to false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Emphasize</span></code></dt><dd><p>Specifies whether the consent screen will emphasize this scope (if the consent screen wants to implement such a feature). Use this setting for sensitive or important scopes. Defaults to false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ShowInDiscoveryDocument</span></code></dt><dd><p>Specifies whether this scope is shown in the discovery document. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserClaims</span></code></dt><dd><p>List of associated user claim types that should be included in the identity token.</p>
</dd>
</dl>
</div>
<span id="document-reference/api_scope"></span><div class="section" id="api-scope">
<h2>API Scope<a class="headerlink" href="#api-scope" title="永久链接至标题">¶</a></h2>
<p>This class models an OAuth scope.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Enabled</span></code></dt><dd><p>Indicates if this resource is enabled and can be requested. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Name</span></code></dt><dd><p>The unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DisplayName</span></code></dt><dd><p>This value can be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>This value can be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserClaims</span></code></dt><dd><p>List of associated user claim types that should be included in the access token.</p>
</dd>
</dl>
<div class="section" id="defining-api-scope-in-appsettings-json">
<h3>Defining API scope in appsettings.json<a class="headerlink" href="#defining-api-scope-in-appsettings-json" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">AddInMemoryApiResource</span></code> extension method also supports adding clients from the ASP.NET Core configuration file:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;IdentityServer&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">&quot;IssuerUri&quot;</span><span class="p">:</span> <span class="s">&quot;urn:sso.company.com&quot;</span><span class="p">,</span>
    <span class="s">&quot;ApiScopes&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;IdentityServerApi&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;resource1.scope1&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;resource2.scope1&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;scope3&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;shared.scope&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;transaction&quot;</span><span class="p">,</span>
            <span class="s">&quot;DisplayName&quot;</span><span class="p">:</span> <span class="s">&quot;Transaction&quot;</span><span class="p">,</span>
            <span class="s">&quot;Description&quot;</span><span class="p">:</span> <span class="s">&quot;A transaction&quot;</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then pass the configuration section to the <code class="docutils literal notranslate"><span class="pre">AddInMemoryApiScopes</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">AddInMemoryApiScopes</span><span class="p">(</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="s">&quot;IdentityServer:ApiScopes&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-reference/api_resource"></span><div class="section" id="api-resource">
<h2>API Resource<a class="headerlink" href="#api-resource" title="永久链接至标题">¶</a></h2>
<p>This class models an API resource.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Enabled</span></code></dt><dd><p>Indicates if this resource is enabled and can be requested. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Name</span></code></dt><dd><p>The unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DisplayName</span></code></dt><dd><p>This value can be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>This value can be used e.g. on the consent screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ApiSecrets</span></code></dt><dd><p>The API secret is used for the introspection endpoint. The API can authenticate with introspection using the API name and secret.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowedAccessTokenSigningAlgorithms</span></code></dt><dd><p>List of allowed signing algorithms for access token. If empty, will use the server default signing algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserClaims</span></code></dt><dd><p>List of associated user claim types that should be included in the access token.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Scopes</span></code></dt><dd><p>List of API scope names.</p>
</dd>
</dl>
<div class="section" id="defining-api-resources-in-appsettings-json">
<h3>Defining API resources in appsettings.json<a class="headerlink" href="#defining-api-resources-in-appsettings-json" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">AddInMemoryApiResource</span></code> extensions method also supports adding API resources from the ASP.NET Core configuration file:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;IdentityServer&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">&quot;IssuerUri&quot;</span><span class="p">:</span> <span class="s">&quot;urn:sso.company.com&quot;</span><span class="p">,</span>
    <span class="s">&quot;ApiResources&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;resource1&quot;</span><span class="p">,</span>
            <span class="s">&quot;DisplayName&quot;</span><span class="p">:</span> <span class="s">&quot;Resource #1&quot;</span><span class="p">,</span>

            <span class="s">&quot;Scopes&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="s">&quot;resource1.scope1&quot;</span><span class="p">,</span>
                <span class="s">&quot;shared.scope&quot;</span>
            <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;resource2&quot;</span><span class="p">,</span>
            <span class="s">&quot;DisplayName&quot;</span><span class="p">:</span> <span class="s">&quot;Resource #2&quot;</span><span class="p">,</span>

            <span class="s">&quot;UserClaims&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="s">&quot;name&quot;</span><span class="p">,</span>
                <span class="s">&quot;email&quot;</span>
            <span class="p">],</span>

            <span class="s">&quot;Scopes&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="s">&quot;resource2.scope1&quot;</span><span class="p">,</span>
                <span class="s">&quot;shared.scope&quot;</span>
            <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then pass the configuration section to the <code class="docutils literal notranslate"><span class="pre">AddInMemoryApiResource</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">AddInMemoryApiResources</span><span class="p">(</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="s">&quot;IdentityServer:ApiResources&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-reference/client"></span><div class="section" id="client">
<h2>Client<a class="headerlink" href="#client" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Client</span></code> class models an OpenID Connect or OAuth 2.0 client -
e.g. a native application, a web application or a JS-based application.</p>
<div class="section" id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Enabled</span></code></dt><dd><p>Specifies if client is enabled. Defaults to <cite>true</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientId</span></code></dt><dd><p>Unique ID of the client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientSecrets</span></code></dt><dd><p>List of client secrets - credentials to access the token endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequireClientSecret</span></code></dt><dd><p>Specifies whether this client needs a secret to request tokens from the token endpoint (defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequireRequestObject</span></code></dt><dd><p>Specifies whether this client needs to wrap the authorize request parameters in a JWT (defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowedGrantTypes</span></code></dt><dd><p>Specifies the grant types the client is allowed to use. Use the <code class="docutils literal notranslate"><span class="pre">GrantTypes</span></code> class for common combinations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequirePkce</span></code></dt><dd><p>Specifies whether clients using an authorization code based grant type must send a proof key (defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowPlainTextPkce</span></code></dt><dd><p>Specifies whether clients using PKCE can use a plain text code challenge (not recommended - and default to <code class="docutils literal notranslate"><span class="pre">false</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RedirectUris</span></code></dt><dd><p>Specifies the allowed URIs to return tokens or authorization codes to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowedScopes</span></code></dt><dd><p>By default a client has no access to any resources - specify the allowed resources by adding the corresponding scopes names</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowOfflineAccess</span></code></dt><dd><p>Specifies whether this client can request refresh tokens (be requesting the <code class="docutils literal notranslate"><span class="pre">offline_access</span></code> scope)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowAccessTokensViaBrowser</span></code></dt><dd><p>Specifies whether this client is allowed to receive access tokens via the browser.
This is useful to harden flows that allow multiple response types
(e.g. by disallowing a hybrid flow client that is supposed to use <cite>code id_token</cite> to add the <cite>token</cite> response type
and thus leaking the token to the browser.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Properties</span></code></dt><dd><p>Dictionary to hold any custom client-specific values as needed.</p>
</dd>
</dl>
</div>
<div class="section" id="authentication-logout">
<h3>Authentication/Logout<a class="headerlink" href="#authentication-logout" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PostLogoutRedirectUris</span></code></dt><dd><p>Specifies allowed URIs to redirect to after logout. See the <a class="reference external" href="https://openid.net/specs/openid-connect-session-1_0.html">OIDC Connect Session Management spec</a> for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FrontChannelLogoutUri</span></code></dt><dd><p>Specifies logout URI at client for HTTP based front-channel logout. See the <a class="reference external" href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">OIDC Front-Channel spec</a> for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FrontChannelLogoutSessionRequired</span></code></dt><dd><p>Specifies if the user’s session id should be sent to the FrontChannelLogoutUri. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BackChannelLogoutUri</span></code></dt><dd><p>Specifies logout URI at client for HTTP based back-channel logout. See the <a class="reference external" href="https://openid.net/specs/openid-connect-backchannel-1_0.html">OIDC Back-Channel spec</a> for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BackChannelLogoutSessionRequired</span></code></dt><dd><p>Specifies if the user’s session id should be sent in the request to the BackChannelLogoutUri. Defaults to true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EnableLocalLogin</span></code></dt><dd><p>Specifies if this client can use local accounts, or external IdPs only. Defaults to <cite>true</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IdentityProviderRestrictions</span></code></dt><dd><p>Specifies which external IdPs can be used with this client (if list is empty all IdPs are allowed). Defaults to empty.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UserSsoLifetime</span></code> <cite>added in 2.3</cite></dt><dd><p>The maximum duration (in seconds) since the last time the user authenticated. Defaults to <code class="docutils literal notranslate"><span class="pre">null</span></code>.
You can adjust the lifetime of a session token to control when and how often a user is required to reenter credentials instead of being silently authenticated, when using a web application.</p>
</dd>
</dl>
</div>
<div class="section" id="token">
<h3>Token<a class="headerlink" href="#token" title="永久链接至标题">¶</a></h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IdentityTokenLifetime</span></code></dt><dd><p>Lifetime to identity token in seconds (defaults to 300 seconds / 5 minutes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowedIdentityTokenSigningAlgorithms</span></code></dt><dd><p>List of allowed signing algorithms for identity token. If empty, will use the server default signing algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AccessTokenLifetime</span></code></dt><dd><p>Lifetime of access token in seconds (defaults to 3600 seconds / 1 hour)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AuthorizationCodeLifetime</span></code></dt><dd><p>Lifetime of authorization code in seconds (defaults to 300 seconds / 5 minutes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AbsoluteRefreshTokenLifetime</span></code></dt><dd><p>Maximum lifetime of a refresh token in seconds. Defaults to 2592000 seconds / 30 days</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SlidingRefreshTokenLifetime</span></code></dt><dd><p>Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RefreshTokenUsage</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ReUse</span></code> the refresh token handle will stay the same when refreshing tokens</p>
<p><code class="docutils literal notranslate"><span class="pre">OneTime</span></code> the refresh token handle will be updated when refreshing tokens. This is the default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RefreshTokenExpiration</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">Absolute</span></code> the refresh token will expire on a fixed point in time (specified by the AbsoluteRefreshTokenLifetime). This is the default.</p>
<p><code class="docutils literal notranslate"><span class="pre">Sliding</span></code> when refreshing the token, the lifetime of the refresh token will be renewed (by the amount specified in SlidingRefreshTokenLifetime). The lifetime will not exceed <cite>AbsoluteRefreshTokenLifetime</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UpdateAccessTokenClaimsOnRefresh</span></code></dt><dd><p>Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AccessTokenType</span></code></dt><dd><p>Specifies whether the access token is a reference token or a self contained JWT token (defaults to <cite>Jwt</cite>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IncludeJwtId</span></code></dt><dd><p>Specifies whether JWT access tokens should have an embedded unique ID (via the <cite>jti</cite> claim). Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowedCorsOrigins</span></code></dt><dd><p>If specified, will be used by the default CORS policy service implementations (In-Memory and EF) to build a CORS policy for JavaScript clients.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Claims</span></code></dt><dd><p>Allows settings claims for the client (will be included in the access token).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AlwaysSendClientClaims</span></code></dt><dd><p>If set, the client claims will be sent for every flow. If not, only for client credentials flow (default is <cite>false</cite>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AlwaysIncludeUserClaimsInIdToken</span></code></dt><dd><p>When requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the userinfo endpoint. Default is <cite>false</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientClaimsPrefix</span></code></dt><dd><p>If set, the prefix client claim types will be prefixed with. Defaults to <cite>client_</cite>. The intent is to make sure they don’t accidentally collide with user claims.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PairWiseSubjectSalt</span></code></dt><dd><p>Salt value used in pair-wise subjectId generation for users of this client.</p>
</dd>
</dl>
</div>
<div class="section" id="consent-screen">
<h3>Consent Screen<a class="headerlink" href="#consent-screen" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RequireConsent</span></code></dt><dd><p>Specifies whether a consent screen is required. Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AllowRememberConsent</span></code></dt><dd><p>Specifies whether user can choose to store consent decisions. Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ConsentLifetime</span></code></dt><dd><p>Lifetime of a user consent in seconds. Defaults to null (no expiration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientName</span></code></dt><dd><p>Client display name (used for logging and consent screen)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientUri</span></code></dt><dd><p>URI to further information about client (used on consent screen)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LogoUri</span></code></dt><dd><p>URI to client logo (used on consent screen)</p>
</dd>
</dl>
</div>
<div class="section" id="device-flow">
<h3>Device flow<a class="headerlink" href="#device-flow" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">UserCodeType</span></code></dt><dd><p>Specifies the type of user code to use for the client. Otherwise falls back to default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DeviceCodeLifetime</span></code></dt><dd><p>Lifetime to device code in seconds (defaults to 300 seconds / 5 minutes)</p>
</dd>
</dl>
</div>
</div>
<span id="document-reference/grant_validation_result"></span><div class="section" id="grantvalidationresult">
<h2>GrantValidationResult<a class="headerlink" href="#grantvalidationresult" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">GrantValidationResult</span></code> class models the outcome of grant validation for extensions grants and resource owner password grants.</p>
<p>The most common usage is to either new it up using an identity (success case):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">GrantValidationResult</span><span class="p">(</span>
    <span class="n">subject</span><span class="p">:</span> <span class="s">&quot;818727&quot;</span><span class="p">,</span>
    <span class="n">authenticationMethod</span><span class="p">:</span> <span class="s">&quot;custom&quot;</span><span class="p">,</span>
    <span class="n">claims</span><span class="p">:</span> <span class="n">optionalClaims</span><span class="p">);</span>
</pre></div>
</div>
<p>…or using an error and description (failure case):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">GrantValidationResult</span><span class="p">(</span>
    <span class="n">TokenRequestErrors</span><span class="p">.</span><span class="n">InvalidGrant</span><span class="p">,</span>
    <span class="s">&quot;invalid custom credential&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>In both case you can pass additional custom values that will be included in the token response.</p>
</div>
<span id="document-reference/profileservice"></span><div class="section" id="profile-service">
<h2>Profile Service<a class="headerlink" href="#profile-service" title="永久链接至标题">¶</a></h2>
<p>在创建令牌或处理对 userinfo 或自省端点的请求时，IdentityServer 通常需要有关用户的身份信息。
默认情况下，IdentityServer 只有身份验证 cookie 中的声明可用于此身份数据。</p>
<p>将用户所需的所有可能声明都放入 cookie 是不切实际的，因此 IdentityServer 定义了一个扩展点，允许根据用户需要动态加载声明。
此扩展点是 <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code>，开发人员通常会实现此接口以访问包含用户身份数据的自定义数据库或 API。</p>
<div class="section" id="iprofileservice-apis">
<h3>IProfileService APIs<a class="headerlink" href="#iprofileservice-apis" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetProfileDataAsync</span></code></dt><dd><p>预期为用户加载声明的 API。 它传递了一个 <code class="docutils literal notranslate"><span class="pre">ProfileDataRequestContext</span></code> 的实例。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IsActiveAsync</span></code></dt><dd><p>预期指示当前是否允许用户获取令牌的 API。 它传递了一个 <code class="docutils literal notranslate"><span class="pre">IsActiveContext</span></code> 的实例。</p>
</dd>
</dl>
</div>
<div class="section" id="profiledatarequestcontext">
<h3>ProfileDataRequestContext<a class="headerlink" href="#profiledatarequestcontext" title="永久链接至标题">¶</a></h3>
<p>为用户声明的请求建模，并且是返回这些声明的工具。 它包含以下属性：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Subject</span></code></dt><dd><p>对用户建模的 <code class="docutils literal notranslate"><span class="pre">ClaimsPrincipal</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Client</span></code></dt><dd><p>正在为其请求声明的 <code class="docutils literal notranslate"><span class="pre">客户端</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code></dt><dd><p>正在请求的声明类型的集合。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Caller</span></code></dt><dd><p>请求声明的上下文的标识符（例如身份令牌、访问令牌或用户信息端点）。 常量 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.ProfileDataCallers</span></code> 包含不同的常量值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IssuedClaims</span></code></dt><dd><p>将返回的 <code class="docutils literal notranslate"><span class="pre">Claim</span></code> 列表。 这预计将由自定义 <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code> 实现填充。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AddRequestedClaims</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ProfileDataRequestContext</span></code> 上的扩展方法来填充 <code class="docutils literal notranslate"><span class="pre">IssuedClaims</span></code>，但首先根据 <code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code> 过滤声明。</p>
</dd>
</dl>
</div>
<div class="section" id="id1">
<h3>请求的范围和声明映射<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>客户端请求的范围控制用户声明在令牌中返回给客户端的内容。
<code class="docutils literal notranslate"><span class="pre">GetProfileDataAsync</span></code> 方法负责根据 <code class="docutils literal notranslate"><span class="pre">ProfileDataRequestContext</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code> 集合动态获取这些声明。</p>
<p><code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code> 集合是根据 <a class="reference internal" href="index.html#refresources"><span class="std std-ref">资源</span></a> 上定义的用户声明填充的，该用户声明对范围进行建模。
如果请求身份令牌并且请求的范围是 <a class="reference internal" href="index.html#refidentityresource"><span class="std std-ref">身份资源</span></a>，则 <code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code> 中的声明将根据 <code class="docutils literal notranslate"><span class="pre">IdentityResource</span></code> 中定义的用户声明类型填充。
如果请求访问令牌并且请求的范围是 <a class="reference internal" href="index.html#refapiresource"><span class="std std-ref">API 资源</span></a>，则 <code class="docutils literal notranslate"><span class="pre">RequestedClaimTypes</span></code> 中的声明将根据 <code class="docutils literal notranslate"><span class="pre">ApiResource</span></code> 和（或） <code class="docutils literal notranslate"><span class="pre">Scope</span></code>。</p>
</div>
<div class="section" id="isactivecontext">
<h3>IsActiveContext<a class="headerlink" href="#isactivecontext" title="永久链接至标题">¶</a></h3>
<p>对请求建模以确定当前是否允许用户获取令牌。 它包含以下属性：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Subject</span></code></dt><dd><p>对用户建模的 <code class="docutils literal notranslate"><span class="pre">ClaimsPrincipal</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Client</span></code></dt><dd><p>正在为其请求声明的 <code class="docutils literal notranslate"><span class="pre">客户端</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Caller</span></code></dt><dd><p>请求声明的上下文的标识符（例如身份令牌、访问令牌或用户信息端点）。 常量 <code class="docutils literal notranslate"><span class="pre">IdentityServerConstants.ProfileDataCallers</span></code> 包含不同的常量值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IsActive</span></code></dt><dd><p>指示是否允许用户获取令牌的标志。 这预计由自定义 <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code> 实现分配。</p>
</dd>
</dl>
</div>
</div>
<span id="document-reference/interactionservice"></span><div class="section" id="identityserver-interaction-service">
<h2>IdentityServer Interaction Service<a class="headerlink" href="#identityserver-interaction-service" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">IIdentityServerInteractionService</span></code> interface is intended to provide services to be used by the user interface to communicate with IdentityServer, mainly pertaining to user interaction.
It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.</p>
<div class="section" id="iidentityserverinteractionservice-apis">
<h3>IIdentityServerInteractionService APIs<a class="headerlink" href="#iidentityserverinteractionservice-apis" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetAuthorizationContextAsync</span></code></dt><dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">AuthorizationRequest</span></code> based on the <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> passed to the login or consent pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IsValidReturnUrl</span></code></dt><dd><p>Indicates if the <code class="docutils literal notranslate"><span class="pre">returnUrl</span></code> is a valid URL for redirect after login or consent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GetErrorContextAsync</span></code></dt><dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">ErrorMessage</span></code> based on the <code class="docutils literal notranslate"><span class="pre">errorId</span></code> passed to the error page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GetLogoutContextAsync</span></code></dt><dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">LogoutRequest</span></code> based on the <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> passed to the logout page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CreateLogoutContextAsync</span></code></dt><dd><p>Used to create a <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> if there is not one presently.
This creates a cookie capturing all the current state needed for signout and the <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> identifies that cookie.
This is typically used when there is no current <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> and the logout page must capture the current user’s state needed for sign-out prior to redirecting to an external identity provider for signout.
The newly created <code class="docutils literal notranslate"><span class="pre">logoutId</span></code> would need to be round-tripped to the external identity provider at signout time, and then used on the signout callback page in the same way it would be on the normal logout page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GrantConsentAsync</span></code></dt><dd><p>Accepts a <code class="docutils literal notranslate"><span class="pre">ConsentResponse</span></code> to inform IdentityServer of the user’s consent to a particular <code class="docutils literal notranslate"><span class="pre">AuthorizationRequest</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DenyAuthorizationAsync</span></code></dt><dd><p>Accepts a <code class="docutils literal notranslate"><span class="pre">AuthorizationError</span></code> to inform IdentityServer of the error to return to the client for a particular <code class="docutils literal notranslate"><span class="pre">AuthorizationRequest</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GetAllUserGrantsAsync</span></code></dt><dd><p>Returns a collection of <code class="docutils literal notranslate"><span class="pre">Grant</span></code> for the user. These represent a user’s consent or a clients access to a user’s resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RevokeUserConsentAsync</span></code></dt><dd><p>Revokes all of a user’s consents and grants for a client.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RevokeTokensForCurrentSessionAsync</span></code></dt><dd><p>Revokes all of a user’s consents and grants for clients the user has signed into during their current session.</p>
</dd>
</dl>
</div>
<div class="section" id="authorizationrequest">
<h3>AuthorizationRequest<a class="headerlink" href="#authorizationrequest" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Client</span></code></dt><dd><p>The client that initiated the request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RedirectUri</span></code></dt><dd><p>The URI to redirect the user to after successful authorization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DisplayMode</span></code></dt><dd><p>The display mode passed from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UiLocales</span></code></dt><dd><p>The UI locales passed from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IdP</span></code></dt><dd><p>The external identity provider requested.
This is used to bypass home realm discovery (HRD).
This is provided via the “idp:” prefix to the <code class="docutils literal notranslate"><span class="pre">acr_values</span></code> parameter on the authorize request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Tenant</span></code></dt><dd><p>The tenant requested.
This is provided via the “tenant:” prefix to the <code class="docutils literal notranslate"><span class="pre">acr_values</span></code> parameter on the authorize request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LoginHint</span></code></dt><dd><p>The expected username the user will use to login.
This is requested from the client via the <code class="docutils literal notranslate"><span class="pre">login_hint</span></code> parameter on the authorize request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PromptMode</span></code></dt><dd><p>The prompt mode requested from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AcrValues</span></code></dt><dd><p>The acr values passed from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ValidatedResources</span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">ResourceValidationResult</span></code> which represents the validated resources from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Parameters</span></code></dt><dd><p>The entire parameter collection passed to the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequestObjectValues</span></code></dt><dd><p>The validated contents of the request object (if present).</p>
</dd>
</dl>
</div>
<div class="section" id="resourcevalidationresult">
<h3>ResourceValidationResult<a class="headerlink" href="#resourcevalidationresult" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Resources</span></code></dt><dd><p>The resources of the result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ParsedScopes</span></code></dt><dd><p>The parsed scopes represented by the result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RawScopeValues</span></code></dt><dd><p>The original (raw) scope values represented by the validated result.</p>
</dd>
</dl>
</div>
<div class="section" id="errormessage">
<h3>ErrorMessage<a class="headerlink" href="#errormessage" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DisplayMode</span></code></dt><dd><p>The display mode passed from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UiLocales</span></code></dt><dd><p>The UI locales passed from the authorization request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Error</span></code></dt><dd><p>The error code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RequestId</span></code></dt><dd><p>The per-request identifier. This can be used to display to the end user and can be used in diagnostics.</p>
</dd>
</dl>
</div>
<div class="section" id="logoutrequest">
<h3>LogoutRequest<a class="headerlink" href="#logoutrequest" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ClientId</span></code></dt><dd><p>The client identifier that initiated the request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PostLogoutRedirectUri</span></code></dt><dd><p>The URL to redirect the user to after they have logged out.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SessionId</span></code></dt><dd><p>The user’s current session id.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SignOutIFrameUrl</span></code></dt><dd><p>The URL to render in an <code class="docutils literal notranslate"><span class="pre">&lt;iframe&gt;</span></code> on the logged out page to enable single sign-out.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Parameters</span></code></dt><dd><p>The entire parameter collection passed to the end session endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ShowSignoutPrompt</span></code></dt><dd><p>Indicates if the user should be prompted for signout based upon the parameters passed to the end session endpoint.</p>
</dd>
</dl>
</div>
<div class="section" id="consentresponse">
<h3>ConsentResponse<a class="headerlink" href="#consentresponse" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ScopesValuesConsented</span></code></dt><dd><p>The collection of scopes the user consented to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RememberConsent</span></code></dt><dd><p>Flag indicating if the user’s consent is to be persisted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>Optional description the user can set for the grant (e.g. the name of the device being used when consent is given). This can be presented back to the user from the <a class="reference internal" href="index.html#refpersistedgrants"><span class="std std-ref">persisted grant service</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Error</span></code></dt><dd><p>Error, if any, for the consent response. This will be returned to the client in the authorization response.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ErrorDescription</span></code></dt><dd><p>Error description. This will be returned to the client in the authorization response.</p>
</dd>
</dl>
</div>
<div class="section" id="grant">
<h3>Grant<a class="headerlink" href="#grant" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SubjectId</span></code></dt><dd><p>The subject id that allowed the grant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ClientId</span></code></dt><dd><p>The client identifier for the grant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Description</span></code></dt><dd><p>The description the user assigned to the client or device being authorized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Scopes</span></code></dt><dd><p>The collection of scopes granted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CreationTime</span></code></dt><dd><p>The date and time when the grant was granted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Expiration</span></code></dt><dd><p>The date and time when the grant will expire.</p>
</dd>
</dl>
</div>
</div>
<span id="document-reference/deviceflow_interactionservice"></span><div class="section" id="device-flow-interaction-service">
<h2>Device Flow Interaction Service<a class="headerlink" href="#device-flow-interaction-service" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">IDeviceFlowInteractionService</span></code> interface is intended to provide services to be used by the user interface to communicate with IdentityServer during device flow authorization.
It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.</p>
<div class="section" id="ideviceflowinteractionservice-apis">
<h3>IDeviceFlowInteractionService APIs<a class="headerlink" href="#ideviceflowinteractionservice-apis" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetAuthorizationContextAsync</span></code></dt><dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">DeviceFlowAuthorizationRequest</span></code> based on the <code class="docutils literal notranslate"><span class="pre">userCode</span></code> passed to the login or consent pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DeviceFlowInteractionResult</span></code></dt><dd><p>Completes device authorization for the given <code class="docutils literal notranslate"><span class="pre">userCode</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="deviceflowauthorizationrequest">
<h3>DeviceFlowAuthorizationRequest<a class="headerlink" href="#deviceflowauthorizationrequest" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ClientId</span></code></dt><dd><p>The client identifier that initiated the request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ScopesRequested</span></code></dt><dd><p>The scopes requested from the authorization request.</p>
</dd>
</dl>
</div>
<div class="section" id="deviceflowinteractionresult">
<h3>DeviceFlowInteractionResult<a class="headerlink" href="#deviceflowinteractionresult" title="永久链接至标题">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IsError</span></code></dt><dd><p>Specifies if the authorization request errored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ErrorDescription</span></code></dt><dd><p>Error description upon failure.</p>
</dd>
</dl>
</div>
</div>
<span id="document-reference/ef"></span><div class="section" id="entity-framework-support">
<h2>Entity Framework Support<a class="headerlink" href="#entity-framework-support" title="永久链接至标题">¶</a></h2>
<p>An EntityFramework-based implementation is provided for the configuration and operational data extensibility points in IdentityServer.
The use of EntityFramework allows any EF-supported database to be used with this library.</p>
<p>The code for this library is located <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/src/EntityFramework">here</a> (with the underlying storage code <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/src/EntityFramework.Storage">here</a>) and the NuGet package is <a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.EntityFramework">here</a>.</p>
<p>The features provided by this library are broken down into two main areas: configuration store and operational store support.
These two different areas can be used independently or together, based upon the needs of the hosting application.</p>
<div class="section" id="configuration-store-support-for-clients-resources-and-cors-settings">
<h3>Configuration Store support for Clients, Resources, and CORS settings<a class="headerlink" href="#configuration-store-support-for-clients-resources-and-cors-settings" title="永久链接至标题">¶</a></h3>
<p>If client, identity resource, API resource, or CORS data is desired to be loaded from a EF-supported database
(rather than use in-memory configuration), then the configuration store can be used.
This support provides implementations of the <code class="docutils literal notranslate"><span class="pre">IClientStore</span></code>, <code class="docutils literal notranslate"><span class="pre">IResourceStore</span></code>, and the <code class="docutils literal notranslate"><span class="pre">ICorsPolicyService</span></code> extensibility points.
These implementations use a <code class="docutils literal notranslate"><span class="pre">DbContext</span></code>-derived class called <code class="docutils literal notranslate"><span class="pre">ConfigurationDbContext</span></code> to model the tables in the database.</p>
<p>To use the configuration store support, use the <code class="docutils literal notranslate"><span class="pre">AddConfigurationStore</span></code> extension method after the call to <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="n">IServiceProvider</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">string</span> <span class="n">connectionString</span> <span class="p">=</span> <span class="s">@&quot;Data Source=(LocalDb)\MSSQLLocalDB;database=IdentityServer4.EntityFramework-2.0.0;trusted_connection=yes;&quot;</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">migrationsAssembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Startup</span><span class="p">).</span><span class="n">GetTypeInfo</span><span class="p">().</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetName</span><span class="p">().</span><span class="n">Name</span><span class="p">;</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
        <span class="c1">// this adds the config data from DB (clients, resources, CORS)</span>
        <span class="p">.</span><span class="n">AddConfigurationStore</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">options</span><span class="p">.</span><span class="n">ConfigureDbContext</span> <span class="p">=</span> <span class="n">builder</span> <span class="p">=&gt;</span>
                <span class="n">builder</span><span class="p">.</span><span class="n">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">,</span>
                    <span class="n">sql</span> <span class="p">=&gt;</span> <span class="n">sql</span><span class="p">.</span><span class="n">MigrationsAssembly</span><span class="p">(</span><span class="n">migrationsAssembly</span><span class="p">));</span>
        <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To configure the configuration store, use the <code class="docutils literal notranslate"><span class="pre">ConfigurationStoreOptions</span></code> options object passed to the configuration callback.</p>
</div>
<div class="section" id="configurationstoreoptions">
<h3>ConfigurationStoreOptions<a class="headerlink" href="#configurationstoreoptions" title="永久链接至标题">¶</a></h3>
<p>This options class contains properties to control the configuration store and <code class="docutils literal notranslate"><span class="pre">ConfigurationDbContext</span></code>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ConfigureDbContext</span></code></dt><dd><p>Delegate of type <code class="docutils literal notranslate"><span class="pre">Action&lt;DbContextOptionsBuilder&gt;</span></code> used as a callback to configure the underlying <code class="docutils literal notranslate"><span class="pre">ConfigurationDbContext</span></code>.
The delegate can configure the <code class="docutils literal notranslate"><span class="pre">ConfigurationDbContext</span></code> in the same way if EF were being used directly with <code class="docutils literal notranslate"><span class="pre">AddDbContext</span></code>, which allows any EF-supported database to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DefaultSchema</span></code></dt><dd><p>Allows setting the default database schema name for all the tables in the <code class="docutils literal notranslate"><span class="pre">ConfigurationDbContext</span></code></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">.</span><span class="n">DefaultSchema</span> <span class="p">=</span> <span class="s">&quot;myConfigurationSchema&quot;</span><span class="p">;</span>
</pre></div>
</div>
</dd>
</dl>
<p>If you need to change the schema for the Migration History Table, you can chain another action to the <code class="docutils literal notranslate"><span class="pre">UseSqlServer</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">.</span><span class="n">ConfigureDbContext</span> <span class="p">=</span> <span class="n">b</span> <span class="p">=&gt;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">,</span>
        <span class="n">sql</span> <span class="p">=&gt;</span> <span class="n">sql</span><span class="p">.</span><span class="n">MigrationsAssembly</span><span class="p">(</span><span class="n">migrationsAssembly</span><span class="p">).</span><span class="n">MigrationsHistoryTable</span><span class="p">(</span><span class="s">&quot;MyConfigurationMigrationTable&quot;</span><span class="p">,</span> <span class="s">&quot;myConfigurationSchema&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="operational-store-support-for-persisted-grants">
<h3>Operational Store support for persisted grants<a class="headerlink" href="#operational-store-support-for-persisted-grants" title="永久链接至标题">¶</a></h3>
<p>If <a class="reference internal" href="index.html#refpersistedgrants"><span class="std std-ref">persisted grants</span></a> are desired to be loaded from a EF-supported database (rather than the default in-memory database), then the operational store can be used.
This support provides implementations of the <code class="docutils literal notranslate"><span class="pre">IPersistedGrantStore</span></code> extensibility point.
The implementation uses a <code class="docutils literal notranslate"><span class="pre">DbContext</span></code>-derived class called <code class="docutils literal notranslate"><span class="pre">PersistedGrantDbContext</span></code> to model the table in the database.</p>
<p>To use the operational store support, use the <code class="docutils literal notranslate"><span class="pre">AddOperationalStore</span></code> extension method after the call to <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="n">IServiceProvider</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">string</span> <span class="n">connectionString</span> <span class="p">=</span> <span class="s">@&quot;Data Source=(LocalDb)\MSSQLLocalDB;database=IdentityServer4.EntityFramework-2.0.0;trusted_connection=yes;&quot;</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">migrationsAssembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Startup</span><span class="p">).</span><span class="n">GetTypeInfo</span><span class="p">().</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetName</span><span class="p">().</span><span class="n">Name</span><span class="p">;</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
        <span class="c1">// this adds the operational data from DB (codes, tokens, consents)</span>
        <span class="p">.</span><span class="n">AddOperationalStore</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">options</span><span class="p">.</span><span class="n">ConfigureDbContext</span> <span class="p">=</span> <span class="n">builder</span> <span class="p">=&gt;</span>
                <span class="n">builder</span><span class="p">.</span><span class="n">UseSqlServer</span><span class="p">(</span><span class="n">connectionString</span><span class="p">,</span>
                    <span class="n">sql</span> <span class="p">=&gt;</span> <span class="n">sql</span><span class="p">.</span><span class="n">MigrationsAssembly</span><span class="p">(</span><span class="n">migrationsAssembly</span><span class="p">));</span>

            <span class="c1">// this enables automatic token cleanup. this is optional.</span>
            <span class="n">options</span><span class="p">.</span><span class="n">EnableTokenCleanup</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">options</span><span class="p">.</span><span class="n">TokenCleanupInterval</span> <span class="p">=</span> <span class="m">3600</span><span class="p">;</span> <span class="c1">// interval in seconds (default is 3600)</span>
        <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To configure the operational store, use the <code class="docutils literal notranslate"><span class="pre">OperationalStoreOptions</span></code> options object passed to the configuration callback.</p>
</div>
<div class="section" id="operationalstoreoptions">
<h3>OperationalStoreOptions<a class="headerlink" href="#operationalstoreoptions" title="永久链接至标题">¶</a></h3>
<p>This options class contains properties to control the operational store and <code class="docutils literal notranslate"><span class="pre">PersistedGrantDbContext</span></code>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ConfigureDbContext</span></code></dt><dd><p>Delegate of type <code class="docutils literal notranslate"><span class="pre">Action&lt;DbContextOptionsBuilder&gt;</span></code> used as a callback to configure the underlying <code class="docutils literal notranslate"><span class="pre">PersistedGrantDbContext</span></code>.
The delegate can configure the <code class="docutils literal notranslate"><span class="pre">PersistedGrantDbContext</span></code> in the same way if EF were being used directly with <code class="docutils literal notranslate"><span class="pre">AddDbContext</span></code>, which allows any EF-supported database to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DefaultSchema</span></code></dt><dd><p>Allows setting the default database schema name for all the tables in the <code class="docutils literal notranslate"><span class="pre">PersistedGrantDbContext</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EnableTokenCleanup</span></code></dt><dd><p>Indicates whether expired grants will be automatically cleaned up from the database. The default is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TokenCleanupInterval</span></code></dt><dd><p>The token cleanup interval (in seconds). The default is 3600 (1 hour).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The token cleanup feature does <em>not</em> remove persisted grants that are <em>consumed</em> (see <a class="reference internal" href="index.html#refpersistedgrants"><span class="std std-ref">persisted grants</span></a>).</p>
</div>
</div>
<div class="section" id="database-creation-and-schema-changes-across-different-versions-of-identityserver">
<h3>Database creation and schema changes across different versions of IdentityServer<a class="headerlink" href="#database-creation-and-schema-changes-across-different-versions-of-identityserver" title="永久链接至标题">¶</a></h3>
<p>It is very likely that across different versions of IdentityServer (and the EF support) that the database schema will change to accommodate new and changing features.</p>
<p>We do not provide any support for creating your database or migrating your data from one version to another.
You are expected to manage the database creation, schema changes, and data migration in any way your organization sees fit.</p>
<p>Using EF migrations is one possible approach to this.
If you do wish to use migrations, then see the <a class="reference internal" href="index.html#refentityframeworkquickstart"><span class="std std-ref">EF quickstart</span></a> for samples on how to get started, or consult the Microsoft <a class="reference external" href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/index">documentation on EF migrations</a>.</p>
<p>We also publish <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4/tree/main/src/EntityFramework.Storage/migrations/SqlServer/Migrations">sample SQL scripts</a> for the current version of the database schema.</p>
</div>
</div>
<span id="document-reference/aspnet_identity"></span><div class="section" id="asp-net-identity-support">
<h2>ASP.NET Identity Support<a class="headerlink" href="#asp-net-identity-support" title="永久链接至标题">¶</a></h2>
<p>An ASP.NET Identity-based implementation is provided for managing the identity database for users of IdentityServer.
This implementation implements the extensibility points in IdentityServer needed to load identity data for your users to emit claims into tokens.</p>
<p>The repo for this support is located <a class="reference external" href="https://github.com/IdentityServer/IdentityServer4.AspNetIdentity/">here</a> and the NuGet package is <a class="reference external" href="https://www.nuget.org/packages/IdentityServer4.AspNetIdentity">here</a>.</p>
<p>To use this library, configure ASP.NET Identity normally.
Then use the <code class="docutils literal notranslate"><span class="pre">AddAspNetIdentity</span></code> extension method after the call to <code class="docutils literal notranslate"><span class="pre">AddIdentityServer</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddIdentity</span><span class="p">&lt;</span><span class="n">ApplicationUser</span><span class="p">,</span> <span class="n">IdentityRole</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">AddEntityFrameworkStores</span><span class="p">&lt;</span><span class="n">ApplicationDbContext</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">AddDefaultTokenProviders</span><span class="p">();</span>

    <span class="n">services</span><span class="p">.</span><span class="n">AddIdentityServer</span><span class="p">()</span>
        <span class="p">.</span><span class="n">AddAspNetIdentity</span><span class="p">&lt;</span><span class="n">ApplicationUser</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AddAspNetIdentity</span></code> requires as a generic parameter the class that models your user for ASP.NET Identity (and the same one passed to <code class="docutils literal notranslate"><span class="pre">AddIdentity</span></code> to configure ASP.NET Identity).
This configures IdentityServer to use the ASP.NET Identity implementations of <code class="docutils literal notranslate"><span class="pre">IUserClaimsPrincipalFactory</span></code>, <code class="docutils literal notranslate"><span class="pre">IResourceOwnerPasswordValidator</span></code>, and <code class="docutils literal notranslate"><span class="pre">IProfileService</span></code>.
It also configures some of ASP.NET Identity’s options for use with IdentityServer (such as claim types to use and authentication cookie settings).</p>
<p>When using your own implementation of <code class="docutils literal notranslate"><span class="pre">IUserClaimsPrincipalFactory</span></code>, make sure that you register it before calling the IdentityServer <code class="docutils literal notranslate"><span class="pre">AddAspNetIdentity</span></code> extension method.</p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-misc/training"></span><div class="section" id="training">
<h2>Training<a class="headerlink" href="#training" title="永久链接至标题">¶</a></h2>
<p>Here are some online, remote and classroom training options to learn more about ASP.NET Core identity &amp; IdentityServer4.</p>
<div class="section" id="identity-access-control-for-modern-applications-using-asp-net-core-2-and-identityserver4">
<h3>Identity &amp; Access Control for modern Applications (using ASP.NET Core 2 and IdentityServer4)<a class="headerlink" href="#identity-access-control-for-modern-applications-using-asp-net-core-2-and-identityserver4" title="永久链接至标题">¶</a></h3>
<p>That’s our own three day flagship course (including extensive hands-on labs) that we deliver as part of conferences, on-sites and remote.</p>
<p>The agenda and dates for public training can be found <a class="reference external" href="https://identityserver.io/training">here</a>,
<a class="reference external" href="mailto:identity&#37;&#52;&#48;leastprivilege&#46;com">contact</a> us for private workshops.</p>
</div>
<div class="section" id="pluralsight-courses">
<h3>PluralSight courses<a class="headerlink" href="#pluralsight-courses" title="永久链接至标题">¶</a></h3>
<p>There are some good courses on PluralSight around identity, ASP.NET Core and IdentityServer.</p>
<p><strong>new</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.pluralsight.com/courses/openid-and-oauth2-securing-angular-apps">Securing Angular Apps with OpenID and OAuth2</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/aspnet-core-identity-management-playbook/table-of-contents">ASP.NET Core Identity Management Playbook</a></p></li>
<li><p><a class="reference external" href="https://www.pluralsight.com/courses/asp-dot-net-core-oauth/">Getting Started with ASP.NET Core and OAuth</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/asp-dotnet-core-oauth2-openid-connect-securing/">Securing ASP.NET Core with OAuth2 and OpenID Connect</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/asp-dot-net-core-security-understanding/">Understanding ASP.NET Core Security (Centralized Authentication with a Token Service)</a></p></li>
</ul>
<p><strong>older</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/oauth2-json-web-tokens-openid-connect-introduction/table-of-contents">Introduction to OAuth2, OpenID Connect and JSON Web Tokens (JWT)</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/webapi-v2-security/table-of-contents">Web API v2 Security</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/oauth-secure-asp-dot-net-api/table-of-contents">Using OAuth to Secure Your ASP.NET API</a></p></li>
<li><p><a class="reference external" href="https://app.pluralsight.com/library/courses/oauth2-openid-connect-angular-aspdotnet/table-of-contents">OAuth2 and OpenID Connect Strategies for Angular and ASP.NET</a></p></li>
</ul>
</div>
</div>
<span id="document-misc/blogs"></span><div class="section" id="blog-posts">
<h2>Blog posts<a class="headerlink" href="#blog-posts" title="永久链接至标题">¶</a></h2>
<div class="section" id="team-posts">
<h3>Team posts<a class="headerlink" href="#team-posts" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>2020<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://leastprivilege.com/2020/07/06/flexible-access-token-validation-in-asp-net-core/">Flexible Access Token Validation in ASP.NET Core</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/06/18/resource-access-in-identityserver4-v4-and-going-forward/">Resource Access in IdentityServer4 v4 and going forward</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/05/18/automatic-token-management-for-asp-net-core-and-worker-services-1-0/">Automatic Token Management for ASP.NET Core and Worker Services 1.0</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/02/12/mutual-tls-and-proof-of-possession-tokens-summary/">Mutual TLS and Proof-of-Possession Tokens: Summary</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/02/07/mutual-tls-and-proof-of-possession-access-tokens-part-1-setup/">Mutual TLS and Proof-of-Possession Access Tokens – Part 1: Setup</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/02/04/hardening-openid-connect-oauth-authorize-requests-and-responses/">Hardening OpenID Connect/OAuth Authorize Requests (and Responses)</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/01/21/hardening-refresh-tokens/">Hardening Refresh Tokens</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2020/01/15/oauth-2-0-the-long-road-to-proof-of-possession-access-tokens/">OAuth 2.0: The long Road to Proof-of-Possession Access Tokens</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/Outsourcing-IdentityServer4-Token-Signing-to-Azure-Key-Vault">Outsourcing IdentityServer4 Token Signing to Azure Key Vault</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/Using-ECDSA-in-IdentityServer4">Using ECDSA in IdentityServer4</a></p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>2019<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://brockallen.com/2019/02/25/scope-and-claims-design-in-identityserver/">Scope and claims design in IdentityServer</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2019/02/08/try-device-flow-with-identityserver4/">Try Device Flow with IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://brockallen.com/2019/01/03/the-state-of-the-implicit-flow-in-oauth2/">The State of the Implicit Flow in OAuth2</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2019/01/18/an-alternative-way-to-secure-spas-with-asp-net-core-openid-connect-oauth-2-0-and-proxykit/">An alternative way to secure SPAs (with ASP.NET Core, OpenID Connect, OAuth 2.0 and ProxyKit)</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2019/01/14/automatic-oauth-2-0-token-management-in-asp-net-core/">Automatic OAuth 2.0 Token Management in ASP.NET Core</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/Encrypting-Identity-Tokens-in-IdentityServer4">Encrypting Identity Tokens in IdentityServer4</a></p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>2018<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://leastprivilege.com/2018/01/17/ndc-london-2018-identityserver-update/">IdentityServer4 Update</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/ASPNET-Core-Swagger-UI-Authorization-using-IdentityServer4">IdentityServer and Swagger</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/OAuth/Removing-Shared-Secrets-for-OAuth-Client-Authentication">Removing Shared Secrets for OAuth Client Authentication</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/Creating-Your-Own-IdentityServer4-Storage-Library">Creating Your Own IdentityServer4 Storage Library</a></p></li>
</ul>
</div>
<div class="section" id="id4">
<h4>2017<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="https://leastprivilege.com/2017/01/15/platforms-where-you-can-run-identityserver4/">Platforms where you can run IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2016/12/14/optimizing-identity-tokens-for-size/">Optimizing Tokens for size</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2016/12/16/identity-vs-permissions/">Identity vs Permissions</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2017/01/06/bootstrapping-openid-connect-discovery/">Bootstraping OpenID Connect: Discovery</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2017/03/03/extending-identityserver4-with-ws-federation-support/">Extending IdentityServer4 with WS-Federation Support</a></p></li>
<li><p><a class="reference external" href="https://leastprivilege.com/2016/09/06/identityserver4-rc1/">Announcing IdentityServer4 RC1</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/Getting-Started-with-IdentityServer-4">Getting Started with IdentityServer 4</a></p></li>
<li><p><a class="reference external" href="https://www.scottbrady91.com/Identity-Server/IdentityServer-4-SharePoint-Integration-using-WS-Federation">IdentityServer 4 SharePoint Integration using WS-Federation</a></p></li>
</ul>
</div>
</div>
<div class="section" id="community-posts">
<h3>Community posts<a class="headerlink" href="#community-posts" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://nahidfa.com/posts/blazor-webassembly-authentication-and-authorization-with-identityserver4/">Blazor WebAssembly authentication and authorization with IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://lurumad.github.io/aditional-api-endpoints-to-identityserver4">Additional API Endpoints to IdentityServer 4</a></p></li>
<li><p><a class="reference external" href="https://lurumad.github.io/securing-hangfire-dashboard-using-an-openid-connect-server-identityserver-4">Securing Hangfire Dashboard using an OpenID Connect server (IdentityServer 4)</a></p></li>
<li><p><a class="reference external" href="https://wp.me/p3mRWu-1Ag/">OAuth 2.0 - OpenID Connect &amp; IdentityServer</a></p></li>
<li><p><a class="reference external" href="https://espressocoder.com/2019/01/29/running-identityserver4-in-a-docker-container/">Running IdentityServer4 in a Docker Container</a></p></li>
<li><p><a class="reference external" href="https://lurumad.github.io/connecting-zendesk-and-identityserver-4-saml2p-identity-provider">Connecting Zendesk and IdentityServer 4 SAML 2.0 Identity Provider</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2017/11/11/identityserver4-localization-using-ui_locales-and-the-query-string">IdentityServer localization using ui_locales</a></p></li>
<li><p><a class="reference external" href="https://www.strathweb.com/2017/10/self-issuing-an-identityserver4-token-in-an-identityserver4-service/">Self-issuing an IdentityServer4 token in an IdentityServer4 service</a></p></li>
<li><p><a class="reference external" href="https://blogs.msdn.microsoft.com/webdev/2017/01/23/asp-net-core-authentication-with-identityserver4/">IdentityServer4 on the ASP.NET Team Blog</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2016/03/02/angular2-openid-connect-implicit-flow-with-identityserver4/">Angular2 OpenID Connect Implicit Flow with IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2016/09/16/full-server-logout-with-identityserver4-and-openid-connect-implicit-flow/">Full Server Logout with IdentityServer4 and OpenID Connect Implicit Flow</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2016/10/01/identityserver4-webapi-and-angular2-in-a-single-asp-net-core-project/">IdentityServer4, ASP.NET Identity, Web API and Angular in a single Project</a></p></li>
<li><p><a class="reference external" href="https://social.technet.microsoft.com/wiki/contents/articles/37169.secure-your-netcore-web-applications-using-identityserver-4.aspx">Secure your .NETCore web applications using IdentityServer 4</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2017/04/14/asp-net-core-identityserver4-resource-owner-password-flow-with-custom-userrepository/">ASP.NET Core IdentityServer4 Resource Owner Password Flow with custom UserRepository</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2017/05/06/secure-asp-net-core-mvc-with-angular-using-identityserver4-openid-connect-hybrid-flow//">Secure ASP.NET Core MVC with Angular using IdentityServer4 OpenID Connect Hybrid Flow</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2017/07/11/adding-an-external-microsoft-login-to-identityserver4/">Adding an external Microsoft login to IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2017/07/14/implementing-two-factor-authentication-with-identityserver4-and-twilio/">Implementing Two-factor authentication with IdentityServer4 and Twilio</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2019/03/06/security-experiments-with-grpc-and-asp-net-core-3-0/">Security Experiments with gRPC and ASP.NET Core 3.0</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2019/02/20/asp-net-core-oauth-device-flow-client-with-identityserver4/">ASP.NET Core OAuth Device Flow Client with IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2019/01/29/securing-a-vue-js-app-using-openid-connect-code-flow-with-pkce-and-identityserver4/">Securing a Vue.js app using OpenID Connect Code Flow with PKCE and IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2018/10/18/using-an-odata-client-with-an-asp-net-core-api/">Using an OData Client with an ASP.NET Core API</a></p></li>
<li><p><a class="reference external" href="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/">OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4</a></p></li>
<li><p><a class="reference external" href="https://blog.tretainfotech.com/posts/2018/august/single-sign-out-in-identityserver4-with-back-channel-logout">Single Sign Out in IdentityServer4 with Back Channel Logout</a></p></li>
</ul>
</div>
</div>
<span id="document-misc/videos"></span><div class="section" id="videos">
<h2>Videos<a class="headerlink" href="#videos" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>2020<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=QpkVnB-N20c">January [NDC London] – Implementing OpenID Connect and OAuth 2.0 – Tips from the Trenches</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=AUgZffkurK0">January [NDC London] – OpenID Connect &amp; OAuth 2.0 – Security Best Practices</a></p></li>
</ul>
</div>
<div class="section" id="id2">
<h3>2019<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://vimeo.com/369311388">October [TDC] – Securing Web Applications and APIs with ASP.NET Core 3.0</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=EYk3KTwwbFA">January [NDC] – Securing Web Applications and APIs with ASP.NET Core 2.2 and 3.0</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=BM091_OlX3o">January [NDC] – Building Clients for OpenID Connect/OAuth 2-based Systems</a></p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>2018<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=Dlrf85NTuAU&amp;feature=youtu.be">26/09 [DevConf] – Authorization for modern Applications</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/254635632">17/01 [NDC London] – IdentityServer v2 on ASP.NET Core v2 - an Update</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/254635640">17/01 [NDC London] – Implementing authorization for web apps and APIs (aka PolicyServer announcement)</a></p></li>
<li><p><a class="reference external" href="https://dotnetrocks.com/?show=1515">17/01 [DotNetRocks] – IdentityServer and PolicyServer on DotNetRocks</a></p></li>
</ul>
</div>
<div class="section" id="id4">
<h3>2017<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://mva.microsoft.com/en-US/training-courses/introduction-to-identityserver-for-aspnet-core-17945">14/09 [Microsoft Learning] – Introduction to IdentityServer for ASP.NET Core - Brock Allen</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/223982185">14/06 [NDC Oslo] – Implementing Authorization for Web Applications and APIs</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/215352044">22/02 [NDC Mini Copenhagen] – IdentityServer4: New &amp; Improved for ASP.NET Core - Dominick Baier</a></p></li>
<li><p><a class="reference external" href="https://www.dotnetrocks.com/?show=1409">02/02 [DotNetRocks] – IdentityServer4 on DotNetRocks</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/204141878">16/01 [NDC London] – IdentityServer4: New and Improved for ASP.NET Core</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/205451987">16/01 [NDC London] – Building JavaScript and mobile/native Clients for Token-based Architectures</a></p></li>
</ul>
</div>
<div class="section" id="id5">
<h3>2016<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://channel9.msdn.com/events/Seth-on-the-Road/NDC-London-2016/Dominick-Baier-on-Identity-Server">The history of .NET identity and IdentityServer Channel9 interview</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/171942749">Authentication &amp; secure API access for native &amp; mobile Applications - Dominick Baier</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/172009501">ASP.NET Identity 3 - Brock Allen</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/154172925">Introduction to IdentityServer3 - Brock Allen</a></p></li>
</ul>
</div>
<div class="section" id="id6">
<h3>2015<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://vimeo.com/131635255">Securing Web APIs – Patterns &amp; Anti-Patterns - Dominick Baier</a></p></li>
<li><p><a class="reference external" href="https://vimeo.com/131636653">Authentication and authorization in modern JavaScript web applications – how hard can it be? - Brock Allen</a></p></li>
</ul>
</div>
<div class="section" id="id7">
<h3>2014<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://vimeo.com/113604459">Unifying Authentication &amp; Delegated API Access for Mobile, Web and the Desktop with OpenID Connect and OAuth 2 - Dominick Baier</a></p></li>
</ul>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020, Brock Allen &amp; Dominick Baier.
      <span class="commit">
        
        Revision <code>62e2afbe</code>.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/zh_CN/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//identityserver4docs.readthedocs.io/_/downloads/zh_CN/latest/pdf/">pdf</a></dd>
        
          <dd><a href="//identityserver4docs.readthedocs.io/_/downloads/zh_CN/latest/htmlzip/">html</a></dd>
        
          <dd><a href="//identityserver4docs.readthedocs.io/_/downloads/zh_CN/latest/epub/">epub</a></dd>
        
      </dl>
      <dl>
        
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/identityserver4docs/?fromdocs=identityserver4docs">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/identityserver4docs/?fromdocs=identityserver4docs">Builds</a>
          </dd>
      </dl>
    </div>
  </div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>