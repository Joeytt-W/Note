

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Autofac 5.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html#document-index" class="icon icon-home"> Autofac
          

          
          </a>

          
            
            
            
              <div class="version">
                v5.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-getting-started/index">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#structuring-the-application">Structuring the Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#add-autofac-references">Add Autofac References</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#application-startup">Application Startup</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#application-execution">Application Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#going-further">Going Further</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#need-help">Need Help?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#building-from-source">Building from Source</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-whats-new/index">What’s New</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-whats-new/releasenotes">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-whats-new/upgradingfrom3to4">Upgrading from Autofac 3.x to 4.x</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-register/index">Registering Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-register/registration">Registration Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#reflection-components">Reflection Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-components">Instance Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#lambda-expression-components">Lambda Expression Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#open-generic-components">Open Generic Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#services-vs-components">Services vs. Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#default-registrations">Default Registrations</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#conditional-registration">Conditional Registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuration-of-registrations">Configuration of Registrations</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dynamically-provided-registrations">Dynamically-Provided Registrations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-register/parameters">Passing Parameters to Register</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#available-parameter-types">Available Parameter Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#parameters-with-reflection-components">Parameters with Reflection Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#parameters-with-lambda-expression-components">Parameters with Lambda Expression Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-register/prop-method-injection">Property and Method Injection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#property-injection">Property Injection</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#method-injection">Method Injection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-register/scanning">Assembly Scanning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#scanning-for-types">Scanning for Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#scanning-for-modules">Scanning for Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#iis-hosted-web-applications">IIS Hosted Web Applications</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-resolve/index">Resolving Services</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-resolve/parameters">Passing Parameters to Resolve</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#available-parameter-types">Available Parameter Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#parameters-with-reflection-components">Parameters with Reflection Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#parameters-with-lambda-expression-components">Parameters with Lambda Expression Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#passing-parameters-without-explicitly-calling-resolve">Passing Parameters Without Explicitly Calling Resolve</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-resolve/relationships">Implicit Relationship Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#supported-relationship-types">Supported Relationship Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#composing-relationship-types">Composing Relationship Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#relationship-types-and-container-independence">Relationship Types and Container Independence</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-lifetime/index">Controlling Scope and Lifetime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/working-with-scopes">Working with Lifetime Scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#creating-a-new-lifetime-scope">Creating a New Lifetime Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tagging-a-lifetime-scope">Tagging a Lifetime Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#adding-registrations-to-a-lifetime-scope">Adding Registrations to a Lifetime Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/instance-scope">Instance Scope</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-per-dependency">Instance Per Dependency</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#single-instance">Single Instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-per-lifetime-scope">Instance Per Lifetime Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-per-matching-lifetime-scope">Instance Per Matching Lifetime Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-per-request">Instance Per Request</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#instance-per-owned">Instance Per Owned</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#thread-scope">Thread Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/captive-dependencies">Captive Dependencies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#general-rule">General Rule</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#simple-example">Simple Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#code-example">Code Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#exception-to-the-rule">Exception to the Rule</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/disposal">Disposal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#registering-components">Registering Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#resolve-components-from-lifetime-scopes">Resolve Components from Lifetime Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#child-scopes-are-not-automatically-disposed">Child Scopes are NOT Automatically Disposed</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#provided-instances">Provided Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#advanced-hierarchies">Advanced Hierarchies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/events">Lifetime Events</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#onpreparing">OnPreparing</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#onactivating">OnActivating</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#onactivated">OnActivated</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#onrelease">OnRelease</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-lifetime/startup">Running Code at Startup</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#startable-components">Startable Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#auto-activated-components">Auto-Activated Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#container-build-callbacks">Container Build Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tips">Tips</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-configuration/index">Configuration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-configuration/xml">JSON/XML Configuration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-with-microsoft-configuration-4-0">Configuring With Microsoft Configuration (4.0+)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-with-application-configuration-legacy-pre-4-0">Configuring With Application Configuration (Legacy Pre-4.0)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-configuration/modules">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#advantages-of-modules">Advantages of Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#adapting-to-the-deployment-environment">Adapting to the Deployment Environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#common-use-cases-for-modules">Common Use Cases for Modules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-integration/index">Application Integration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/aspnet">ASP.NET</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/owin">OWIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/mvc">MVC</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/webapi">Web API</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/signalr">SignalR</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/webforms">Web Forms</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#document-integration/ria">RIA / Domain Services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/netcore">.NET Core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#quick-start">Quick Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#using-a-child-scope-as-a-root">Using a Child Scope as a Root</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/aspnetcore">ASP.NET Core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#quick-start">Quick Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuration-method-naming-conventions">Configuration Method Naming Conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dependency-injection-hooks">Dependency Injection Hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#differences-from-asp-net-classic">Differences From ASP.NET Classic</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#controllers-as-services">Controllers as Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#multitenant-support">Multitenant Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#using-a-child-scope-as-a-root">Using a Child Scope as a Root</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/blazor">Blazor</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/wcf">Windows Communication Foundation (WCF)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#clients">Clients</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#services">Services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/servicefabric">Service Fabric</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#quick-start">Quick Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#per-request-scopes">Per-Request Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/mef">Managed Extensibility Framework (MEF)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#consuming-mef-extensions-in-autofac">Consuming MEF Extensions in Autofac</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#providing-autofac-components-to-mef-extensions">Providing Autofac Components to MEF Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#using-metadata">Using Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#known-issues-gotchas">Known Issues / Gotchas</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/csl">Common Service Locator</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/entlib">Enterprise Library 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#using-the-configurator">Using the Configurator</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#specifying-a-registration-source">Specifying a Registration Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/nhibernate">NHibernate</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/moq">Moq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#getting-started">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-mocks">Configuring Mocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-specific-dependencies">Configuring Specific Dependencies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-integration/fakeiteasy">FakeItEasy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#getting-started">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-fakes">Configuring Fakes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#configuring-specific-dependencies">Configuring Specific Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#options-for-fakes">Options for Fakes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-best-practices/index">Best Practices and Recommendations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#always-resolve-dependencies-from-nested-lifetimes">Always Resolve Dependencies from Nested Lifetimes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#structure-configuration-with-modules">Structure Configuration with Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#use-as-t-in-delegate-registrations">Use As&lt;T&gt;() in Delegate Registrations</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#use-constructor-injection">Use Constructor Injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#use-relationship-types-not-service-locators">Use Relationship Types, Not Service Locators</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#register-components-from-least-to-most-specific">Register Components from Least-to-Most Specific</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#use-profilers-for-performance-checking">Use Profilers for Performance Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#register-once-resolve-many">Register Once, Resolve Many</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#register-frequently-used-components-with-lambdas">Register Frequently-Used Components with Lambdas</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#consider-a-container-as-immutable">Consider a Container as Immutable</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-advanced/index">Advanced Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/registration-sources">Registration Sources</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#any-concrete-type-not-already-registered-source">“Any Concrete Type Not Already Registered” Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#implementing-a-registration-source">Implementing a Registration Source</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/adapters-decorators">Adapters and Decorators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#adapters">Adapters</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#decorators">Decorators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/circular-dependencies">Circular Dependencies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#property-property-dependencies">Property/Property Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#constructor-property-dependencies">Constructor/Property Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#constructor-constructor-dependencies">Constructor/Constructor Dependencies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/metadata">Component Metadata / Attribute Metadata</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#adding-metadata-to-a-component-registration">Adding Metadata to a Component Registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#consuming-metadata">Consuming Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#strongly-typed-metadata">Strongly-Typed Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#interface-based-metadata">Interface-Based Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#attribute-based-metadata">Attribute-Based Metadata</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/keyed-services">Named and Keyed Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#named-services">Named Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#keyed-services">Keyed Services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/delegate-factories">Delegate Factories</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#creation-through-factories">Creation through Factories</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#the-payoff">The Payoff</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/owned-instances">Owned Instances</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#lifetime-and-scope">Lifetime and Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#relationship-types">Relationship Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/concurrency">Handling Concurrency</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#component-registration">Component Registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#service-resolution">Service Resolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#lifetime-events">Lifetime Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#thread-scoped-services">Thread Scoped Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#internals">Internals</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#thread-safe-types">Thread-Safe Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#deadlock-avoidance">Deadlock Avoidance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/multitenant">Multitenant Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#what-is-multitenancy">What Is Multitenancy?</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#general-principles">General Principles</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#asp-net-integration">ASP.NET Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#asp-net-core-integration">ASP.NET Core Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#wcf-integration">WCF Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tenant-id-strategy-tips">Tenant ID Strategy Tips</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/aggregate-services">Aggregate Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#required-references">Required References</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#getting-started">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#how-aggregate-services-are-resolved">How Aggregate Services are Resolved</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#properties">Properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#methods">Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#property-setters-and-void-methods">Property Setters and Void Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#how-it-works">How It Works</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#performance-considerations">Performance Considerations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/interceptors">Type Interceptors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#enabling-interception">Enabling Interception</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tips">Tips</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#known-issues">Known Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/cross-platform-apps">Cross-Platform and Native Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#xamarin">Xamarin</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#net-native">.NET Native</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-advanced/debugging">Debugging and Troubleshooting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#exceptions">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#symbols-and-sources">Symbols and Sources</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#support">Support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-examples/index">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-examples/repository">Examples Repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-examples/log4net">log4net Integration Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-faq/index">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/per-request-scope">How do I work with per-request lifetime scope?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#note-on-asp-net-core">Note on ASP.NET Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#registering-dependencies-as-per-request">Registering Dependencies as Per-Request</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#how-per-request-lifetime-works">How Per-Request Lifetime Works</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sharing-dependencies-across-apps-without-requests">Sharing Dependencies Across Apps Without Requests</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#testing-with-per-request-dependencies">Testing with Per-Request Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#troubleshooting-per-request-dependencies">Troubleshooting Per-Request Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#implementing-custom-per-request-semantics">Implementing Custom Per-Request Semantics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/select-by-context">How do I pick a service implementation by context?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-1-redesign-your-interfaces">Option 1: Redesign Your Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-2-change-the-registrations">Option 2: Change the Registrations</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-3-use-keyed-services">Option 3: Use Keyed Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-4-use-metadata">Option 4: Use Metadata</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/instance-per-session">How do I create a session-based lifetime scope in a web application?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#why-this-is-a-bad-idea">Why This is a Bad Idea</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#how-to-do-it">How to Do It</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/iis-restart">Why aren’t my assemblies getting scanned after IIS restart?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/conditional-registration">How do I conditionally register components?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#use-configuration">Use Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#use-modules">Use Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#lambda-registrations">Lambda Registrations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/share-across-app-types">How do I share component registrations across application types?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/isolate-autofac">How do I keep Autofac references isolated away from my app?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#application-startup">Application Startup</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#component-registrations">Component Registrations</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#service-resolution">Service Resolution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/pcl">Why are “old versions” of the framework (e.g., System.Core 2.0.5.0) referenced?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/binding-redirect">Why don’t all Autofac packages target the latest Autofac core?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/injecting-configured-parameters">How do I inject configuration, environment, or context parameters?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-1-register-using-a-lambda">Option 1: Register Using a Lambda</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#option-2-use-a-provider">Option 2: Use a Provider</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/injecting-global-parameters">How do I pass a parameter to a component in the middle of a resolve chain?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#why-this-is-a-design-problem">Why This is a Design Problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#solutions">Solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/container-analysis">Why isn’t container registration analysis built in?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-faq/xamarin-issues">Why are things in my Xamarin app misbehaving?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contributors">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-support">Getting Support</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#community-support">Community Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#commercial-support">Commercial Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filing-an-issue">Filing an Issue</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://autofac.org/apidoc/">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-owners">Owner’s Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ownership-is-about-trust">Ownership is About Trust</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-of-conduct">Code of Conduct</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#responsibilities">Responsibilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#api-design">API Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#bug-fixes-and-enhancements">Bug Fixes and Enhancements</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#performance-and-testing">Performance and Testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#issue-review">Issue Review</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#pull-request-review">Pull Request Review</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#support">Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#documentation-and-examples">Documentation and Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#compatibility">Compatibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#release-process">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#you-are-not-alone">You Are Not Alone</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">Autofac</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>Autofac 5.2.0 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/autofac/Documentation/blob/v5.2.0/docs/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-autofac-s-documentation">
<h1>Welcome to Autofac’s documentation!<a class="headerlink" href="#welcome-to-autofac-s-documentation" title="Permalink to this headline">¶</a></h1>
<img alt="_images/logo.png" src="_images/logo.png" />
<p>Autofac is an addictive <a class="reference external" href="http://martinfowler.com/articles/injection.html">IoC container</a> for .NET. It manages the dependencies between classes so that <strong>applications stay easy to change as they grow</strong> in size and complexity. This is achieved by treating regular .NET classes as <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a>.</p>
<div class="toctree-wrapper compound">
<span id="document-getting-started/index"></span><div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>The basic pattern for integrating Autofac into your application is:</p>
<ul class="simple">
<li>Structure your app with <em>inversion of control</em> (IoC) in mind.</li>
<li>Add Autofac references.</li>
<li>At application startup…</li>
<li>Create a <cite>ContainerBuilder</cite>.</li>
<li>Register components.</li>
<li>Build the container and store it for later use.</li>
<li>During application execution…</li>
<li>Create a lifetime scope from the container.</li>
<li>Use the lifetime scope to resolve instances of the components.</li>
</ul>
<p>This getting started guide walks you through these steps for a simple console application. Once you have the basics down, you can check out the rest of the wiki for more advanced usage and <a class="reference internal" href="index.html#document-integration/index"><span class="doc">integration information for WCF, ASP.NET, and other application types</span></a>.</p>
<div class="section" id="structuring-the-application">
<h3>Structuring the Application<a class="headerlink" href="#structuring-the-application" title="Permalink to this headline">¶</a></h3>
<p>The idea behind inversion of control is that, rather than tie the classes in your application together and let classes “new up” their dependencies, you switch it around so dependencies are instead passed in during class construction. <a class="reference external" href="http://martinfowler.com/articles/injection.html">Martin Fowler has an excellent article explaining dependency injection/inversion of control</a> if you want more on that.</p>
<p>For our sample app, we’ll define a class that writes the current date out. However, we don’t want it tied to the <code class="docutils literal notranslate"><span class="pre">Console</span></code> because we want to be able to test the class later or use it in a place where the console isn’t available.</p>
<p>We’ll also go as far as allowing the mechanism writing the date to be abstracted, so if we want to, later, swap in a version that writes <em>tomorrow’s</em> date, it’ll be a snap.</p>
<p>We’ll do something like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">DemoApp</span>
<span class="p">{</span>
  <span class="c1">// This interface helps decouple the concept of</span>
  <span class="c1">// &quot;writing output&quot; from the Console class. We</span>
  <span class="c1">// don&#39;t really &quot;care&quot; how the Write operation</span>
  <span class="c1">// happens, just that we can write.</span>
  <span class="k">public</span> <span class="k">interface</span> <span class="n">IOutput</span>
  <span class="p">{</span>
    <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">string</span> <span class="n">content</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// This implementation of the IOutput interface</span>
  <span class="c1">// is actually how we write to the Console. Technically</span>
  <span class="c1">// we could also implement IOutput to write to Debug</span>
  <span class="c1">// or Trace... or anywhere else.</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">ConsoleOutput</span> <span class="p">:</span> <span class="n">IOutput</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">string</span> <span class="n">content</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">content</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// This interface decouples the notion of writing</span>
  <span class="c1">// a date from the actual mechanism that performs</span>
  <span class="c1">// the writing. Like with IOutput, the process</span>
  <span class="c1">// is abstracted behind an interface.</span>
  <span class="k">public</span> <span class="k">interface</span> <span class="n">IDateWriter</span>
  <span class="p">{</span>
    <span class="k">void</span> <span class="nf">WriteDate</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// This TodayWriter is where it all comes together.</span>
  <span class="c1">// Notice it takes a constructor parameter of type</span>
  <span class="c1">// IOutput - that lets the writer write to anywhere</span>
  <span class="c1">// based on the implementation. Further, it implements</span>
  <span class="c1">// WriteDate such that today&#39;s date is written out;</span>
  <span class="c1">// you could have one that writes in a different format</span>
  <span class="c1">// or a different date.</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">TodayWriter</span> <span class="p">:</span> <span class="n">IDateWriter</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="n">IOutput</span> <span class="n">_output</span><span class="p">;</span>
    <span class="k">public</span> <span class="nf">TodayWriter</span><span class="p">(</span><span class="n">IOutput</span> <span class="n">output</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">_output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">WriteDate</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">_output</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Today</span><span class="p">.</span><span class="n">ToShortDateString</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that we have a reasonably structured (if contrived) set of dependencies, let’s get Autofac in the mix!</p>
</div>
<div class="section" id="add-autofac-references">
<h3>Add Autofac References<a class="headerlink" href="#add-autofac-references" title="Permalink to this headline">¶</a></h3>
<p>The first step is to add Autofac references to your project. For this example, we’re only using core Autofac. <a class="reference internal" href="index.html#document-integration/index"><span class="doc">Other application types may use additional Autofac integration libraries.</span></a>.</p>
<p>The easiest way to do this is through NuGet. The “Autofac” package has all the core functionality you’ll need.</p>
<img alt="_images/gsnuget.png" src="_images/gsnuget.png" />
</div>
<div class="section" id="application-startup">
<h3>Application Startup<a class="headerlink" href="#application-startup" title="Permalink to this headline">¶</a></h3>
<p>At application startup, you need to create a <cite>ContainerBuilder</cite> and register your <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a> with it. A <em>component</em> is an expression, .NET type, or other bit of code that exposes one or more <em>services</em> and can take in other <em>dependencies</em>.</p>
<p>In simple terms, think about a .NET type that implements an interface, like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SomeType</span> <span class="p">:</span> <span class="n">IService</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You could address that type in one of two ways:</p>
<ul class="simple">
<li>As the type itself, <code class="docutils literal notranslate"><span class="pre">SomeType</span></code></li>
<li>As the interface, an <code class="docutils literal notranslate"><span class="pre">IService</span></code></li>
</ul>
<p>In this case, the <em>component</em> is <code class="docutils literal notranslate"><span class="pre">SomeType</span></code> and the <em>services</em> it exposes are <code class="docutils literal notranslate"><span class="pre">SomeType</span></code> and <code class="docutils literal notranslate"><span class="pre">IService</span></code>.</p>
<p>In Autofac, you’d register that with a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> something like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create your builder.</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Usually you&#39;re only interested in exposing the type</span>
<span class="c1">// via its interface:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>

<span class="c1">// However, if you want BOTH services (not as common)</span>
<span class="c1">// you can say so:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;().</span><span class="n">AsSelf</span><span class="p">().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>For our sample app, we need to register all of our components (classes) and expose their services (interfaces) so things can get wired up nicely.</p>
<p>We also need to store the container so it can be used to resolve types later.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">DemoApp</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">IContainer</span> <span class="n">Container</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleOutput</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IOutput</span><span class="p">&gt;();</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TodayWriter</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDateWriter</span><span class="p">&gt;();</span>
      <span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

      <span class="c1">// The WriteDate method is where we&#39;ll make use</span>
      <span class="c1">// of our dependency injection. We&#39;ll define that</span>
      <span class="c1">// in a bit.</span>
      <span class="n">WriteDate</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we have a <em>container</em> with all of the <em>components</em> registered and they’re exposing the proper <em>services</em>. Let’s make use of it.</p>
</div>
<div class="section" id="application-execution">
<h3>Application Execution<a class="headerlink" href="#application-execution" title="Permalink to this headline">¶</a></h3>
<p>During application execution, you’ll need to make use of the components you registered. You do this by <em>resolving</em> them from a <em>lifetime scope</em>.</p>
<p>The container itself <em>is</em> a lifetime scope, and you can technically just resolve things right from the container. <strong>It is not recommended to resolve from the container directly</strong>, however.</p>
<p>When you resolve a component, depending on the <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">instance scope you define</span></a>, a new instance of the object gets created. (Resolving a component is roughly equivalent to calling “new” to instantiate a class. That’s really, really oversimplifying it, but from an analogy perspective it’s fine.) Some components may need to be disposed (like they implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>) - <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">Autofac can handle disposing those components for you</span></a> when the lifetime scope is disposed.</p>
<p>However, the container lives for the lifetime of your application. If you resolve a lot of stuff directly from the container, you may end up with a lot of things hanging around waiting to be disposed. That’s not good (and you may see a “memory leak” doing that).</p>
<p>Instead, create a <em>child lifetime scope</em> from the container and resolve from that. When you’re done resolving components, dispose of the child scope and everything gets cleaned up for you.</p>
<p>(When you’re working with the <a class="reference internal" href="index.html#document-integration/index"><span class="doc">Autofac integration libraries</span></a>, this child scope creation is largely done for you so you don’t have to think about it.)</p>
<p>For our sample app, we’ll implement the “WriteDate” method to get the writer from a scope and dispose of the scope when we’re done.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nn">DemoApp</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">IContainer</span> <span class="n">Container</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// ...the stuff you saw earlier...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">WriteDate</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="c1">// Create the scope, resolve your IDateWriter,</span>
      <span class="c1">// use it, then dispose of the scope.</span>
      <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="kt">var</span> <span class="n">writer</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDateWriter</span><span class="p">&gt;();</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">WriteDate</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now when you run your program…</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">WriteDate</span></code> method creates a lifetime scope from which it can resolve dependencies. It does this to avoid any memory leaks - if <code class="docutils literal notranslate"><span class="pre">IDateWriter</span></code> or its dependencies are disposable, they will be automatically disposed when the scope is disposed.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">WriteDate</span></code> method manually resolves an <code class="docutils literal notranslate"><span class="pre">IDateWriter</span></code> from the lifetime scope. (This is “service location.”) Internally…<ul>
<li>Autofac sees that <code class="docutils literal notranslate"><span class="pre">IDateWriter</span></code> maps to <code class="docutils literal notranslate"><span class="pre">TodayWriter</span></code> so starts creating a <code class="docutils literal notranslate"><span class="pre">TodayWriter</span></code>.</li>
<li>Autofac sees that the <code class="docutils literal notranslate"><span class="pre">TodayWriter</span></code> needs an <code class="docutils literal notranslate"><span class="pre">IOutput</span></code> in its constructor. (This is “constructor injection.”)</li>
<li>Autofac sees that <code class="docutils literal notranslate"><span class="pre">IOutput</span></code> maps to <code class="docutils literal notranslate"><span class="pre">ConsoleOutput</span></code> so creates a new <code class="docutils literal notranslate"><span class="pre">ConsoleOutput</span></code> instance.</li>
<li>Autofac uses the new <code class="docutils literal notranslate"><span class="pre">ConsoleOutput</span></code> instance to finish constructing the <code class="docutils literal notranslate"><span class="pre">TodayWriter</span></code>.</li>
<li>Autofac returns the fully-constructed <code class="docutils literal notranslate"><span class="pre">TodayWriter</span></code> for <code class="docutils literal notranslate"><span class="pre">WriteDate</span></code> to consume.</li>
</ul>
</li>
<li>The call to <code class="docutils literal notranslate"><span class="pre">writer.WriteDate()</span></code> goes to the brand new <code class="docutils literal notranslate"><span class="pre">TodayWriter.WriteDate()</span></code> since that’s what was resolved.</li>
<li>The Autofac lifetime scope is disposed. Any disposable items that were resolved from that lifetime scope are also disposed.</li>
</ul>
<p>Later, if you want your application to write a different date, you could implement a different <code class="docutils literal notranslate"><span class="pre">IDateWriter</span></code> and then change the registration at app startup. You don’t have to change any other classes. Yay, inversion of control!</p>
<p><strong>Note: generally speaking, service location is largely considered an anti-pattern</strong> <a class="reference external" href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx">(see article)</a>. That is, manually creating scopes everywhere and sprinkling use of the container through your code is not necessarily the best way to go. Using the <a class="reference internal" href="index.html#document-integration/index"><span class="doc">Autofac integration libraries</span></a> you usually won’t have to do what we did in the sample app above. Instead, things get resolved from a central, “top level” location in the application and manual resolution is rare. Of course, how you design your app is up to you.</p>
</div>
<div class="section" id="going-further">
<h3>Going Further<a class="headerlink" href="#going-further" title="Permalink to this headline">¶</a></h3>
<p>The sample app gives you an idea of how to use Autofac, but there’s a lot more you can do.</p>
<ul class="simple">
<li>Check out the list of <a class="reference internal" href="index.html#document-integration/index"><span class="doc">integration libraries</span></a> to see how to integrate Autofac with your application.</li>
<li>Learn about the <a class="reference internal" href="index.html#document-register/index"><span class="doc">ways to register components</span></a> that add flexibility.</li>
<li>Learn about <a class="reference internal" href="index.html#document-configuration/index"><span class="doc">Autofac configuration options</span></a> that allow you to better manage your component registrations.</li>
</ul>
</div>
<div class="section" id="need-help">
<h3>Need Help?<a class="headerlink" href="#need-help" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>You can <a class="reference external" href="https://stackoverflow.com/questions/tagged/autofac">ask questions on StackOverflow</a>.</li>
<li>You can <a class="reference external" href="https://groups.google.com/forum/#forum/autofac">participate in the Autofac Google Group</a>.</li>
<li>There’s an introductory <a class="reference external" href="http://www.codeproject.com/KB/architecture/di-with-autofac.aspx">Autofac tutorial</a> on CodeProject.</li>
<li>We have <a class="reference internal" href="index.html#document-advanced/debugging"><span class="doc">advanced debugging tips</span></a> if you want to dive deep.</li>
</ul>
</div>
<div class="section" id="building-from-source">
<h3>Building from Source<a class="headerlink" href="#building-from-source" title="Permalink to this headline">¶</a></h3>
<p>The source code along with Visual Studio project files is available <a class="reference external" href="https://github.com/autofac/Autofac">on GitHub</a>. Build instructions and details on contributing can be found in the <a class="reference internal" href="index.html#document-contributors"><span class="doc">Contributor Guide</span></a>.</p>
</div>
</div>
<span id="document-whats-new/index"></span><div class="section" id="what-s-new">
<h2>What’s New<a class="headerlink" href="#what-s-new" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-whats-new/releasenotes"></span><div class="section" id="release-notes">
<h3>Release Notes<a class="headerlink" href="#release-notes" title="Permalink to this headline">¶</a></h3>
<p>Release notes for Autofac and integration packages are all stored in the GitHub releases for the respective package.</p>
<ul class="simple">
<li>Core components</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac/releases">Autofac</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Configuration/releases">Autofac.Configuration</a></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Integration libraries</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extensions.DependencyInjection/releases">.NET Core / ASP.NET Core</a></li>
<li>ASP.NET</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac.Web/releases">Web Forms</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Mvc/releases">MVC</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.WebApi/releases">Web API</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.SignalR/releases">SignalR</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.DomainServices/releases">RIA/Domain Services</a></li>
<li>OWIN<ul>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Owin/releases">OWIN Core</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.WebApi.Owin/releases">Web API</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Mvc.Owin/releases">MVC</a></li>
</ul>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac.Wcf/releases">WCF</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Mef/releases">MEF</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.ServiceFabric/releases">Service Fabric</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.CommonServiceLocator/releases">Common Service Locator</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac/wiki/Enterprise-Library-Configurator-Release-Notes">Enterprise Library 5 Configurator</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.NHibernate/releases">NHibernate</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.Moq/releases">Moq</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.FakeItEasy/releases">FakeItEasy</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.MvvmCross/releases">MvvmCross</a></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Multitenancy</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac.Multitenant/releases">General Applications</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Multitenant.Wcf/releases">WCF</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.AspNetCore.Multitenant/releases">ASP.NET Core</a></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Extended features</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.AggregateService/releases">Aggregate Services</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.AttributeMetadata/releases">Attribute Metadata</a></li>
<li><a class="reference external" href="https://github.com/autofac/Autofac.Extras.DynamicProxy/releases">Dynamic Proxy / Interception</a></li>
</ul>
</div></blockquote>
</div>
<span id="document-whats-new/upgradingfrom3to4"></span><div class="section" id="upgrading-from-autofac-3-x-to-4-x">
<h3>Upgrading from Autofac 3.x to 4.x<a class="headerlink" href="#upgrading-from-autofac-3-x-to-4-x" title="Permalink to this headline">¶</a></h3>
<p>The Autofac 4.x release added .NET Core support to core Autofac as well as several of the integration packages.</p>
<p>Generally speaking, the public API held stable during the upgrade but internals changed because reflection and a few other things are done just slightly differently in .NET Core.</p>
<p>The following is a list of known differences between the 3.x and 4.x versions of Autofac including changes to integration/extras packages:</p>
<ul class="simple">
<li>The following NuGet packages were renamed:<ul>
<li>Autofac.Extras.Attributed =&gt; Autofac.Extras.AttributeMetadata</li>
<li>Autofac.Extras.Multitenant =&gt; Autofac.Multitenant</li>
<li>Autofac.Extras.Multitenant.Wcf =&gt; Autofac.Multitenant.Wcf</li>
<li>Autofac.Extras.DynamicProxy2 =&gt; Autofac.Extras.DynamicProxy</li>
</ul>
</li>
<li>Minimum target frameworks for all packages has been increased to .NET 4.5 and the .NET 4.5 security model is being used (e.g., no more <code class="docutils literal notranslate"><span class="pre">AllowPartiallyTrustedCallersAttribute</span></code>).</li>
<li>The Autofac.Configuration package now uses Microsoft.Extensions.Configuration formatted configuration files instead of the old XML format. <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">You can read more about this on the configuration page.</span></a></li>
<li>The following integration packages have been moved to maintenance mode (fixes only, no new features, no active work):<ul>
<li>Autofac.Extras.NHibernate</li>
<li>Autofac.Extras.EnterpriseLibraryConfigurator</li>
<li>Autofac.Integration.DomainServices</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<span id="document-register/index"></span><div class="section" id="registering-components">
<h2>Registering Components<a class="headerlink" href="#registering-components" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-register/registration"></span><div class="section" id="registration-concepts">
<h3>Registration Concepts<a class="headerlink" href="#registration-concepts" title="Permalink to this headline">¶</a></h3>
<p>You register <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a> with Autofac by creating a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> and informing the builder which <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a> expose which <a class="reference internal" href="index.html#document-glossary"><span class="doc">services</span></a>.</p>
<p><strong>Components</strong> can be created via <strong>reflection</strong> (by registering a specific .NET type or open generic); by providing a ready-made <strong>instance</strong> (an instance of an object you created); or via lambda <strong>expression</strong> (an anonymous function that executes to instantiate your object). <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> has a family of <code class="docutils literal notranslate"><span class="pre">Register()</span></code> methods that allow you to set these up.</p>
<p>Each component exposes one or more <strong>services</strong> that are wired up using the <code class="docutils literal notranslate"><span class="pre">As()</span></code> methods on <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the builder with which components/services are registered.</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register types that expose interfaces...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>

<span class="c1">// Register instances of objects you create...</span>
<span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">output</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TextWriter</span><span class="p">&gt;();</span>

<span class="c1">// Register expressions that execute to create objects...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ConfigReader</span><span class="p">(</span><span class="s">&quot;mysection&quot;</span><span class="p">)).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;();</span>

<span class="c1">// Build the container to finalize registrations</span>
<span class="c1">// and prepare for object resolution.</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// Now you can resolve services using Autofac. For example,</span>
<span class="c1">// this line will execute the lambda expression registered</span>
<span class="c1">// to the IConfigReader service.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="reflection-components">
<span id="register-registration-reflection-components"></span><h4>Reflection Components<a class="headerlink" href="#reflection-components" title="Permalink to this headline">¶</a></h4>
<div class="section" id="register-by-type">
<h5>Register by Type<a class="headerlink" href="#register-by-type" title="Permalink to this headline">¶</a></h5>
<p>Components generated by reflection are typically registered by type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ConfigReader</span><span class="p">));</span>
</pre></div>
</div>
<p>When using reflection-based components, <strong>Autofac automatically uses the constructor for your class with the most parameters that are able to be obtained from the container</strong>.</p>
<p>For example, say you have a class with three constructors like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MyComponent</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">MyComponent</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">MyComponent</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">MyComponent</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">,</span> <span class="n">IConfigReader</span> <span class="n">reader</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now say you register components and services in your container like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyComponent</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">MyComponent</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you resolve your component, Autofac will see that you have an <code class="docutils literal notranslate"><span class="pre">ILogger</span></code> registered, but you don’t have an <code class="docutils literal notranslate"><span class="pre">IConfigReader</span></code> registered. In that case, the second constructor will be chosen since that’s the one with the most parameters that can be found in the container.</p>
<p><strong>An important note on reflection-based components:</strong> Any component type you register via <code class="docutils literal notranslate"><span class="pre">RegisterType</span></code> must be a concrete type. While components can expose abstract classes or interfaces as <a class="reference internal" href="index.html#document-glossary"><span class="doc">services</span></a>, you can’t register an abstract/interface component. It makes sense if you think about it: behind the scenes, Autofac is creating an instance of the thing you’re registering. You can’t “new up” an abstract class or an interface. You have to have an implementation, right?</p>
</div>
<div class="section" id="specifying-a-constructor">
<h5>Specifying a Constructor<a class="headerlink" href="#specifying-a-constructor" title="Permalink to this headline">¶</a></h5>
<p><strong>You can manually choose a particular constructor</strong> to use and override the automatic choice by registering your component with the <code class="docutils literal notranslate"><span class="pre">UsingConstructor</span></code> method and a list of types representing the parameter types in the constructor:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyComponent</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">UsingConstructor</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ILogger</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IConfigReader</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that you will still need to have the requisite parameters available at resolution time or there will be an error when you try to resolve the object. You can <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">pass parameters at registration time</span></a> or you can <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">pass them at resolve time</span></a>.</p>
</div>
</div>
<div class="section" id="instance-components">
<h4>Instance Components<a class="headerlink" href="#instance-components" title="Permalink to this headline">¶</a></h4>
<p>In some cases, you may want to pre-generate an instance of an object and add it to the container for use by registered components. You can do this using the <code class="docutils literal notranslate"><span class="pre">RegisterInstance</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">output</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TextWriter</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Something to consider when you do this is that Autofac <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">automatically handles disposal of registered components</span></a> and you may want to control the lifetime yourself rather than having Autofac call <code class="docutils literal notranslate"><span class="pre">Dispose</span></code> on your object for you. In that case, you need to register the instance with the <code class="docutils literal notranslate"><span class="pre">ExternallyOwned</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TextWriter</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ExternallyOwned</span><span class="p">();</span>
</pre></div>
</div>
<p>Registering provided instances is also handy when integrating Autofac into an existing application where a singleton instance already exists and needs to be used by components in the container. Rather than tying those components directly to the singleton, it can be registered with the container as an instance:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">MySingleton</span><span class="p">.</span><span class="n">Instance</span><span class="p">).</span><span class="n">ExternallyOwned</span><span class="p">();</span>
</pre></div>
</div>
<p>This ensures that the static singleton can eventually be eliminated and replaced with a container-managed one.</p>
<p>The default service exposed by an instance is the concrete type of the instance. See “Services vs. Components,” below.</p>
</div>
<div class="section" id="lambda-expression-components">
<span id="register-registration-lambda-expression-components"></span><h4>Lambda Expression Components<a class="headerlink" href="#lambda-expression-components" title="Permalink to this headline">¶</a></h4>
<p>Reflection is a pretty good default choice for component creation. Things get messy, though, when component creation logic goes beyond a simple constructor call.</p>
<p>Autofac can accept a delegate or lambda expression to be used as a component creator:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;()));</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> provided to the expression is the <em>component context</em> (an <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> object) in which the component is being created. You can use this to resolve other values from the container to assist in creating your component. <strong>It is important to use this rather than a closure to access the container</strong> so that <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">deterministic disposal</span></a> and nested containers can be supported correctly.</p>
<p>Additional dependencies can be satisfied using this context parameter - in the example, <code class="docutils literal notranslate"><span class="pre">A</span></code> requires a constructor parameter of type <code class="docutils literal notranslate"><span class="pre">B</span></code> that may have additional dependencies.</p>
<p>The default service provided by an expression-created component is the inferred return type of the expression.</p>
<p>Below are some examples of requirements met poorly by reflective component creation but nicely addressed by lambda expressions.</p>
<div class="section" id="complex-parameters">
<h5>Complex Parameters<a class="headerlink" href="#complex-parameters" title="Permalink to this headline">¶</a></h5>
<p>Constructor parameters can’t always be declared with simple constant values. Rather than puzzling over how to construct a value of a certain type using an XML configuration syntax, use code:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">UserSession</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">AddMinutes</span><span class="p">(</span><span class="m">25</span><span class="p">)));</span>
</pre></div>
</div>
<p>(Of course, session expiry is probably something you’d want to specify in a configuration file - but you get the gist ;))</p>
</div>
<div class="section" id="property-injection">
<h5>Property Injection<a class="headerlink" href="#property-injection" title="Permalink to this headline">¶</a></h5>
<p>While Autofac offers <a class="reference internal" href="index.html#document-register/prop-method-injection"><span class="doc">a more first-class approach to property injection</span></a>, you can use expressions and property initializers to populate properties as well:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">(){</span> <span class="n">MyB</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">ResolveOptional</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;()</span> <span class="p">});</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ResolveOptional</span></code> method will try to resolve the value but won’t throw an exception if the service isn’t registered. (You will still get an exception if the service is registered but can’t properly be resolved.) This is one of the options for <a class="reference internal" href="index.html#document-resolve/index"><span class="doc">resolving a service</span></a>.</p>
<p><strong>Property injection is not recommended in the majority of cases.</strong> Alternatives like <a class="reference external" href="http://en.wikipedia.org/wiki/Null_Object_pattern">the Null Object pattern</a>, overloaded constructors or constructor parameter default values make it possible to create cleaner, “immutable” components with optional dependencies using constructor injection.</p>
</div>
<div class="section" id="selection-of-an-implementation-by-parameter-value">
<h5>Selection of an Implementation by Parameter Value<a class="headerlink" href="#selection-of-an-implementation-by-parameter-value" title="Permalink to this headline">¶</a></h5>
<p>One of the great benefits of isolating component creation is that the concrete type can be varied. This is often done at runtime, not just configuration time:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">CreditCard</span><span class="p">&gt;(</span>
  <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">accountId</span> <span class="p">=</span> <span class="n">p</span><span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">&quot;accountId&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">accountId</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;9&quot;</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">GoldCard</span><span class="p">(</span><span class="n">accountId</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StandardCard</span><span class="p">(</span><span class="n">accountId</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> is implemented by two classes, <code class="docutils literal notranslate"><span class="pre">GoldCard</span></code> and <code class="docutils literal notranslate"><span class="pre">StandardCard</span></code> - which class is instantiated depends on the account ID provided at runtime.</p>
<p><a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">Parameters are provided to the creation function</span></a> through an optional second parameter named <code class="docutils literal notranslate"><span class="pre">p</span></code> in this example.</p>
<p>Using this registration would look like:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">card</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">CreditCard</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">NamedParameter</span><span class="p">(</span><span class="s">&quot;accountId&quot;</span><span class="p">,</span> <span class="s">&quot;12345&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>A cleaner, type-safe syntax can be achieved if a delegate to create <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instances is declared and <a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">a delegate factory</span></a> is used.</p>
</div>
</div>
<div class="section" id="open-generic-components">
<h4>Open Generic Components<a class="headerlink" href="#open-generic-components" title="Permalink to this headline">¶</a></h4>
<p>Autofac supports open generic types. Use the <code class="docutils literal notranslate"><span class="pre">RegisterGeneric()</span></code> builder method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">NHibernateRepository</span><span class="p">&lt;&gt;))</span>
       <span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;&gt;))</span>
       <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
</pre></div>
</div>
<p>When a matching service type is requested from the container, Autofac will map this to an equivalent closed version of the implementation type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Autofac will return an NHibernateRepository&lt;Task&gt;</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IRepository</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
<p>Registration of a specialized service type (e.g. <code class="docutils literal notranslate"><span class="pre">IRepository&lt;Person&gt;</span></code>) will override the open generic version.</p>
</div>
<div class="section" id="services-vs-components">
<h4>Services vs. Components<a class="headerlink" href="#services-vs-components" title="Permalink to this headline">¶</a></h4>
<p>When you register <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a>, you have to tell Autofac which <a class="reference internal" href="index.html#document-glossary"><span class="doc">services</span></a> that component exposes. By default, most registrations will just expose themselves as the type registered:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This exposes the service &quot;CallLogger&quot;</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Components can only be <a class="reference internal" href="index.html#document-resolve/index"><span class="doc">resolved</span></a> by the services they expose. In this simple example it means:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This will work because the component</span>
<span class="c1">// exposes the type by default:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;();</span>

<span class="c1">// This will NOT work because we didn&#39;t</span>
<span class="c1">// tell the registration to also expose</span>
<span class="c1">// the ILogger interface on CallLogger:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>You can expose a component with any number of services you like:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICallInterceptor</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Once you expose a service, you can resolve the component based on that service. Note, however, that once you expose a component as a specific service, the default service (the component type) is overridden:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// These will both work because we exposed</span>
<span class="c1">// the appropriate services in the registration:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ICallInterceptor</span><span class="p">&gt;();</span>

<span class="c1">// This WON&#39;T WORK anymore because we specified</span>
<span class="c1">// service overrides on the component:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>If you want to expose a component as a set of services as well as using the default service, use the <code class="docutils literal notranslate"><span class="pre">AsSelf</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICallInterceptor</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Now all of these will work:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// These will all work because we exposed</span>
<span class="c1">// the appropriate services in the registration:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ICallInterceptor</span><span class="p">&gt;();</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">CallLogger</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="default-registrations">
<h4>Default Registrations<a class="headerlink" href="#default-registrations" title="Permalink to this headline">¶</a></h4>
<p>If more than one component exposes the same service, <strong>Autofac will use the last registered component as the default provider of that service</strong>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">FileLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>In this scenario, <code class="docutils literal notranslate"><span class="pre">FileLogger</span></code> will be the default for <code class="docutils literal notranslate"><span class="pre">ILogger</span></code> because it was the last one registered.</p>
<p>To override this behavior, use the <code class="docutils literal notranslate"><span class="pre">PreserveExistingDefaults()</span></code> modifier:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">FileLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;().</span><span class="n">PreserveExistingDefaults</span><span class="p">();</span>
</pre></div>
</div>
<p>In this scenario, <code class="docutils literal notranslate"><span class="pre">ConsoleLogger</span></code> will be the default for <code class="docutils literal notranslate"><span class="pre">ILogger</span></code> because the later registration for <code class="docutils literal notranslate"><span class="pre">FileLogger</span></code> used <code class="docutils literal notranslate"><span class="pre">PreserveExistingDefaults()</span></code>.</p>
</div>
<div class="section" id="conditional-registration">
<h4>Conditional Registration<a class="headerlink" href="#conditional-registration" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Conditional registration was introduced in Autofac <strong>4.4.0</strong></p>
</div>
<p>In most cases, overriding registrations as noted in the section above, “Default Registrations,” is enough to get the right component resolved at runtime. Ensuring things get registered in the right order; using <code class="docutils literal notranslate"><span class="pre">PreserveExistingDefaults()</span></code>; and taking advantage of lambda/delegate registrations for more complex conditions and behavior can get you pretty far.</p>
<p>There can be a few scenarios where this may not be the way you want to go:</p>
<ul class="simple">
<li>You don’t want the component present in the system if something else is handling the functionality. For example, if you resolve an <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;T&gt;</span></code> of a service, all of the registered components implementing that service will be returned, whether or not you’ve used <code class="docutils literal notranslate"><span class="pre">PreserveExistingDefaults()</span></code>. Usually this is fine, but there are some edge cases where you may not want that.</li>
<li>You only want to register the component if some other component <em>isn’t</em> registered; or only if some other component <em>is</em> registered. You can’t resolve things out of a container that you’re building, and you shouldn’t update a container that’s already built. Being able to conditionally register a component based on other registrations can be helpful.</li>
</ul>
<p>There are two registration extensions that can help in these cases:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">OnlyIf()</span></code> - Provide a lambda that uses an <code class="docutils literal notranslate"><span class="pre">IComponentRegistryBuilder</span></code> to determine if a registration should happen.</li>
<li><code class="docutils literal notranslate"><span class="pre">IfNotRegistered()</span></code> - Shortcut to stop a registration from happening if some other service is already registered.</li>
</ul>
<p>These extensions run at the time of <code class="docutils literal notranslate"><span class="pre">ContainerBuilder.Build()</span></code> and will execute in the order of the actual component registrations. Here are some examples showing how they work:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Only ServiceA will be registered.</span>
<span class="c1">// Note the IfNotRegistered takes the SERVICE TYPE to</span>
<span class="c1">// check for (the As&lt;T&gt;), NOT the COMPONENT TYPE</span>
<span class="c1">// (the RegisterType&lt;T&gt;).</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ServiceA</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ServiceB</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">IfNotRegistered</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IService</span><span class="p">));</span>

<span class="c1">// HandlerA WILL be registered - it&#39;s running</span>
<span class="c1">// BEFORE HandlerB has a chance to be registered</span>
<span class="c1">// so the IfNotRegistered check won&#39;t find it.</span>
<span class="c1">//</span>
<span class="c1">// HandlerC will NOT be registered because it</span>
<span class="c1">// runs AFTER HandlerB. Note it can check for</span>
<span class="c1">// the type &quot;HandlerB&quot; because HandlerB registered</span>
<span class="c1">// AsSelf() not just As&lt;IHandler&gt;(). Again,</span>
<span class="c1">// IfNotRegistered can only check for &quot;As&quot;</span>
<span class="c1">// types.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HandlerA</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">IfNotRegistered</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">HandlerB</span><span class="p">));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HandlerB</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HandlerC</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">IfNotRegistered</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">HandlerB</span><span class="p">));</span>

<span class="c1">// Manager will be registered because both an IService</span>
<span class="c1">// and HandlerB are registered. The OnlyIf predicate</span>
<span class="c1">// can allow a lot more flexibility.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Manager</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IManager</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">OnlyIf</span><span class="p">(</span><span class="n">reg</span> <span class="p">=&gt;</span>
         <span class="n">reg</span><span class="p">.</span><span class="n">IsRegistered</span><span class="p">(</span><span class="k">new</span> <span class="n">TypedService</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IService</span><span class="p">)))</span> <span class="p">&amp;&amp;</span>
         <span class="n">reg</span><span class="p">.</span><span class="n">IsRegistered</span><span class="p">(</span><span class="k">new</span> <span class="n">TypedService</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">HandlerB</span><span class="p">))));</span>

<span class="c1">// This is when the conditionals actually run. Again,</span>
<span class="c1">// they run in the order the registrations were added</span>
<span class="c1">// to the ContainerBuilder.</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration-of-registrations">
<h4>Configuration of Registrations<a class="headerlink" href="#configuration-of-registrations" title="Permalink to this headline">¶</a></h4>
<p>You can <a class="reference internal" href="index.html#document-configuration/index"><span class="doc">use XML or programmatic configuration (“modules”)</span></a> to provide groups of registrations together or change registrations at runtime. You can also use <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">use Autofac modules</span></a> for some dynamic registration generation or conditional registration logic.</p>
</div>
<div class="section" id="dynamically-provided-registrations">
<h4>Dynamically-Provided Registrations<a class="headerlink" href="#dynamically-provided-registrations" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> are the simplest way to introduce dynamic registration logic or simple cross-cutting features. For example, you can use a module to <a class="reference internal" href="index.html#document-examples/log4net"><span class="doc">dynamically attach a log4net logger instance to a service being resolved</span></a>.</p>
<p>If you find that you need even more dynamic behavior, such as adding support for a new <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship type</span></a>, you might want to <a class="reference internal" href="index.html#document-advanced/registration-sources"><span class="doc">check out the registration sources section in the advanced concepts area</span></a>.</p>
</div>
</div>
<span id="document-register/parameters"></span><div class="section" id="passing-parameters-to-register">
<h3>Passing Parameters to Register<a class="headerlink" href="#passing-parameters-to-register" title="Permalink to this headline">¶</a></h3>
<p>When you <a class="reference internal" href="index.html#document-register/registration"><span class="doc">register components</span></a> you have the ability to provide a set of parameters that can be used during the <a class="reference internal" href="index.html#document-resolve/index"><span class="doc">resolution of services</span></a> based on that component. (If you’d rather provide the parameters at resolution time, <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">you can do that instead</span></a>.)</p>
<div class="section" id="available-parameter-types">
<h4>Available Parameter Types<a class="headerlink" href="#available-parameter-types" title="Permalink to this headline">¶</a></h4>
<p>Autofac offers several different parameter matching strategies:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NamedParameter</span></code> - match target parameters by name</li>
<li><code class="docutils literal notranslate"><span class="pre">TypedParameter</span></code> - match target parameters by type (exact type match required)</li>
<li><code class="docutils literal notranslate"><span class="pre">ResolvedParameter</span></code> - flexible parameter matching</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">NamedParameter</span></code> and <code class="docutils literal notranslate"><span class="pre">TypedParameter</span></code> can supply constant values only.</p>
<p><code class="docutils literal notranslate"><span class="pre">ResolvedParameter</span></code> can be used as a way to supply values dynamically retrieved from the container, e.g. by resolving a service by name.</p>
</div>
<div class="section" id="parameters-with-reflection-components">
<h4>Parameters with Reflection Components<a class="headerlink" href="#parameters-with-reflection-components" title="Permalink to this headline">¶</a></h4>
<p>When you register a reflection-based component, the constructor of the type may require a parameter that can’t be resolved from the container. You can use a parameter on the registration to provide that value.</p>
<p>Say you have a configuration reader that needs a configuration section name passed in:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ConfigReader</span> <span class="p">:</span> <span class="n">IConfigReader</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ConfigReader</span><span class="p">(</span><span class="kt">string</span> <span class="n">configSectionName</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Store config section name</span>
  <span class="p">}</span>

  <span class="c1">// ...read configuration based on the section name.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You could use a lambda expression component for that:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ConfigReader</span><span class="p">(</span><span class="s">&quot;sectionName&quot;</span><span class="p">)).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Or you could pass a parameter to a reflection component registration:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Using a NAMED parameter:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">,</span> <span class="s">&quot;sectionName&quot;</span><span class="p">);</span>

<span class="c1">// Using a TYPED parameter:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span><span class="k">new</span> <span class="n">TypedParameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">),</span> <span class="s">&quot;sectionName&quot;</span><span class="p">));</span>

<span class="c1">// Using a RESOLVED parameter:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
         <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">pi</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&quot;configSectionName&quot;</span><span class="p">,</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">&quot;sectionName&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="parameters-with-lambda-expression-components">
<h4>Parameters with Lambda Expression Components<a class="headerlink" href="#parameters-with-lambda-expression-components" title="Permalink to this headline">¶</a></h4>
<p>With lambda expression component registrations, rather than passing the parameter value <em>at registration time</em> you enable the ability to pass the value <em>at service resolution time</em>. (<a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">Read more about resolving with parameters.</span></a>)</p>
<p>In the component registration expression, you can make use of the incoming parameters by changing the delegate signature you use for registration. Instead of just taking in an <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> parameter, take in an <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> and an <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;Parameter&gt;</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use TWO parameters to the registration delegate:</span>
<span class="c1">// c = The current IComponentContext to dynamically resolve dependencies</span>
<span class="c1">// p = An IEnumerable&lt;Parameter&gt; with the incoming parameter set</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">=&gt;</span>
                 <span class="k">new</span> <span class="nf">ConfigReader</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">)))</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>When <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">resolving with parameters</span></a>, your lambda will use the parameters passed in:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">NamedParameter</span><span class="p">(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">,</span> <span class="s">&quot;sectionName&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<span id="document-register/prop-method-injection"></span><div class="section" id="property-and-method-injection">
<h3>Property and Method Injection<a class="headerlink" href="#property-and-method-injection" title="Permalink to this headline">¶</a></h3>
<p>While constructor parameter injection is the preferred method of passing values to a component being constructed, you can also use property or method injection to provide values.</p>
<p><strong>Property injection</strong> uses writeable properties rather than constructor parameters to perform injection. <strong>Method injection</strong> sets dependencies by calling a method.</p>
<div class="section" id="property-injection">
<h4>Property Injection<a class="headerlink" href="#property-injection" title="Permalink to this headline">¶</a></h4>
<p>If the component is a <a class="reference internal" href="index.html#register-registration-lambda-expression-components"><span class="std std-ref">lambda expression component</span></a>, use an object initializer:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span> <span class="p">{</span> <span class="n">B</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;()</span> <span class="p">});</span>
</pre></div>
</div>
<p>To support <a class="reference internal" href="index.html#document-advanced/circular-dependencies"><span class="doc">circular dependencies</span></a>, use an <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">activated event handler</span></a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">()).</span><span class="n">OnActivated</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">B</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Context</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;());</span>
</pre></div>
</div>
<p>If the component is a <a class="reference internal" href="index.html#register-registration-reflection-components"><span class="std std-ref">reflection component</span></a>, use the <code class="docutils literal notranslate"><span class="pre">PropertiesAutowired()</span></code> modifier to inject properties:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;().</span><span class="n">PropertiesAutowired</span><span class="p">();</span>
</pre></div>
</div>
<p>If you have one specific property and value to wire up, you can use the <code class="docutils literal notranslate"><span class="pre">WithProperty()</span></code> modifier:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;().</span><span class="n">WithProperty</span><span class="p">(</span><span class="s">&quot;PropertyName&quot;</span><span class="p">,</span> <span class="n">propertyValue</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="method-injection">
<h4>Method Injection<a class="headerlink" href="#method-injection" title="Permalink to this headline">¶</a></h4>
<p>The simplest way to call a method to set a value on a component is to use a <a class="reference internal" href="index.html#register-registration-lambda-expression-components"><span class="std std-ref">lambda expression component</span></a> and handle the method call right in the activator:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyObjectType</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">dep</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">TheDependency</span><span class="p">&gt;();</span>
  <span class="n">result</span><span class="p">.</span><span class="n">SetTheDependency</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>If you can’t use a registration lambda, you can add an <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">activating event handler</span></a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span>
  <span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">MyObjectType</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">OnActivating</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">dep</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Context</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">TheDependency</span><span class="p">&gt;();</span>
    <span class="n">e</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">SetTheDependency</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
  <span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<span id="document-register/scanning"></span><div class="section" id="assembly-scanning">
<h3>Assembly Scanning<a class="headerlink" href="#assembly-scanning" title="Permalink to this headline">¶</a></h3>
<p>Autofac can use conventions to find and register components in assemblies. You can scan and register individual types or you can scan specifically for <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a>.</p>
<div class="section" id="scanning-for-types">
<h4>Scanning for Types<a class="headerlink" href="#scanning-for-types" title="Permalink to this headline">¶</a></h4>
<p>Otherwise known as convention-driven registration or scanning, Autofac can register a set of types from an assembly according to user-specified rules:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">dataAccess</span> <span class="p">=</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">dataAccess</span><span class="p">)</span>
       <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Repository&quot;</span><span class="p">))</span>
       <span class="p">.</span><span class="n">AsImplementedInterfaces</span><span class="p">();</span>
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyTypes()</span></code> call will apply one set of rules only - multiple invocations of <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyTypes()</span></code> are necessary if there are multiple different sets of components to register.</p>
<div class="section" id="filtering-types">
<h5>Filtering Types<a class="headerlink" href="#filtering-types" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">RegisterAssemblyTypes()</span></code> accepts a parameter array of one or more assemblies. By default, <strong>all concrete classes in the assembly will be registered.</strong> This includes internal and nested private classes. You can filter the set of types to register using some provided LINQ-style predicates.</p>
<p>In 4.8.0 a <code class="docutils literal notranslate"><span class="pre">PublicOnly()</span></code> extension was added to make data encapsulation easier. If you only want your public classes registered, use <code class="docutils literal notranslate"><span class="pre">PublicOnly()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">PublicOnly</span><span class="p">();</span>
</pre></div>
</div>
<p>To apply custom filtering to the types that are registered, use the <code class="docutils literal notranslate"><span class="pre">Where()</span></code> predicate:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Repository&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>To exclude types from scanning, use the <code class="docutils literal notranslate"><span class="pre">Except()</span></code> predicate:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">Except</span><span class="p">&lt;</span><span class="n">MyUnwantedType</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Except()</span></code> predicate also allows you to customize the registration for the specific excluded type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">Except</span><span class="p">&lt;</span><span class="n">MyCustomisedType</span><span class="p">&gt;(</span><span class="n">ct</span> <span class="p">=&gt;</span>
          <span class="n">ct</span><span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISpecial</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">());</span>
</pre></div>
</div>
<p>Multiple filters can be used, in which case they will be applied with logical AND.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">PublicOnly</span><span class="p">()</span>
       <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Repository&quot;</span><span class="p">))</span>
       <span class="p">.</span><span class="n">Except</span><span class="p">&lt;</span><span class="n">MyUnwantedRepository</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-services">
<h5>Specifying Services<a class="headerlink" href="#specifying-services" title="Permalink to this headline">¶</a></h5>
<p>The registration syntax for <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyTypes()</span></code> is a superset of <a class="reference internal" href="index.html#document-register/index"><span class="doc">the registration syntax for single types</span></a>, so methods like <code class="docutils literal notranslate"><span class="pre">As()</span></code> all work with assemblies as well:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Repository&quot;</span><span class="p">))</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IRepository</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Additional overloads to <code class="docutils literal notranslate"><span class="pre">As()</span></code> and <code class="docutils literal notranslate"><span class="pre">Named()</span></code> accept lambda expressions that determine, for a type, which services it will provide:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">GetInterfaces</span><span class="p">()[</span><span class="m">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>As with normal component registrations, multiple calls to <code class="docutils literal notranslate"><span class="pre">As()</span></code> are added together.</p>
<p>A number of additional registration methods have been added to make it easier to build up common conventions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="31%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">AsImplementedInterfaces()</span></code></td>
<td>Register the type as providing
all of its public interfaces as
services (excluding <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>).</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="o">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="o">.</span><span class="n">Where</span><span class="p">(</span><span class="n">t</span> <span class="o">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Name</span><span class="o">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s2">&quot;Repository&quot;</span><span class="p">))</span>
       <span class="o">.</span><span class="n">AsImplementedInterfaces</span><span class="p">();</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">AsClosedTypesOf(open)</span></code></td>
<td>Register types that are assignable to
a closed instance of the open
generic type.</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="o">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="o">.</span><span class="n">AsClosedTypesOf</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="o">&lt;&gt;</span><span class="p">));</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">AsSelf()</span></code></td>
<td>The default: register types as
themselves - useful when also
overriding the default with another
service specification.</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="o">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
       <span class="o">.</span><span class="n">AsImplementedInterfaces</span><span class="p">()</span>
       <span class="o">.</span><span class="n">AsSelf</span><span class="p">();</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="scanning-for-modules">
<h4>Scanning for Modules<a class="headerlink" href="#scanning-for-modules" title="Permalink to this headline">¶</a></h4>
<p>Module scanning is performed with the <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyModules()</span></code> registration method, which does exactly what its name suggests. It scans through the provided assemblies for <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a>, creates instances of the modules, and then registers them with the current container builder.</p>
<p>For example, say the two simple module classes below live in the same assembly and each register a single component:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">AModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">AComponent</span><span class="p">()).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">AComponent</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">BModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">BComponent</span><span class="p">()).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">BComponent</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The overload of <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyModules()</span></code> that <em>does not accept a type parameter</em> will register all classes implementing <code class="docutils literal notranslate"><span class="pre">IModule</span></code> found in the provided list of assemblies. In the example below <strong>both modules</strong> get registered:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">AComponent</span><span class="p">).</span><span class="n">Assembly</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Registers both modules</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyModules</span><span class="p">(</span><span class="n">assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>The overload of <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyModules()</span></code> with <em>the generic type parameter</em> allows you to specify a base type that the modules must derive from. In the example below <strong>only one module</strong> is registered because the scanning is restricted:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">AComponent</span><span class="p">).</span><span class="n">Assembly</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Registers AModule but not BModule</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyModules</span><span class="p">&lt;</span><span class="n">AModule</span><span class="p">&gt;(</span><span class="n">assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>The overload of <code class="docutils literal notranslate"><span class="pre">RegisterAssemblyModules()</span></code> with <em>a Type object parameter</em> works like the generic type parameter overload but allows you to specify a type that might be determined at runtime. In the example below <strong>only one module</strong> is registered because the scanning is restricted:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">AComponent</span><span class="p">).</span><span class="n">Assembly</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Registers AModule but not BModule</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAssemblyModules</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">AModule</span><span class="p">),</span> <span class="n">assembly</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="iis-hosted-web-applications">
<h4>IIS Hosted Web Applications<a class="headerlink" href="#iis-hosted-web-applications" title="Permalink to this headline">¶</a></h4>
<p>When using assembly scanning with IIS applications, you can run into a little trouble depending on how you do the assembly location. (<a class="reference internal" href="index.html#document-faq/iis-restart"><span class="doc">This is one of our FAQs</span></a>)</p>
<p>When hosting applications in IIS all assemblies are loaded into the <code class="docutils literal notranslate"><span class="pre">AppDomain</span></code> when the application first starts, but <strong>when the AppDomain is recycled by IIS the assemblies are then only loaded on demand.</strong></p>
<p>To avoid this issue use the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.compilation.buildmanager.getreferencedassemblies.aspx">GetReferencedAssemblies()</a> method on <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.compilation.buildmanager.aspx">System.Web.Compilation.BuildManager</a> to get a list of the referenced assemblies instead:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">assemblies</span> <span class="p">=</span> <span class="n">BuildManager</span><span class="p">.</span><span class="n">GetReferencedAssemblies</span><span class="p">().</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Assembly</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>That will force the referenced assemblies to be loaded into the <code class="docutils literal notranslate"><span class="pre">AppDomain</span></code> immediately making them available for module scanning.</p>
</div>
</div>
</div>
</div>
<span id="document-resolve/index"></span><div class="section" id="resolving-services">
<h2>Resolving Services<a class="headerlink" href="#resolving-services" title="Permalink to this headline">¶</a></h2>
<p>After you have your <a class="reference internal" href="index.html#document-register/index"><span class="doc">components registered with appropriate services exposed</span></a>, you can resolve services from the built container and child <a class="reference internal" href="index.html#document-lifetime/index"><span class="doc">lifetime scopes</span></a>. You do this using the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyComponent</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will notice the example resolves the service from a lifetime scope rather than the container directly - you should, too.</p>
<blockquote>
<div><strong>While it is possible to resolve components right from the root container, doing this through your application in some cases may result in a memory leak.</strong> It is recommended you always resolve components from a lifetime scope where possible to make sure service instances are properly disposed and garbage collected. You can read more about this in the <a class="reference internal" href="index.html#document-lifetime/index"><span class="doc">section on controlling scope and lifetime</span></a>.</div></blockquote>
<p>When resolving a service, Autofac will automatically chain down the entire dependency hierarchy of the service and resolve any dependencies required to fully construct the service. If you have <a class="reference internal" href="index.html#document-advanced/circular-dependencies"><span class="doc">circular dependencies</span></a> that are improperly handled or if there are missing required dependencies, you will get a <code class="docutils literal notranslate"><span class="pre">DependencyResolutionException</span></code>.</p>
<p>If you have a service that may or may not be registered, you can attempt conditional resolution of the service using <code class="docutils literal notranslate"><span class="pre">ResolveOptional()</span></code> or <code class="docutils literal notranslate"><span class="pre">TryResolve()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// If IService is registered, it will be resolved; if</span>
<span class="c1">// it isn&#39;t registered, the return value will be null.</span>
<span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">ResolveOptional</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>

<span class="c1">// If IProvider is registered, the provider variable</span>
<span class="c1">// will hold the value; otherwise you can take some</span>
<span class="c1">// other action.</span>
<span class="n">IProvider</span> <span class="n">provider</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">scope</span><span class="p">.</span><span class="n">TryResolve</span><span class="p">&lt;</span><span class="n">IProvider</span><span class="p">&gt;(</span><span class="k">out</span> <span class="n">provider</span><span class="p">))</span>
<span class="p">{</span>
  <span class="c1">// Do something with the resolved provider value.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">ResolveOptional()</span></code> and <code class="docutils literal notranslate"><span class="pre">TryResolve()</span></code> revolve around the conditional nature of a specific service <em>being registered</em>. If the service is registered, resolution will be attempted. If resolution fails (e.g., due to lack of a dependency being registered), <strong>you will still get a DependencyResolutionException</strong>. If you need conditional resolution around a service where the condition is based on whether or not the service can successfully resolve, wrap the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> call with a try/catch block.</p>
<p>Additional topics for resolving services:</p>
<div class="toctree-wrapper compound">
<span id="document-resolve/parameters"></span><div class="section" id="passing-parameters-to-resolve">
<h3>Passing Parameters to Resolve<a class="headerlink" href="#passing-parameters-to-resolve" title="Permalink to this headline">¶</a></h3>
<p>When it’s time to <a class="reference internal" href="index.html#document-index"><span class="doc">resolve services</span></a>, you may find that you need to pass parameters to the resolution. (If you know the values at registration time, <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">you can provide them in the registration instead</span></a>.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> methods accept <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">the same parameter types available at registration time</span></a> using a variable-length argument list. Alternatively, <a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">delegate factories</span></a> and the <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship type</span></a> also allow ways to pass parameters during resolution.</p>
<div class="section" id="available-parameter-types">
<h4>Available Parameter Types<a class="headerlink" href="#available-parameter-types" title="Permalink to this headline">¶</a></h4>
<p>Autofac offers several different parameter matching strategies:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NamedParameter</span></code> - match target parameters by name</li>
<li><code class="docutils literal notranslate"><span class="pre">TypedParameter</span></code> - match target parameters by type (exact type match required)</li>
<li><code class="docutils literal notranslate"><span class="pre">ResolvedParameter</span></code> - flexible parameter matching</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">NamedParameter</span></code> and <code class="docutils literal notranslate"><span class="pre">TypedParameter</span></code> can supply constant values only.</p>
<p><code class="docutils literal notranslate"><span class="pre">ResolvedParameter</span></code> can be used as a way to supply values dynamically retrieved from the container, e.g. by resolving a service by name.</p>
</div>
<div class="section" id="parameters-with-reflection-components">
<h4>Parameters with Reflection Components<a class="headerlink" href="#parameters-with-reflection-components" title="Permalink to this headline">¶</a></h4>
<p>When you resolve a reflection-based component, the constructor of the type may require a parameter that you need to specify based on a runtime value, something that isn’t available at registration time. You can use a parameter in the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> method call to provide that value.</p>
<p>Say you have a configuration reader that needs a configuration section name passed in:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ConfigReader</span> <span class="p">:</span> <span class="n">IConfigReader</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ConfigReader</span><span class="p">(</span><span class="kt">string</span> <span class="n">configSectionName</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Store config section name</span>
  <span class="p">}</span>

  <span class="c1">// ...read configuration based on the section name.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You could pass a parameter to the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> call like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ConfigReader</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">NamedParameter</span><span class="p">(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">,</span> <span class="s">&quot;sectionName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#document-register/parameters"><span class="doc">As with registration-time parameters</span></a>, the <code class="docutils literal notranslate"><span class="pre">NamedParameter</span></code> in the example will map to the corresponding named constructor parameter, assuming the <code class="docutils literal notranslate"><span class="pre">ConfigReader</span></code> component was <a class="reference internal" href="index.html#document-register/registration"><span class="doc">registered using reflection</span></a>.</p>
<p>If you have more than one parameter, just pass them all in via the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">AnotherService</span><span class="p">&gt;(</span>
                <span class="k">new</span> <span class="nf">NamedParameter</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;service-identifier&quot;</span><span class="p">),</span>
                <span class="k">new</span> <span class="nf">TypedParameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Guid</span><span class="p">),</span> <span class="n">Guid</span><span class="p">.</span><span class="n">NewGuid</span><span class="p">()),</span>
                <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
                  <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ILog</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">pi</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&quot;logger&quot;</span><span class="p">,</span>
                  <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">LogManager</span><span class="p">.</span><span class="n">GetLogger</span><span class="p">(</span><span class="s">&quot;service&quot;</span><span class="p">)));</span>
</pre></div>
</div>
</div>
<div class="section" id="parameters-with-lambda-expression-components">
<h4>Parameters with Lambda Expression Components<a class="headerlink" href="#parameters-with-lambda-expression-components" title="Permalink to this headline">¶</a></h4>
<p>With lambda expression component registrations, you need to add the parameter handling inside your lambda expression so when the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> call passes them in, you can take advantage of them.</p>
<p>In the component registration expression, you can make use of the incoming parameters by changing the delegate signature you use for registration. Instead of just taking in an <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> parameter, take in an <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> and an <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;Parameter&gt;</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use TWO parameters to the registration delegate:</span>
<span class="c1">// c = The current IComponentContext to dynamically resolve dependencies</span>
<span class="c1">// p = An IEnumerable&lt;Parameter&gt; with the incoming parameter set</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">=&gt;</span>
                 <span class="k">new</span> <span class="nf">ConfigReader</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">)))</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Now when you resolve the <code class="docutils literal notranslate"><span class="pre">IConfigReader</span></code>, your lambda will use the parameters passed in:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IConfigReader</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">NamedParameter</span><span class="p">(</span><span class="s">&quot;configSectionName&quot;</span><span class="p">,</span> <span class="s">&quot;sectionName&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="passing-parameters-without-explicitly-calling-resolve">
<h4>Passing Parameters Without Explicitly Calling Resolve<a class="headerlink" href="#passing-parameters-without-explicitly-calling-resolve" title="Permalink to this headline">¶</a></h4>
<p>Autofac supports two features that allow you to automatically generate service “factories” that can take strongly-typed parameter lists that will be used during resolution. This is a slightly cleaner way to create component instances that require parameters.</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">Delegate Factories</span></a> allow you to define factory delegate methods.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship type</span></a> can provide an automatically-generated factory function.</li>
</ul>
</div>
</div>
<span id="document-resolve/relationships"></span><div class="section" id="implicit-relationship-types">
<h3>Implicit Relationship Types<a class="headerlink" href="#implicit-relationship-types" title="Permalink to this headline">¶</a></h3>
<p>Autofac supports automatically resolving particular types implicitly to support special relationships between <a class="reference internal" href="index.html#document-glossary"><span class="doc">components and services</span></a>. To take advantage of these relationships, simply register your components as normal, but change the constructor parameter in the consuming component or the type being resolved in the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> call so it takes in the specified relationship type.</p>
<p>For example, when Autofac is injecting a constructor parameter of type <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;ITask&gt;</span></code> it will <strong>not</strong> look for a component that supplies <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;ITask&gt;</span></code>. Instead, the container will find all implementations of <code class="docutils literal notranslate"><span class="pre">ITask</span></code> and inject all of them.</p>
<p>(Don’t worry - there are examples below showing the usage of the various types and what they mean.)</p>
<p>Note: To override this default behavior <em>it is still possible to register explicit implementations of these types</em>.</p>
<p>[Content on this document based on Nick Blumhardt’s blog article <a class="reference external" href="http://nblumhardt.com/2010/01/the-relationship-zoo/">The Relationship Zoo</a>.]</p>
<div class="section" id="supported-relationship-types">
<h4>Supported Relationship Types<a class="headerlink" href="#supported-relationship-types" title="Permalink to this headline">¶</a></h4>
<p>The table below summarizes each of the supported relationship types in Autofac and shows the .NET type you can use to consume them. Each relationship type has a more detailed description and use case after that.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="33%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Relationship</th>
<th class="head">Type</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>A</em> needs <em>B</em></td>
<td><code class="docutils literal notranslate"><span class="pre">B</span></code></td>
<td>Direct Dependency</td>
</tr>
<tr class="row-odd"><td><em>A</em> needs <em>B</em> at some point in the future</td>
<td><code class="docutils literal notranslate"><span class="pre">Lazy&lt;B&gt;</span></code></td>
<td>Delayed Instantiation</td>
</tr>
<tr class="row-even"><td><em>A</em> needs <em>B</em> until some point in the future</td>
<td><code class="docutils literal notranslate"><span class="pre">Owned&lt;B&gt;</span></code></td>
<td><a class="reference internal" href="index.html#document-advanced/owned-instances"><span class="doc">Controlled Lifetime</span></a></td>
</tr>
<tr class="row-odd"><td><em>A</em> needs to create instances of <em>B</em></td>
<td><code class="docutils literal notranslate"><span class="pre">Func&lt;B&gt;</span></code></td>
<td>Dynamic Instantiation</td>
</tr>
<tr class="row-even"><td><em>A</em> provides parameters of types <em>X</em> and <em>Y</em> to <em>B</em></td>
<td><code class="docutils literal notranslate"><span class="pre">Func&lt;X,Y,B&gt;</span></code></td>
<td>Parameterized Instantiation</td>
</tr>
<tr class="row-odd"><td><em>A</em> needs all the kinds of <em>B</em></td>
<td><code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;B&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">IList&lt;B&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">ICollection&lt;B&gt;</span></code></td>
<td>Enumeration</td>
</tr>
<tr class="row-even"><td><em>A</em> needs to know <em>X</em> about <em>B</em></td>
<td><code class="docutils literal notranslate"><span class="pre">Meta&lt;B&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">Meta&lt;B,X&gt;</span></code></td>
<td><a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">Metadata Interrogation</span></a></td>
</tr>
<tr class="row-odd"><td><em>A</em> needs to choose <em>B</em> based on <em>X</em></td>
<td><code class="docutils literal notranslate"><span class="pre">IIndex&lt;X,B&gt;</span></code></td>
<td><a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">Keyed Service</span></a> Lookup</td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="relationship-type-details">
<p class="topic-title">Relationship Type Details</p>
<ul class="simple">
<li><a class="reference internal" href="#direct-dependency-b" id="id1">Direct Dependency (B)</a></li>
<li><a class="reference internal" href="#delayed-instantiation-lazy-b" id="id2">Delayed Instantiation (Lazy&lt;B&gt;)</a></li>
<li><a class="reference internal" href="#controlled-lifetime-owned-b" id="id3">Controlled Lifetime (Owned&lt;B&gt;)</a></li>
<li><a class="reference internal" href="#dynamic-instantiation-func-b" id="id4">Dynamic Instantiation (Func&lt;B&gt;)</a></li>
<li><a class="reference internal" href="#parameterized-instantiation-func-x-y-b" id="id5">Parameterized Instantiation (Func&lt;X, Y, B&gt;)</a></li>
<li><a class="reference internal" href="#enumeration-ienumerable-b-ilist-b-icollection-b" id="id6">Enumeration (IEnumerable&lt;B&gt;, IList&lt;B&gt;, ICollection&lt;B&gt;)</a></li>
<li><a class="reference internal" href="#metadata-interrogation-meta-b-meta-b-x" id="id7">Metadata Interrogation (Meta&lt;B&gt;, Meta&lt;B, X&gt;)</a></li>
<li><a class="reference internal" href="#keyed-service-lookup-iindex-x-b" id="id8">Keyed Service Lookup (IIndex&lt;X, B&gt;)</a></li>
</ul>
</div>
<div class="section" id="direct-dependency-b">
<h5><a class="toc-backref" href="#id1">Direct Dependency (B)</a><a class="headerlink" href="#direct-dependency-b" title="Permalink to this headline">¶</a></h5>
<p>A <em>direct dependency</em> relationship is the most basic relationship supported - component <code class="docutils literal notranslate"><span class="pre">A</span></code> needs service <code class="docutils literal notranslate"><span class="pre">B</span></code>. This is handled automatically through standard constructor and property injection:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">B</span> <span class="n">dependency</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Register the <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> components, then resolve:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// B is automatically injected into A.</span>
  <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="delayed-instantiation-lazy-b">
<h5><a class="toc-backref" href="#id2">Delayed Instantiation (Lazy&lt;B&gt;)</a><a class="headerlink" href="#delayed-instantiation-lazy-b" title="Permalink to this headline">¶</a></h5>
<p>A <em>lazy dependency</em> is not instantiated until its first use. This appears where the dependency is infrequently used, or expensive to construct. To take advantage of this, use a <code class="docutils literal notranslate"><span class="pre">Lazy&lt;B&gt;</span></code> in the constructor of <code class="docutils literal notranslate"><span class="pre">A</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">_b</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_b</span> <span class="p">=</span> <span class="n">b</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// The component implementing B is created the</span>
      <span class="c1">// first time M() is called</span>
      <span class="n">_b</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you have a lazy dependency for which you also need metadata, you can use <code class="docutils literal notranslate"><span class="pre">Lazy&lt;B,M&gt;</span></code> instead of the longer <code class="docutils literal notranslate"><span class="pre">Meta&lt;Lazy&lt;B&gt;,</span> <span class="pre">M&gt;</span></code>.</p>
</div>
<div class="section" id="controlled-lifetime-owned-b">
<h5><a class="toc-backref" href="#id3">Controlled Lifetime (Owned&lt;B&gt;)</a><a class="headerlink" href="#controlled-lifetime-owned-b" title="Permalink to this headline">¶</a></h5>
<p>An <em>owned dependency</em> can be released by the owner when it is no longer required. Owned dependencies usually correspond to some unit of work performed by the dependent component.</p>
<p>This type of relationship is interesting particularly when working with components that implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>. <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">Autofac automatically disposes of disposable components</span></a> at the end of a lifetime scope, but that may mean a component is held onto for too long; or you may just want to take control of disposing the object yourself. In this case, you’d use an <em>owned dependency</em>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">Owned</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">_b</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// _b is used for some task</span>
      <span class="n">_b</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

      <span class="c1">// Here _b is no longer needed, so</span>
      <span class="c1">// it is released</span>
      <span class="n">_b</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Internally, Autofac creates a tiny lifetime scope in which the <code class="docutils literal notranslate"><span class="pre">B</span></code> service is resolved, and when you call <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> on it, the lifetime scope is disposed. What that means is that disposing of <code class="docutils literal notranslate"><span class="pre">B</span></code> will <em>also dispose of its dependencies</em> unless those dependencies are shared (e.g., singletons).</p>
<p>This also means that if you have <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code> registrations and you resolve one as <code class="docutils literal notranslate"><span class="pre">Owned&lt;B&gt;</span></code> then you may not get the same instance as being used elsewhere in the same lifetime scope. This example shows the gotcha:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;().</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;().</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// Here we resolve a B that is InstancePerLifetimeScope();</span>
  <span class="kt">var</span> <span class="n">b1</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;();</span>
  <span class="n">b1</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

  <span class="c1">// This will be the same as b1 from above.</span>
  <span class="kt">var</span> <span class="n">b2</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;();</span>
  <span class="n">b2</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

  <span class="c1">// The B used in A will NOT be the same as the others.</span>
  <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;();</span>
  <span class="n">a</span><span class="p">.</span><span class="n">M</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is by design because you wouldn’t want one component to dispose the <code class="docutils literal notranslate"><span class="pre">B</span></code> out from under everything else. However, it may lead to some confusion if you’re not aware.</p>
<p>If you would rather control <code class="docutils literal notranslate"><span class="pre">B</span></code> disposal yourself all the time, <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">register B as ExternallyOwned()</span></a>.</p>
</div>
<div class="section" id="dynamic-instantiation-func-b">
<h5><a class="toc-backref" href="#id4">Dynamic Instantiation (Func&lt;B&gt;)</a><a class="headerlink" href="#dynamic-instantiation-func-b" title="Permalink to this headline">¶</a></h5>
<p>Using an <em>auto-generated factory</em> can let you resolve a new <cite>B</cite> programmatically within the control flow of your program, without requiring a direct dependency on the Autofac library. Use this relationship type if:</p>
<ul class="simple">
<li>You need to create more than one instance of a given service.</li>
<li>You want to specifically control when the setup of the service occurs.</li>
<li>You’re not sure if you’re going to need a service and want to make the decision at runtime.</li>
</ul>
<p>This relationship is also useful in cases like <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">WCF integration</span></a> where you need to create a new service proxy after faulting the channel.</p>
<p><code class="docutils literal notranslate"><span class="pre">Func&lt;B&gt;</span></code> behaves just like calling <code class="docutils literal notranslate"><span class="pre">Resolve&lt;B&gt;()</span></code>. That means it’s not limited to acting on parameterless constructors on objects - it will wire up constructor parameters, do property injection, and follow the whole lifecycle that <code class="docutils literal notranslate"><span class="pre">Resolve&lt;B&gt;()</span></code> does.</p>
<p>Further, lifetime scopes are respected. If you register an object as <code class="docutils literal notranslate"><span class="pre">InstancePerDependency()</span></code> and call the <code class="docutils literal notranslate"><span class="pre">Func&lt;B&gt;</span></code> multiple times, you’ll get a new instance each time; if you register an object as <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> and call the <code class="docutils literal notranslate"><span class="pre">Func&lt;B&gt;</span></code> to resolve the object more than once, you will get <em>the same object instance every time</em>.</p>
<p>An example of this relationship looks like:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoSomething</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">_newB</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_newB</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">_newB</span><span class="p">();</span>
      <span class="n">b</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parameterized-instantiation-func-x-y-b">
<h5><a class="toc-backref" href="#id5">Parameterized Instantiation (Func&lt;X, Y, B&gt;)</a><a class="headerlink" href="#parameterized-instantiation-func-x-y-b" title="Permalink to this headline">¶</a></h5>
<p>You can also use an <em>auto-generated factory</em> to provide parameters when creating an new instance of the object, where the constructor of the object calls for some additional parameters. While the <code class="docutils literal notranslate"><span class="pre">Func&lt;B&gt;</span></code> relationship is similar to <code class="docutils literal notranslate"><span class="pre">Resolve&lt;B&gt;()</span></code>, the <code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code> relationship is like calling <code class="docutils literal notranslate"><span class="pre">Resolve&lt;B&gt;(TypedParameter.From&lt;X&gt;(x),</span> <span class="pre">TypedParameter.From&lt;Y&gt;(y))</span></code> - a resolve operation that has typed parameters. This is an alternative to <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">passing parameters during registration</span></a> or <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">passing during manual resolution</span></a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">B</span><span class="p">(</span><span class="kt">string</span> <span class="n">someString</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoSomething</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">_newB</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_newB</span> <span class="p">=</span> <span class="n">b</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">_newB</span><span class="p">(</span><span class="m">42</span><span class="p">,</span> <span class="s">&quot;http://hell.owor.ld&quot;</span><span class="p">);</span>
        <span class="n">b</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that since we’re resolving the instance rather than directly calling the constructor we don’t need to declare the parameters in the same order as they appear in the constructor definition, nor do we need to provide <em>all</em> the parameters listed in the constructor. If some of the constructor’s parameters can be resolved by the lifetime scope, then those parameters can be omitted from the <code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code> signature being declared. You only <em>need</em> to list the types that the scope can’t resolve.</p>
<p>Alternatively, you can use this approach to override a constructor parameter that <em>would</em> otherwise have been resolved from the container, with a concrete instance already in hand.</p>
<p>Example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//Suppose that P, Q &amp; R are all registered with the Autofac Container.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">P</span> <span class="n">peaDependency</span><span class="p">,</span> <span class="n">Q</span> <span class="n">queueDependency</span><span class="p">,</span> <span class="n">R</span> <span class="n">ourDependency</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoSomething</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">_newB</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">bFactory</span><span class="p">)</span> <span class="p">{</span> <span class="n">_newB</span> <span class="p">=</span> <span class="n">bFactory</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">(</span><span class="n">P</span> <span class="n">existingPea</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// The Q and R will be resolved by Autofac, but P will be existingPea instead.</span>
        <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">_newB</span><span class="p">(</span><span class="m">42</span><span class="p">,</span> <span class="n">existingPea</span><span class="p">);</span>
        <span class="n">b</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Internally, Autofac determines what values to use for the constructor args solely based on the type and behaves as though we’ve temporarily defined the input values for resolution. A consequence of this is that  <strong>auto-generated function factories cannot have duplicate types in the input parameter list.</strong> See below for further notes on this.</p>
<p><strong>Lifetime scopes are respected</strong> using this relationship type, just as they are when using <a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">delegate factories</span></a>. If you register an object as <code class="docutils literal notranslate"><span class="pre">InstancePerDependency()</span></code> and call the <code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code> multiple times, you’ll get a new instance each time. However, if you register an object as <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> and call the <code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code> to resolve the object more than once, you will get <em>the same object instance every time regardless of the different parameters you pass in.</em> Just passing different parameters will not break the respect for the lifetime scope.</p>
<p>As noted above, <code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code> treats arguments as <code class="docutils literal notranslate"><span class="pre">TypedParameter</span></code> so you can’t have duplicate types in the parameter list. For example, say you have a type like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">DuplicateTypes</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">DuplicateTypes</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">string</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You might want to register that type and have an auto-generated function factory for it. <em>You will be able to resolve the function, but you won’t be able to execute it.</em></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">func</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="n">DuplicateTypes</span><span class="p">&gt;&gt;();</span>

<span class="c1">// Throws a DependencyResolutionException:</span>
<span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">func</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>In a loosely coupled scenario where the parameters are matched on type, you shouldn’t really know about the order of the parameters for a specific object’s constructor. If you need to do something like this, you should use a custom delegate type instead:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">delegate</span> <span class="n">DuplicateTypes</span> <span class="nf">FactoryDelegate</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">string</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>Then register that delegate using <code class="docutils literal notranslate"><span class="pre">RegisterGeneratedFactory()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DuplicateTypes</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGeneratedFactory</span><span class="p">&lt;</span><span class="n">FactoryDelegate</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">TypedService</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DuplicateTypes</span><span class="p">)));</span>
</pre></div>
</div>
<p>Now the function will work:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">func</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">FactoryDelegate</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">func</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Another option you have is to use a <a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">delegate factory, which you can read about in the advanced topics section</span></a>.</p>
<p>Should you decide to use the built-in auto-generated factory behavior (<code class="docutils literal notranslate"><span class="pre">Func&lt;X,</span> <span class="pre">Y,</span> <span class="pre">B&gt;</span></code>) and only resolve a factory with one of each type, it will work but you’ll get the same input for all constructor parameters of the same type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">func</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="n">DuplicateTypes</span><span class="p">&gt;&gt;();</span>

<span class="c1">// This works and is the same as calling</span>
<span class="c1">// new DuplicateTypes(1, 1, &quot;three&quot;)</span>
<span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">func</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>You can read more about delegate factories and the <code class="docutils literal notranslate"><span class="pre">RegisterGeneratedFactory()</span></code> method <a class="reference internal" href="index.html#document-advanced/delegate-factories"><span class="doc">in the advanced topics section</span></a>.</p>
</div>
<div class="section" id="enumeration-ienumerable-b-ilist-b-icollection-b">
<h5><a class="toc-backref" href="#id6">Enumeration (IEnumerable&lt;B&gt;, IList&lt;B&gt;, ICollection&lt;B&gt;)</a><a class="headerlink" href="#enumeration-ienumerable-b-ilist-b-icollection-b" title="Permalink to this headline">¶</a></h5>
<p>Dependencies of an <em>enumerable type</em> provide multiple implementations of the same service (interface). This is helpful in cases like message handlers, where a message comes in and more than one handler is registered to process the message.</p>
<p>Let’s say you have a dependency interface defined like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IMessageHandler</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">HandleMessage</span><span class="p">(</span><span class="n">Message</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Further, you have a consumer of dependencies like that where you need to have more than one registered and the consumer needs all of the registered dependencies:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MessageProcessor</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;</span> <span class="n">_handlers</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MessageProcessor</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;</span> <span class="n">handlers</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_handlers</span> <span class="p">=</span> <span class="n">handlers</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ProcessMessage</span><span class="p">(</span><span class="n">Message</span> <span class="n">m</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">handler</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="n">_handlers</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">handler</span><span class="p">.</span><span class="n">HandleMessage</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can easily accomplish this using the implicit enumerable relationship type. Just register all of the dependencies and the consumer, and when you resolve the consumer the <em>set of all matching dependencies</em> will be resolved as an enumeration.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">FirstHandler</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SecondHandler</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ThirdHandler</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MessageProcessor</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// When processor is resolved, it&#39;ll have all of the</span>
  <span class="c1">// registered handlers passed in to the constructor.</span>
  <span class="kt">var</span> <span class="n">processor</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">MessageProcessor</span><span class="p">&gt;();</span>
  <span class="n">processor</span><span class="p">.</span><span class="n">ProcessMessage</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>The enumerable support will return an empty set if no matching items are registered in the container.</strong> That is, using the above example, if you don’t register any <code class="docutils literal notranslate"><span class="pre">IMessageHandler</span></code> implementations, this will break:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This throws an exception - none are registered!</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p><em>However, this works:</em></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This returns an empty list, NOT an exception:</span>
<span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
<p>This can create a bit of a “gotcha” where you might think you’ll get a null value if you inject something using this relationship. Instead, you’ll get an empty list.</p>
</div>
<div class="section" id="metadata-interrogation-meta-b-meta-b-x">
<h5><a class="toc-backref" href="#id7">Metadata Interrogation (Meta&lt;B&gt;, Meta&lt;B, X&gt;)</a><a class="headerlink" href="#metadata-interrogation-meta-b-meta-b-x" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">Autofac metadata feature</span></a> lets you associate arbitrary data with services that you can use to make decisions when resolving. If you want to make those decisions in the consuming component, use the <code class="docutils literal notranslate"><span class="pre">Meta&lt;B&gt;</span></code> relationship, which will provide you with a string/object dictionary of all the object metadata:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">Meta</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">_b</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_b</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;SomeValue&quot;</span><span class="p">]</span> <span class="p">==</span> <span class="s">&quot;yes&quot;</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_b</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can use <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">strongly-typed metadata</span></a> as well, by specifying the metadata type in the <code class="docutils literal notranslate"><span class="pre">Meta&lt;B,</span> <span class="pre">X&gt;</span></code> relationship:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">Meta</span><span class="p">&lt;</span><span class="n">B</span><span class="p">,</span> <span class="n">BMetadata</span><span class="p">&gt;</span> <span class="n">_b</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">B</span><span class="p">,</span> <span class="n">BMetadata</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_b</span><span class="p">.</span><span class="n">Metadata</span><span class="p">.</span><span class="n">SomeValue</span> <span class="p">==</span> <span class="s">&quot;yes&quot;</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_b</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you have a lazy dependency for which you also need metadata, you can use <code class="docutils literal notranslate"><span class="pre">Lazy&lt;B,M&gt;</span></code> instead of the longer <code class="docutils literal notranslate"><span class="pre">Meta&lt;Lazy&lt;B&gt;,</span> <span class="pre">M&gt;</span></code>.</p>
</div>
<div class="section" id="keyed-service-lookup-iindex-x-b">
<h5><a class="toc-backref" href="#id8">Keyed Service Lookup (IIndex&lt;X, B&gt;)</a><a class="headerlink" href="#keyed-service-lookup-iindex-x-b" title="Permalink to this headline">¶</a></h5>
<p>In the case where you have many of a particular item (like the <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;B&gt;</span></code> relationship) but you want to pick one based on <a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">service key</span></a>, you can use the <code class="docutils literal notranslate"><span class="pre">IIndex&lt;X,</span> <span class="pre">B&gt;</span></code> relationship. First, register your services with keys:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DerivedB</span><span class="p">&gt;().</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;(</span><span class="s">&quot;first&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">AnotherDerivedB</span><span class="p">&gt;().</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;(</span><span class="s">&quot;second&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Then consume the <code class="docutils literal notranslate"><span class="pre">IIndex&lt;X,</span> <span class="pre">B&gt;</span></code> to get a dictionary of keyed services:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="n">IIndex</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">_b</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">IIndex</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">_b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_b</span><span class="p">[</span><span class="s">&quot;first&quot;</span><span class="p">];</span>
    <span class="n">b</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="composing-relationship-types">
<h4>Composing Relationship Types<a class="headerlink" href="#composing-relationship-types" title="Permalink to this headline">¶</a></h4>
<p>Relationship types can be composed, so:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">ITask</span><span class="p">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Is interpreted correctly to mean:</p>
<blockquote>
<div><ul class="simple">
<li>All implementations, of</li>
<li>Factories, that return</li>
<li><a class="reference internal" href="index.html#document-advanced/owned-instances"><span class="doc">Lifetime-controlled</span></a></li>
<li><code class="docutils literal notranslate"><span class="pre">ITask</span></code> services</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="relationship-types-and-container-independence">
<h4>Relationship Types and Container Independence<a class="headerlink" href="#relationship-types-and-container-independence" title="Permalink to this headline">¶</a></h4>
<p>The custom relationship types in Autofac based on standard .NET types don’t force you to bind your application more tightly to Autofac. They give you a programming model for container configuration that is consistent with the way you write other components (vs. having to know a lot of specific container extension points and APIs that also potentially centralize your configuration).</p>
<p>For example, you can still create a custom <code class="docutils literal notranslate"><span class="pre">ITaskFactory</span></code> in your core model, but provide an <code class="docutils literal notranslate"><span class="pre">AutofacTaskFactory</span></code> implementation based on <code class="docutils literal notranslate"><span class="pre">Func&lt;Owned&lt;ITask&gt;&gt;</span></code> if that is desirable.</p>
<p>Note that some relationships are based on types that are in Autofac (e.g., <code class="docutils literal notranslate"><span class="pre">IIndex&lt;X,</span> <span class="pre">B&gt;</span></code>). Using those relationship types do tie you to at least having a reference to Autofac, even if you choose to use a different IoC container for the actual resolution of services.</p>
</div>
</div>
</div>
<p>You may also be interested in checking out the list of <a class="reference internal" href="index.html#document-advanced/index"><span class="doc">advanced topics</span></a> to learn about <a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">named and keyed services</span></a>, <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">working with component metadata</span></a>, and other service resolution related topics.</p>
</div>
<span id="document-lifetime/index"></span><div class="section" id="controlling-scope-and-lifetime">
<h2>Controlling Scope and Lifetime<a class="headerlink" href="#controlling-scope-and-lifetime" title="Permalink to this headline">¶</a></h2>
<p>A great place to start learning about Autofac scope and lifetime is in <a class="reference external" href="http://nblumhardt.com/2011/01/an-autofac-lifetime-primer/">Nick Blumhardt’s Autofac lifetime primer</a>. There’s a lot to digest, though, and a lot of intermixed concepts there, so we’ll try to complement that article here.</p>
<p>You may recall from the <a class="reference internal" href="index.html#document-register/registration"><span class="doc">registration topic</span></a> that you add <strong>components</strong> to the container that implement <strong>services</strong>. You then end up <a class="reference internal" href="index.html#document-resolve/index"><span class="doc">resolving services</span></a> and using those service instances to do your work.</p>
<p>The <strong>lifetime</strong> of a service is how long the service instance will live in your application - from the original instantiation to <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">disposal</span></a>. For example, if you “new up” an object that implements <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.idisposable.aspx">IDisposable</a> and then later call <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> on it, the lifetime of that object is from the time you instantiated it all the way through disposal (or garbage collection if you didn’t proactively dispose it).</p>
<p>The <strong>scope</strong> of a service is the area in the application where that service can be shared with other components that consume it. For example, in your application you may have a global static singleton - the “scope” of that global object instance would be the whole application. On the other hand, you might create a local variable in a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop that makes use of the global singleton - the local variable has a much smaller scope than the global.</p>
<p>The concept of a <strong>lifetime scope</strong> in Autofac combines these two notions. Effectively, a lifetime scope equates with a unit of work in your application. A unit of work might begin a lifetime scope at the start, then services required for that unit of work get resolved from a lifetime scope. As you resolve services, Autofac tracks disposable (<code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>) components that are resolved. At the end of the unit of work, you dispose of the associated lifetime scope and Autofac will automatically clean up/dispose of the resolved services.</p>
<p><strong>The two important things lifetime scopes control are sharing and disposal.</strong></p>
<ul class="simple">
<li><strong>Lifetime scopes are nestable and they control how components are shared.</strong> For example, a “singleton” service might be resolved from a root lifetime scope while individual units of work may require their own instances of other services. You can determine how a component is shared by <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">setting its instance scope at registration</span></a>.</li>
<li><strong>Lifetime scopes track disposable objects and dispose of them when the lifetime scope is disposed.</strong> For example, if you have a component that implements <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> and you resolve it from a lifetime scope, the scope will hold onto it and dispose of it for you so your service consumers don’t have to know about the underlying implementation. <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">You have the ability to control this behavior or add new disposal behavior if you choose.</span></a></li>
</ul>
<p>As you work in your application, it’s good to remember these concepts so you make the most efficient use of your resources.</p>
<blockquote>
<div><strong>It is important to always resolve services from a lifetime scope and not the root container.</strong> Due to the disposal tracking nature of lifetime scopes, if you resolve a lot of disposable components from the container (the “root lifetime scope”), you may inadvertently cause yourself a memory leak. The root container will hold references to those disposable components for as long as it lives (usually the lifetime of the application) so it can dispose of them. <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">You can change disposal behavior if you choose</span></a>, but it’s a good practice to only resolve from a scope. If Autofac detects usage of a singleton or shared component, it will automatically place it in the appropriate tracking scope.</div></blockquote>
<p>Let’s look at a web application as a more concrete example to illustrate lifetime scope usage. Say you have the following scenario:</p>
<ul class="simple">
<li>You have a global singleton logging service.</li>
<li>Two simultaneous requests come in to the web application.</li>
<li>Each request is a logical “unit of work” and each requires its own order processing service.</li>
<li>Each order processing service needs to log information to the logging service.</li>
</ul>
<p>In this scenario, you’d have a root lifetime scope that contains the singleton logging service and you’d have one child lifetime scope per request, each with its own order processing service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---------------------------------------------------+</span>
<span class="o">|</span>                 <span class="n">Autofac</span> <span class="n">Container</span>                 <span class="o">|</span>
<span class="o">|</span>                <span class="n">Root</span> <span class="n">Lifetime</span> <span class="n">Scope</span>                <span class="o">|</span>
<span class="o">|</span>                                                   <span class="o">|</span>
<span class="o">|</span>                  <span class="n">Logging</span> <span class="n">Service</span>                  <span class="o">|</span>
<span class="o">|</span>            <span class="p">(</span><span class="n">shared</span> <span class="n">across</span> <span class="nb">all</span> <span class="n">requests</span><span class="p">)</span>           <span class="o">|</span>
<span class="o">|</span>                                                   <span class="o">|</span>
<span class="o">|</span> <span class="o">+----------------------+</span> <span class="o">+----------------------+</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span>  <span class="n">First</span> <span class="n">Request</span> <span class="n">Scope</span> <span class="o">|</span> <span class="o">|</span> <span class="n">Second</span> <span class="n">Request</span> <span class="n">Scope</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span>                      <span class="o">|</span> <span class="o">|</span>                      <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span>   <span class="n">Order</span> <span class="n">Processor</span>    <span class="o">|</span> <span class="o">|</span>   <span class="n">Order</span> <span class="n">Processor</span>    <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">+----------------------+</span> <span class="o">+----------------------+</span> <span class="o">|</span>
<span class="o">+---------------------------------------------------+</span>
</pre></div>
</div>
<p>When each request ends, the request lifetime scope ends and the respective order processor gets disposed. The logging service, as a singleton, stays alive for sharing by future requests.</p>
<p>You can dive deeper on lifetime scopes in <a class="reference external" href="http://nblumhardt.com/2011/01/an-autofac-lifetime-primer/">Nick Blumhardt’s Autofac lifetime primer</a>.</p>
<p><strong>Additional lifetime scope topics to explore:</strong></p>
<div class="toctree-wrapper compound">
<span id="document-lifetime/working-with-scopes"></span><div class="section" id="working-with-lifetime-scopes">
<h3>Working with Lifetime Scopes<a class="headerlink" href="#working-with-lifetime-scopes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="creating-a-new-lifetime-scope">
<h4>Creating a New Lifetime Scope<a class="headerlink" href="#creating-a-new-lifetime-scope" title="Permalink to this headline">¶</a></h4>
<p>You can create a lifetime scope by calling the <code class="docutils literal notranslate"><span class="pre">BeginLifetimeScope()</span></code> method on any existing lifetime scope, starting with the root container. <strong>Lifetime scopes are disposable and they track component disposal, so make sure you always call “Dispose()”” or wrap them in “using” statements.</strong></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// Resolve services from a scope that is a child</span>
  <span class="c1">// of the root container.</span>
  <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>

  <span class="c1">// You can also create nested scopes...</span>
  <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">unitOfWorkScope</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">anotherService</span> <span class="p">=</span> <span class="n">unitOfWorkScope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IOther</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="tagging-a-lifetime-scope">
<h4>Tagging a Lifetime Scope<a class="headerlink" href="#tagging-a-lifetime-scope" title="Permalink to this headline">¶</a></h4>
<p>There are some cases where you want to share services across units of work but you don’t want those services to be shared globally like singletons. A common example is “per-request” lifetimes in web applications. (<a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">You can read more about per-request scoping in the “Instance Scope” topic.</span></a>) In this case, you’d want to tag your lifetime scope and register services as <code class="docutils literal notranslate"><span class="pre">InstancePerMatchingLifetimeScope()</span></code>.</p>
<p>For example, say you have a component that sends emails. A logical transaction in your system may need to send more than one email, so you can share that component across individual pieces of the logical transaction. However, you don’t want the email component to be a global singleton. Your setup might look something like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Register your transaction-level shared component</span>
<span class="c1">// as InstancePerMatchingLifetimeScope and give it</span>
<span class="c1">// a &quot;known tag&quot; that you&#39;ll use when starting new</span>
<span class="c1">// transactions.</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailSender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailSender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerMatchingLifetimeScope</span><span class="p">(</span><span class="s">&quot;transaction&quot;</span><span class="p">);</span>

<span class="c1">// Both the order processor and the receipt manager</span>
<span class="c1">// need to send email notifications.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OrderProcessor</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IOrderProcessor</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ReceiptManager</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IReceiptManager</span><span class="p">&gt;();</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>


<span class="c1">// Create transaction scopes with a tag.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">transactionScope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;transaction&quot;</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">orderScope</span> <span class="p">=</span> <span class="n">transactionScope</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// This would resolve an IEmailSender to use, but the</span>
    <span class="c1">// IEmailSender would &quot;live&quot; in the parent transaction</span>
    <span class="c1">// scope and be shared across any children of the</span>
    <span class="c1">// transaction scope because of that tag.</span>
    <span class="kt">var</span> <span class="n">op</span> <span class="p">=</span> <span class="n">orderScope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IOrderProcessor</span><span class="p">&gt;();</span>
    <span class="n">op</span><span class="p">.</span><span class="n">ProcessOrder</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">receiptScope</span> <span class="p">=</span> <span class="n">transactionScope</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// This would also resolve an IEmailSender to use, but it</span>
    <span class="c1">// would find the existing IEmailSender in the parent</span>
    <span class="c1">// scope and use that. It&#39;d be the same instance used</span>
    <span class="c1">// by the order processor.</span>
    <span class="kt">var</span> <span class="n">rm</span> <span class="p">=</span> <span class="n">receiptScope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IReceiptManager</span><span class="p">&gt;();</span>
    <span class="n">rm</span><span class="p">.</span><span class="n">SendReceipt</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Again, <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">you can read more about tagged scopes and per-request scoping in the “Instance Scope” topic.</span></a></p>
</div>
<div class="section" id="adding-registrations-to-a-lifetime-scope">
<h4>Adding Registrations to a Lifetime Scope<a class="headerlink" href="#adding-registrations-to-a-lifetime-scope" title="Permalink to this headline">¶</a></h4>
<p>Autofac allows you to add registrations “on the fly” as you create lifetime scopes. This can help you when you need to do a sort of “spot weld” limited registration override or if you generally just need some additional stuff in a scope that you don’t want to register globally. You do this by passing a lambda to <code class="docutils literal notranslate"><span class="pre">BeginLifetimeScope()</span></code> that takes a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> and adds registrations.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span>
  <span class="n">builder</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Override</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">MyModule</span><span class="p">&gt;();</span>
  <span class="p">}))</span>
<span class="p">{</span>
  <span class="c1">// The additional registrations will be available</span>
  <span class="c1">// only in this lifetime scope.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-lifetime/instance-scope"></span><div class="section" id="instance-scope">
<h3>Instance Scope<a class="headerlink" href="#instance-scope" title="Permalink to this headline">¶</a></h3>
<p>Instance scope determines how an instance is shared between requests for the same service. Note that you should be familiar with <a class="reference internal" href="index.html#document-lifetime/index"><span class="doc">the concept of lifetime scopes</span></a> to better understand what’s happening here.</p>
<p>When a request is made for a service, Autofac can return a single instance (single instance scope), a new instance (per dependency scope), or a single instance within some kind of context, e.g. a thread or an HTTP request (per lifetime scope).</p>
<p>This applies to instances returned from an explicit <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> call as well as instances created internally by the container to satisfy the dependencies of another component.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Choosing the right lifetime scope will help you avoid <a class="reference internal" href="index.html#document-lifetime/captive-dependencies"><span class="doc">captive dependencies</span></a> and other pitfalls where a component lives too long or not long enough. It is up to the developer to make the correct choice for each of their application components.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#instance-per-dependency" id="id1">Instance Per Dependency</a></li>
<li><a class="reference internal" href="#single-instance" id="id2">Single Instance</a></li>
<li><a class="reference internal" href="#instance-per-lifetime-scope" id="id3">Instance Per Lifetime Scope</a></li>
<li><a class="reference internal" href="#instance-per-matching-lifetime-scope" id="id4">Instance Per Matching Lifetime Scope</a></li>
<li><a class="reference internal" href="#instance-per-request" id="id5">Instance Per Request</a></li>
<li><a class="reference internal" href="#instance-per-owned" id="id6">Instance Per Owned</a></li>
<li><a class="reference internal" href="#thread-scope" id="id7">Thread Scope</a></li>
</ul>
</div>
<div class="section" id="instance-per-dependency">
<h4><a class="toc-backref" href="#id1">Instance Per Dependency</a><a class="headerlink" href="#instance-per-dependency" title="Permalink to this headline">¶</a></h4>
<p>Also called ‘transient’ or ‘factory’ in other containers. Using per-dependency scope, <strong>a unique instance will be returned from each request for a service.</strong></p>
<p><strong>This is the default</strong> if no other option is specified.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// This...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>

<span class="c1">// ...is the same as this:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">();</span>
</pre></div>
</div>
<p>When you resolve a component that is instance per dependency, you get a new one each time.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="c1">// Every one of the 100 Worker instances</span>
    <span class="c1">// resolved in this loop will be brand new.</span>
    <span class="kt">var</span> <span class="n">w</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
    <span class="n">w</span><span class="p">.</span><span class="n">DoWork</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="single-instance">
<h4><a class="toc-backref" href="#id2">Single Instance</a><a class="headerlink" href="#single-instance" title="Permalink to this headline">¶</a></h4>
<p>This is also known as ‘singleton.’ Using single instance scope, <strong>one instance is returned from all requests in the root and all nested scopes</strong>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
</pre></div>
</div>
<p>When you resolve a single instance component, you always get the same instance no matter where you request it.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// It&#39;s generally not good to resolve things from the</span>
<span class="c1">// container directly, but for singleton demo purposes</span>
<span class="c1">// we do...</span>
<span class="kt">var</span> <span class="n">root</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>

<span class="c1">// We can resolve the worker from any level of nested</span>
<span class="c1">// lifetime scope, any number of times.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">w1</span> <span class="p">=</span> <span class="n">scope1</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
    <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope2</span> <span class="p">=</span> <span class="n">scope1</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">w2</span> <span class="p">=</span> <span class="n">scope2</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>

      <span class="c1">// root, w1, and w2 are always literally the</span>
      <span class="c1">// same object instance. It doesn&#39;t matter</span>
      <span class="c1">// which lifetime scope it&#39;s resolved from</span>
      <span class="c1">// or how many times.</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="instance-per-lifetime-scope">
<h4><a class="toc-backref" href="#id3">Instance Per Lifetime Scope</a><a class="headerlink" href="#instance-per-lifetime-scope" title="Permalink to this headline">¶</a></h4>
<p>This scope applies to nested lifetimes. <strong>A component with per-lifetime scope will have at most a single instance per nested lifetime scope.</strong></p>
<p>This is useful for objects specific to a single unit of work that may need to nest additional logical units of work. Each nested lifetime scope will get a new instance of the registered dependency.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;().</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
</pre></div>
</div>
<p>When you resolve the instance per lifetime scope component, you get a single instance per nested scope (e.g., per unit of work).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="c1">// Every time you resolve this from within this</span>
    <span class="c1">// scope you&#39;ll get the same instance.</span>
    <span class="kt">var</span> <span class="n">w1</span> <span class="p">=</span> <span class="n">scope1</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="c1">// Every time you resolve this from within this</span>
    <span class="c1">// scope you&#39;ll get the same instance, but this</span>
    <span class="c1">// instance is DIFFERENT than the one that was</span>
    <span class="c1">// used in the above scope. New scope = new instance.</span>
    <span class="kt">var</span> <span class="n">w2</span> <span class="p">=</span> <span class="n">scope2</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="instance-per-matching-lifetime-scope">
<h4><a class="toc-backref" href="#id4">Instance Per Matching Lifetime Scope</a><a class="headerlink" href="#instance-per-matching-lifetime-scope" title="Permalink to this headline">¶</a></h4>
<p>This is similar to the ‘instance per lifetime scope’ concept above, but allows more precise control over instance sharing.</p>
<p>When you create a nested lifetime scope, you have the ability to “tag” or “name” the scope. <strong>A component with per-matching-lifetime scope will have at most a single instance per nested lifetime scope that matches a given name.</strong> This allows you to create a sort of “scoped singleton” where other nested lifetime scopes can share an instance of a component without declaring a global shared instance.</p>
<p>This is useful for objects specific to a single unit of work, e.g. an HTTP request, as a nested lifetime can be created per unit of work. If a nested lifetime is created per HTTP request, then any component with per-lifetime scope will have an instance per HTTP request. (More on per-request lifetime scope below.)</p>
<p>In most applications, only one level of container nesting will be sufficient for representing the scope of units of work. If more levels of nesting are required (e.g. something like global-&gt;request-&gt;transaction) components can be configured to be shared at a particular level in the hierarchy using tags.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;().</span><span class="n">InstancePerMatchingLifetimeScope</span><span class="p">(</span><span class="s">&quot;myrequest&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The supplied tag value is associated with a lifetime scope when you start it. <strong>You will get an exception if you try to resolve a per-matching-lifetime-scope component when there’s no correctly named lifetime scope.</strong></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the lifetime scope using the tag.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;myrequest&quot;</span><span class="p">))</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">w1</span> <span class="p">=</span> <span class="n">scope1</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
    <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope2</span> <span class="p">=</span> <span class="n">scope1</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">w2</span> <span class="p">=</span> <span class="n">scope2</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>

      <span class="c1">// w1 and w2 are always the same object</span>
      <span class="c1">// instance because the component is per-matching-lifetime-scope,</span>
      <span class="c1">// so it&#39;s effectively a singleton within the</span>
      <span class="c1">// named scope.</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Create another lifetime scope using the tag.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope3</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;myrequest&quot;</span><span class="p">))</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="c1">// w3 will be DIFFERENT than the worker resolved in the</span>
    <span class="c1">// earlier tagged lifetime scope.</span>
    <span class="kt">var</span> <span class="n">w3</span> <span class="p">=</span> <span class="n">scope3</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
    <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope4</span> <span class="p">=</span> <span class="n">scope3</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">w4</span> <span class="p">=</span> <span class="n">scope4</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>

      <span class="c1">// w3 and w4 are always the same object because</span>
      <span class="c1">// they&#39;re in the same tagged scope, but they are</span>
      <span class="c1">// NOT the same as the earlier workers (w1, w2).</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// You can&#39;t resolve a per-matching-lifetime-scope component</span>
<span class="c1">// if there&#39;s no matching scope.</span>
<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">noTagScope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// This throws an exception because this scope doesn&#39;t</span>
  <span class="c1">// have the expected tag and neither does any parent scope!</span>
  <span class="kt">var</span> <span class="n">fail</span> <span class="p">=</span> <span class="n">noTagScope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="instance-per-request">
<h4><a class="toc-backref" href="#id5">Instance Per Request</a><a class="headerlink" href="#instance-per-request" title="Permalink to this headline">¶</a></h4>
<p>Some application types naturally lend themselves to “request” type semantics, for example ASP.NET <a class="reference internal" href="index.html#document-integration/webforms"><span class="doc">web forms</span></a> and <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">MVC</span></a> applications. In these application types, it’s helpful to have the ability to have a sort of “singleton per request.”</p>
<p><strong>Instance per request builds on top of instance per matching lifetime scope</strong> by providing a well-known lifetime scope tag, a registration convenience method, and integration for common application types. Behind the scenes, though, it’s still just instance per matching lifetime scope.</p>
<p>What this means is that if you try to resolve components that are registered as instance-per-request but there’s no current request… you’re going to get an exception.</p>
<p><a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">There is a detailed FAQ outlining how to work with per-request lifetimes.</span></a></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Worker</span><span class="p">&gt;().</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>ASP.NET Core uses Instance Per Lifetime Scope rather than Instance Per Request.</strong> See the <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">ASP.NET Core integration doc for more</span></a>.</p>
</div>
<div class="section" id="instance-per-owned">
<h4><a class="toc-backref" href="#id6">Instance Per Owned</a><a class="headerlink" href="#instance-per-owned" title="Permalink to this headline">¶</a></h4>
<p>The <cite>Owned&lt;T&gt;</cite> <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship type</span></a> creates new nested lifetime scopes. It is possible to scope dependencies to the owned instance using the instance-per-owned registrations.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MessageHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ServiceForHandler</span><span class="p">&gt;().</span><span class="n">InstancePerOwned</span><span class="p">&lt;</span><span class="n">MessageHandler</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>In this example the <code class="docutils literal notranslate"><span class="pre">ServiceForHandler</span></code> service will be scoped to the lifetime of the owned <code class="docutils literal notranslate"><span class="pre">MessageHandler</span></code> instance.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// The message handler itself as well as the</span>
  <span class="c1">// resolved dependent ServiceForHandler service</span>
  <span class="c1">// is in a tiny child lifetime scope under</span>
  <span class="c1">// &quot;scope.&quot; Note that resolving an Owned&lt;T&gt;</span>
  <span class="c1">// means YOU are responsible for disposal.</span>
  <span class="kt">var</span> <span class="n">h1</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">MessageHandler</span><span class="p">&gt;&gt;();</span>
  <span class="n">h1</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="thread-scope">
<h4><a class="toc-backref" href="#id7">Thread Scope</a><a class="headerlink" href="#thread-scope" title="Permalink to this headline">¶</a></h4>
<p>Autofac can enforce that objects bound to one thread will not satisfy the dependencies of a component bound to another thread. While there is not a convenience method for this, you can do it using lifetime scopes.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyThreadScopedComponent</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Then, each thread gets its own lifetime scope:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="nf">ThreadStart</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">threadLifetime</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">thisThreadsInstance</span> <span class="p">=</span> <span class="n">threadLifetime</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">MyThreadScopedComponent</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>IMPORTANT: Given the multithreaded scenario, you must be very careful that the parent scope doesn’t get disposed out from under the spawned thread.</strong> You can get into a bad situation where components can’t be resolved if you spawn the thread and then dispose the parent scope.</p>
<p>Each thread executing through <code class="docutils literal notranslate"><span class="pre">ThreadStart()</span></code> will then get its own instance of <code class="docutils literal notranslate"><span class="pre">MyThreadScopedComponent</span></code> - which is essentially a “singleton” in the lifetime scope. Because scoped instances are never provided to outer scopes, it is easier to keep thread components separated.</p>
<p>You can inject a parent lifetime scope into the code that spawns the thread by taking an <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code> parameter. Autofac knows to automatically inject the current lifetime scope and you can create a nested scope from that.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ThreadCreator</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">ILifetimeScope</span> <span class="n">_parentScope</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ThreadCreator</span><span class="p">(</span><span class="n">ILifetimeScope</span> <span class="n">parentScope</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_parentScope</span> <span class="p">=</span> <span class="n">parentScope</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ThreadStart</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">threadLifetime</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_parentScope</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">thisThreadsInstance</span> <span class="p">=</span> <span class="n">threadLifetime</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">MyThreadScopedComponent</span><span class="p">&gt;();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you would like to enforce this even more heavily, use instance per matching lifetime scope (see above) to associate the thread-scoped components with the inner lifetime (they’ll still have dependencies from the factory/singleton components in the outer container injected.) The result of this approach looks something like:</p>
<img alt="_images/threadedcontainers.png" src="_images/threadedcontainers.png" />
<p>The ‘contexts’ in the diagram are the containers created with <code class="docutils literal notranslate"><span class="pre">BeginLifetimeScope()</span></code>.</p>
</div>
</div>
<span id="document-lifetime/captive-dependencies"></span><div class="section" id="captive-dependencies">
<h3>Captive Dependencies<a class="headerlink" href="#captive-dependencies" title="Permalink to this headline">¶</a></h3>
<p>A “captive dependency” occurs when a component intended to live for a <em>short</em> amount of time gets held by a component that lives for a <em>long</em> time. <a class="reference external" href="http://blog.ploeh.dk/2014/06/02/captive-dependency/">This blog article from Mark Seemann</a> does a good job of explaining the concept.</p>
<p><strong>Autofac does not necessarily prevent you from creating captive dependencies.</strong> You may find times when you get a resolution exception because of the way a captive is set up, but you won’t always. Stopping captive dependencies is the responsibility of the developer.</p>
<div class="section" id="general-rule">
<h4>General Rule<a class="headerlink" href="#general-rule" title="Permalink to this headline">¶</a></h4>
<p>The general rule to avoid captive dependencies:</p>
<p><strong>The lifetime of the consuming component should be less than or equal to the lifetime of the service being consumed.</strong></p>
<p>Basically, don’t let a singleton take an instance-per-request dependency because it’ll be held too long.</p>
</div>
<div class="section" id="simple-example">
<h4>Simple Example<a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h4>
<p>Say you have a web application that uses some information from the inbound request to determine the right database to which a connection should be made. You might have the following components:</p>
<ul class="simple">
<li>A <em>repository</em> that takes in the current request and a database connection factory.</li>
<li>The <em>current request</em> like an <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code> that could be used to help decide the business logic.</li>
<li>The <em>database connection factory</em> that takes some sort of parameter and returns the right database connection.</li>
</ul>
<p>In this example, consider the <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">lifetime scope</span></a> that you’d want to use for each component. The current request context is an obvious one - you want <em>instance-per-request</em>. What about the others?</p>
<p>For the <em>repository</em>, say you choose “singleton.” A singleton gets created one time and cached for the life of the application. If you choose “singleton,” the request context will be passed in and held for the life of the application - even after that current request is over, the stale request context will be held. The repository is long-lived, but holds on to a shorter-life component. <strong>That’s a captive dependency.</strong></p>
<p>However, say you make the repository “instance-per-request” - now it lives as long as the current request and no longer. That’s exactly as long as the request context it needs, so now it’s not a captive. Both the repository and the request context will be released at the same time (at the end of the request) and everything will be fine.</p>
<p>Taking it a step further, say you make the repository “instance-per-dependency” so you get a new one every time. This is still OK because it is intended to live for a <em>shorter</em> time than the current request. It won’t hold onto the request for too long, so there’s no captive.</p>
<p>The database connection factory goes through a similar thought process, but may have some different considerations. Maybe the factory is expensive to instantiate or needs to maintain some internal state to work correctly. You may not want it to be “instance-per-request” or “instance-per-dependency.” You may actually need it to be a singleton.</p>
<p><strong>It’s OK for shorter-lived dependencies to take on longer-lived dependencies.</strong> If your repository is “instance-per-request” or “instance-per-dependency” you’ll still be good. The database connection factory intentionally lives longer.</p>
</div>
<div class="section" id="code-example">
<h4>Code Example<a class="headerlink" href="#code-example" title="Permalink to this headline">¶</a></h4>
<p>Here’s a unit test that shows what it looks like to forcibly create a captive dependency. In this example, a “rule manager” is used to deal with a set of “rules” that get used through an application.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">RuleManager</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">RuleManager</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;</span> <span class="n">rules</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">Rules</span> <span class="p">=</span> <span class="n">rules</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;</span> <span class="n">Rules</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IRule</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SingletonRule</span> <span class="p">:</span> <span class="n">IRule</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">InstancePerDependencyRule</span> <span class="p">:</span> <span class="n">IRule</span> <span class="p">{</span> <span class="p">}</span>


<span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">CaptiveDependency</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// The rule manager is a single-instance component. It</span>
    <span class="c1">// will only ever be instantiated one time and the cached</span>
    <span class="c1">// instance will be used thereafter. It will be always be resolved</span>
    <span class="c1">// from the root lifetime scope (the container) because</span>
    <span class="c1">// it needs to be shared.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">RuleManager</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>

    <span class="c1">// This rule is registered instance-per-dependency. A new</span>
    <span class="c1">// instance will be created every time it&#39;s requested.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">InstancePerDependencyRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;();</span>

    <span class="c1">// This rule is registered as a singleton. Like the rule manager</span>
    <span class="c1">// it will only ever be resolved one time and will be resolved</span>
    <span class="c1">// from the root lifetime scope.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SingletonRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>

    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">())</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;request&quot;</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// The manager will be a singleton. It will contain</span>
      <span class="c1">// a reference to the singleton SingletonRule, which is</span>
      <span class="c1">// fine. However, it will also hold onto an InstancePerDependencyRule</span>
      <span class="c1">// which may not be OK. The InstancePerDependencyRule that it</span>
      <span class="c1">// holds will live for the lifetime of the container inside the</span>
      <span class="c1">// RuleManager and will last until the container is disposed.</span>
      <span class="kt">var</span> <span class="n">manager</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">RuleManager</span><span class="p">&gt;();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the example above doesn’t directly show it, but if you were to dynamically add registrations for rules in the <code class="docutils literal notranslate"><span class="pre">container.BeginLifetimeScope()</span></code> call, those dynamic registrations <em>would not be included</em> in the resolved <code class="docutils literal notranslate"><span class="pre">RuleManager</span></code>. The <code class="docutils literal notranslate"><span class="pre">RuleManager</span></code>, being a singleton, gets resolved from the root container where the dynamically added registrations don’t exist.</p>
<p>Another code example shows how you may get an exception when creating a captive dependency that ties incorrectly to a child lifetime scope.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">RuleManager</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">RuleManager</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;</span> <span class="n">rules</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">Rules</span> <span class="p">=</span> <span class="n">rules</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;</span> <span class="n">Rules</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IRule</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SingletonRule</span> <span class="p">:</span> <span class="n">IRule</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">SingletonRule</span><span class="p">(</span><span class="n">InstancePerRequestDependency</span> <span class="n">dep</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">InstancePerRequestDependency</span> <span class="p">:</span> <span class="n">IRule</span> <span class="p">{</span> <span class="p">}</span>


<span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">CaptiveDependency</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// Again, the rule manager is a single-instance component,</span>
    <span class="c1">// resolved from the root lifetime and cached thereafter.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">RuleManager</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>

    <span class="c1">// This rule is registered as a singleton. Like the rule manager</span>
    <span class="c1">// it will only ever be resolved one time and will be resolved</span>
    <span class="c1">// from the root lifetime scope.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SingletonRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>

    <span class="c1">// This rule is registered on a per-request basis. It only exists</span>
    <span class="c1">// during the request.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">InstancePerRequestDependency</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IRule</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">InstancePerMatchingLifetimeScope</span><span class="p">(</span><span class="s">&quot;request&quot;</span><span class="p">);</span>

    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">())</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;request&quot;</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// PROBLEM: When the SingletonRule is resolved as part of the dependency</span>
      <span class="c1">// chain for the rule manager, the InstancePerRequestDependency in</span>
      <span class="c1">// the rule constructor will fail to be resolved because the rule</span>
      <span class="c1">// is coming from the root lifetime scope but the InstancePerRequestDependency</span>
      <span class="c1">// doesn&#39;t exist there.</span>
      <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">DependencyResolutionException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">RuleManager</span><span class="p">&gt;());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="exception-to-the-rule">
<h4>Exception to the Rule<a class="headerlink" href="#exception-to-the-rule" title="Permalink to this headline">¶</a></h4>
<p>Given the developer of the application is ultimately responsible for determining whether captives are OK or not, the developer may determine that it’s acceptable for a singleton, for example, to take an “instance-per-dependency” service.</p>
<p>For example, maybe you have a caching class that is intentionally set up to cache things for only the lifetime of the consuming component. If the consumer is a singleton, the cache can be used to store things for the whole app lifetime; if the consumer is “instance-per-request” then it only stores data for a single web request. In a case like that, you may end up with a longer-lived component taking a dependency on a shorter-lived component <em>intentionally</em>.</p>
<p>This is acceptable as long as the application developer understands the consequences of setting things up with such lifetimes. Which is to say, if you’re going to do it, do it intentionally rather than accidentally.</p>
</div>
</div>
<span id="document-lifetime/disposal"></span><div class="section" id="disposal">
<h3>Disposal<a class="headerlink" href="#disposal" title="Permalink to this headline">¶</a></h3>
<p>Resources obtained within a unit of work - database connections, transactions, authenticated sessions, file handles etc. - should be disposed of when that work is complete. .NET provides the <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> interface to aid in this more deterministic notion of disposal.</p>
<p>Some IoC containers need to be told explicitly to dispose of a particular instance, through a method like <code class="docutils literal notranslate"><span class="pre">ReleaseInstance()</span></code>. This makes it very difficult to guarantee that the correct disposal semantics are used.</p>
<ul class="simple">
<li>Switching implementations from a non-disposable to a disposable component can mean modifying client code.</li>
<li>Client code that may have ignored disposal when using shared instances will almost certainly fail to clean up when switched to non-shared instances.</li>
</ul>
<p><a class="reference internal" href="index.html#document-lifetime/index"><span class="doc">Autofac solves these problems using lifetime scopes</span></a> as a way of disposing of all of the components created during a unit of work.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">DisposableComponent</span><span class="p">&gt;().</span><span class="n">DoSomething</span><span class="p">();</span>

  <span class="c1">// Components for scope disposed here, at the</span>
  <span class="c1">// end of the &#39;using&#39; statement when the scope</span>
  <span class="c1">// itself is disposed.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A lifetime scope is created when a unit of work begins, and when that unit of work is complete the nested container can dispose all of the instances within it that are out of scope.</p>
<div class="section" id="registering-components">
<h4>Registering Components<a class="headerlink" href="#registering-components" title="Permalink to this headline">¶</a></h4>
<p>Autofac can automatically dispose of some components, but you have the ability to manually specify a disposal mechanism, too.</p>
<p>Components must be registered as <code class="docutils literal notranslate"><span class="pre">InstancePerDependency()</span></code> (the default) or some variation of <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">InstancePerMatchingLifetimeScope()</span></code> or <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code>).</p>
<p>If you have singleton components (registered as <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code>) <strong>they will live for the life of the container</strong>. Since container lifetimes are usually the application lifetime, it means the component won’t be disposed until the end of the application.</p>
<div class="section" id="automatic-disposal">
<h5>Automatic Disposal<a class="headerlink" href="#automatic-disposal" title="Permalink to this headline">¶</a></h5>
<p>To take advantage of automatic deterministic disposal, your component must implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>.
You can then register your component as needed and at the end of each lifetime scope in which the component
is resolved, the <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> method on the component will be called.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeDisposableComponent</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="c1">// Create nested lifetime scopes, resolve</span>
<span class="c1">// the component, and dispose of the scopes.</span>
<span class="c1">// Your component will be disposed with the scope.</span>
</pre></div>
</div>
</div>
<div class="section" id="asynchronous-disposal-support">
<h5>Asynchronous Disposal Support<a class="headerlink" href="#asynchronous-disposal-support" title="Permalink to this headline">¶</a></h5>
<p>If your components’ disposal behaviour requires some I/O activity, such as flushing a buffer to a file,
or sending a packet over the network to close a connection, then you may want to consider implementing
the new .NET <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable?view=netstandard-2.1">IAsyncDisposable</a>
interface.</p>
<p>In Autofac 5.0, support was added for the <code class="docutils literal notranslate"><span class="pre">IAsyncDisposable</span></code> interface, so lifetime scopes can now be disposed of
asynchronously:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyComponent</span> <span class="p">:</span> <span class="n">IDisposable</span><span class="p">,</span> <span class="n">IAsyncDisposable</span>
<span class="p">{</span>
  <span class="n">INetworkResource</span> <span class="n">myResource</span><span class="p">;</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">myResource</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span> <span class="nf">DisposeAsync</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">myResource</span><span class="p">.</span><span class="n">CloseAsync</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="k">await</span> <span class="nf">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">MyComponent</span><span class="p">&gt;():</span>

    <span class="c1">// DisposeAsync will be called on MyComponent</span>
    <span class="c1">// when the using block exits.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When a lifetime scope is disposed of asynchronously, any registered components that implement <code class="docutils literal notranslate"><span class="pre">IAsyncDisposable</span></code>
in addition to <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> will have their <code class="docutils literal notranslate"><span class="pre">DisposeAsync()</span></code> method invoked, <strong>instead</strong> of the <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> method.</p>
<p>If a component only implements the synchronous <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> method,
then it will still be invoked when the lifetime scope is disposed asynchronously.</p>
<p>When using Autofac with the ASP.NET Core Integration, all per-request lifetime scopes are disposed of asynchronously.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>While you do not <em>have</em> to implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> if you implement <code class="docutils literal notranslate"><span class="pre">IAsyncDisposable</span></code>, we strongly
recommend you do so.</p>
<p class="last">If your component only implements <code class="docutils literal notranslate"><span class="pre">IAsyncDisposable</span></code>, but someone disposes of the scope synchronously,
then Autofac will throw an exception, because it does not know how to dispose of your component.</p>
</div>
</div>
<div class="section" id="specified-disposal">
<h5>Specified Disposal<a class="headerlink" href="#specified-disposal" title="Permalink to this headline">¶</a></h5>
<p>If your component doesn’t implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> but still requires some cleanup at the end of a lifetime scope, you can use <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">the OnRelease lifetime event</span></a>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeComponent</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">OnRelease</span><span class="p">(</span><span class="n">instance</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">CleanUp</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="c1">// Create nested lifetime scopes, resolve</span>
<span class="c1">// the component, and dispose of the scopes.</span>
<span class="c1">// Your component&#39;s &quot;CleanUp()&quot; method will be</span>
<span class="c1">// called when the scope is disposed.</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">OnRelease()</span></code> overrides the default handling of <code class="docutils literal notranslate"><span class="pre">IDisposable.Dispose()</span></code>. If your component both implements <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> <em>and</em> requires some other cleanup method, you will either need to manually call <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> in <code class="docutils literal notranslate"><span class="pre">OnRelease()</span></code> or you will need to update your class so the cleanup method gets called from inside <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code>.</p>
</div>
<div class="section" id="disabling-disposal">
<h5>Disabling Disposal<a class="headerlink" href="#disabling-disposal" title="Permalink to this headline">¶</a></h5>
<p>Components are owned by the container by default and will be disposed by it when appropriate.
To disable this, register a component as having external ownership:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeComponent</span><span class="p">&gt;().</span><span class="n">ExternallyOwned</span><span class="p">();</span>
</pre></div>
</div>
<p>The container will never call <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> or <code class="docutils literal notranslate"><span class="pre">DisposeAsync()</span></code> on an object registered with external ownership.
It is up to you to dispose of components registered in this fashion.</p>
<p>Another alternative for disabling disposal is to use the <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship</span></a> <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> and <a class="reference internal" href="index.html#document-advanced/owned-instances"><span class="doc">owned instances</span></a>. In this case, rather than putting a dependency <code class="docutils literal notranslate"><span class="pre">T</span></code> in your consuming code, you put a dependency on <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code>. Your consuming code will then be responsible for disposal.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Consumer</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">Owned</span><span class="p">&lt;</span><span class="n">DisposableComponent</span><span class="p">&gt;</span> <span class="n">_service</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">Consumer</span><span class="p">(</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">DisposableComponent</span><span class="p">&gt;</span> <span class="n">service</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_service</span> <span class="p">=</span> <span class="n">service</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// _service is used for some task</span>
    <span class="n">_service</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

    <span class="c1">// Here _service is no longer needed, so</span>
    <span class="c1">// it is released</span>
    <span class="n">_service</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can read more about <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> <a class="reference internal" href="index.html#document-advanced/owned-instances"><span class="doc">in the owned instances topic</span></a>.</p>
</div>
</div>
<div class="section" id="resolve-components-from-lifetime-scopes">
<h4>Resolve Components from Lifetime Scopes<a class="headerlink" href="#resolve-components-from-lifetime-scopes" title="Permalink to this headline">¶</a></h4>
<p>Lifetime scopes are created by calling <code class="docutils literal notranslate"><span class="pre">BeginLifetimeScope()</span></code>. The simplest way is in a <code class="docutils literal notranslate"><span class="pre">using</span></code> block. Use the lifetime scopes to resolve your components and then dispose of the scope when the unit of work is complete.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">lifetime</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">lifetime</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">SomeComponent</span><span class="p">&gt;();</span>
  <span class="c1">// component, and any of its disposable dependencies, will</span>
  <span class="c1">// be disposed of when the using block completes</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that with <a class="reference internal" href="index.html#document-integration/index"><span class="doc">Autofac integration libraries</span></a> standard unit-of-work lifetime scopes will be created and disposed for you automatically. For example, in Autofac’s <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">ASP.NET MVC integration</span></a>, a lifetime scope will be created for you at the beginning of a web request and all components will generally be resolved from there. At the end of the web request, the scope will automatically be disposed - no additional scope creation is required on your part. If you are using <a class="reference internal" href="index.html#document-integration/index"><span class="doc">one of the integration libraries</span></a>, you should be aware of what automatically-created scopes are available for you.</p>
<p>You can <a class="reference internal" href="index.html#document-lifetime/working-with-scopes"><span class="doc">read more about creating lifetime scopes here</span></a>.</p>
</div>
<div class="section" id="child-scopes-are-not-automatically-disposed">
<h4>Child Scopes are NOT Automatically Disposed<a class="headerlink" href="#child-scopes-are-not-automatically-disposed" title="Permalink to this headline">¶</a></h4>
<p>While lifetime scopes themselves implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code>, the lifetime scopes that you create are <strong>not automatically disposed for you.</strong> If you create a lifetime scope, you are responsible for calling <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> on it to clean it up and trigger the automatic disposal of components. This is done easily with a <code class="docutils literal notranslate"><span class="pre">using</span></code> statement, but if you create a scope without a <code class="docutils literal notranslate"><span class="pre">using</span></code>, don’t forget to dispose of it when you’re done with it.</p>
<p>It’s important to distinguish between scopes <strong>you create</strong> and scopes the <strong>integration libraries create for you</strong>. You don’t have to worry about managing integration scopes (like the ASP.NET request scope) - those will be done for you. However, if you manually create your own scope, you will be responsible for cleaning it up.</p>
</div>
<div class="section" id="provided-instances">
<h4>Provided Instances<a class="headerlink" href="#provided-instances" title="Permalink to this headline">¶</a></h4>
<p>If you provide <a class="reference internal" href="index.html#document-register/registration"><span class="doc">an instance registration</span></a> to Autofac, Autofac will assume ownership of that instance and will handle its disposal.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// If you do this, Autofac will dispose of the StringWriter</span>
<span class="c1">// instance when the container is disposed.</span>
<span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TextWriter</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>If you want to take control of the disposal of the instance yourself, you need to register the instance as <code class="docutils literal notranslate"><span class="pre">ExternallyOwned()</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Using ExternallyOwned means you will be responsible for</span>
<span class="c1">// disposing the StringWriter instead of Autofac.</span>
<span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TextWriter</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ExternallyOwned</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-hierarchies">
<h4>Advanced Hierarchies<a class="headerlink" href="#advanced-hierarchies" title="Permalink to this headline">¶</a></h4>
<p>The simplest and most advisable resource management scenario, demonstrated above, is two-tiered: there is a single ‘root’ container and a lifetime scope is created from this for each unit of work. It is possible to create more complex hierarchies of containers and components, however, using <a class="reference internal" href="index.html#document-lifetime/working-with-scopes"><span class="doc">tagged lifetime scopes</span></a>.</p>
</div>
</div>
<span id="document-lifetime/events"></span><div class="section" id="lifetime-events">
<h3>Lifetime Events<a class="headerlink" href="#lifetime-events" title="Permalink to this headline">¶</a></h3>
<p>Autofac exposes events that can be hooked at various stages in instance lifecycle. These are subscribed to during component registration (or alternatively by attaching to the <code class="docutils literal notranslate"><span class="pre">IComponentRegistration</span></code> interface.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#onpreparing" id="id1">OnPreparing</a></li>
<li><a class="reference internal" href="#onactivating" id="id2">OnActivating</a></li>
<li><a class="reference internal" href="#onactivated" id="id3">OnActivated</a></li>
<li><a class="reference internal" href="#onrelease" id="id4">OnRelease</a></li>
</ul>
</div>
<div class="section" id="onpreparing">
<h4><a class="toc-backref" href="#id1">OnPreparing</a><a class="headerlink" href="#onpreparing" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">OnPreparing</span></code> event is raised when a new instance of a component is required,
before <code class="docutils literal notranslate"><span class="pre">OnActivating</span></code> is invoked.</p>
<p>This event can be used to specify a custom set of parameter information that Autofac will consider
when it creates a new instance of the component.</p>
<p>The primary use case of this event is to mock or interecept the services that Autofac would normally
pass as parameters to component activation, by setting the <code class="docutils literal notranslate"><span class="pre">Parameters</span></code> property of the provided
<code class="docutils literal notranslate"><span class="pre">PreparingEventArgs</span></code> argument with any custom parameters.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Before you use this event to set parameters, consider whether it may be more appropriate
to define these at registration time, using <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">parameter registration</span></a>.</p>
</div>
</div>
<div class="section" id="onactivating">
<h4><a class="toc-backref" href="#id2">OnActivating</a><a class="headerlink" href="#onactivating" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">OnActivating</span></code> event is raised before a component is used. Here you can:</p>
<ul class="simple">
<li>Switch the instance for another or wrap it in a proxy</li>
<li><a class="reference internal" href="index.html#document-register/prop-method-injection"><span class="doc">Do property injection or method injection</span></a></li>
<li>Perform other initialization tasks</li>
</ul>
<p>In some cases, such as with <code class="docutils literal notranslate"><span class="pre">RegisterType&lt;T&gt;()</span></code>, the concrete type registered is used for type resolution and used by <code class="docutils literal notranslate"><span class="pre">ActivatingEventArgs</span></code>. For example, the following will fail with a class cast exception:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TConcrete</span><span class="p">&gt;()</span> <span class="c1">// FAILS: will throw at cast of TInterfaceSubclass</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TInterface</span><span class="p">&gt;()</span>          <span class="c1">// to type TConcrete</span>
       <span class="p">.</span><span class="n">OnActivating</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">ReplaceInstance</span><span class="p">(</span><span class="k">new</span> <span class="n">TInterfaceSubclass</span><span class="p">()));</span>
</pre></div>
</div>
<p>A simple workaround is to do the registration in two steps:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TConcrete</span><span class="p">&gt;().</span><span class="n">AsSelf</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">TInterface</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">TConcrete</span><span class="p">&gt;())</span>
       <span class="p">.</span><span class="n">OnActivating</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">ReplaceInstance</span><span class="p">(</span><span class="k">new</span> <span class="n">TInterfaceSubclass</span><span class="p">()));</span>
</pre></div>
</div>
</div>
<div class="section" id="onactivated">
<h4><a class="toc-backref" href="#id3">OnActivated</a><a class="headerlink" href="#onactivated" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">OnActivated</span></code> event is raised once a component is fully constructed. Here you can perform application-level tasks that depend on the component being fully constructed - <em>these should be rare</em>.</p>
</div>
<div class="section" id="onrelease">
<h4><a class="toc-backref" href="#id4">OnRelease</a><a class="headerlink" href="#onrelease" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">OnRelease</span></code> event replaces <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">the standard cleanup behavior for a component</span></a>. The standard cleanup behavior of components that implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> and that are not marked as <code class="docutils literal notranslate"><span class="pre">ExternallyOwned()</span></code> is to call the <code class="docutils literal notranslate"><span class="pre">Dispose()</span></code> method. The standard cleanup behavior for components that do not implement <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> or are marked as externally owned is a no-op - to do nothing. <code class="docutils literal notranslate"><span class="pre">OnRelease</span></code> overrides this behavior with the provided implementation.</p>
</div>
</div>
<span id="document-lifetime/startup"></span><div class="section" id="running-code-at-startup">
<h3>Running Code at Startup<a class="headerlink" href="#running-code-at-startup" title="Permalink to this headline">¶</a></h3>
<p>Autofac provides the ability for components to be notified or automatically activated when the container is built.</p>
<p>There are three automatic activation mechanisms available:
- Startable components
- Auto-activated components
- Container build callbacks</p>
<p>In all cases, <strong>at the time the container is built, the component will be activated</strong>.</p>
<p><strong>Use startup code sparingly.</strong> You can get yourself into some traps by overusing it. See the “Tips” section for more.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#startable-components" id="id1">Startable Components</a></li>
<li><a class="reference internal" href="#auto-activated-components" id="id2">Auto-Activated Components</a></li>
<li><a class="reference internal" href="#container-build-callbacks" id="id3">Container Build Callbacks</a></li>
<li><a class="reference internal" href="#tips" id="id4">Tips</a></li>
</ul>
</div>
<div class="section" id="startable-components">
<h4><a class="toc-backref" href="#id1">Startable Components</a><a class="headerlink" href="#startable-components" title="Permalink to this headline">¶</a></h4>
<p>A <strong>startable component</strong> is one that is activated by the container when the container is initially built and has a specific method called to bootstrap an action on the component.</p>
<p>The key is to implement the <code class="docutils literal notranslate"><span class="pre">Autofac.IStartable</span></code> interface. When the container is built, the component will be activated and the <code class="docutils literal notranslate"><span class="pre">IStartable.Start()</span></code> method will be called.</p>
<p><strong>This only happens once, for a single instance of each component, the first time the container is built.</strong> Resolving startable components by hand won’t result in their <code class="docutils literal notranslate"><span class="pre">Start()</span></code> method being called. It isn’t recommended that startable components are registered as anything other than <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code>.</p>
<p>Components that need to have something like a <code class="docutils literal notranslate"><span class="pre">Start()</span></code> method called <em>each time they are activated</em> should use <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">a lifetime event</span></a> like <code class="docutils literal notranslate"><span class="pre">OnActivated</span></code> instead.</p>
<p>To create a startable component, implement <code class="docutils literal notranslate"><span class="pre">Autofac.IStartable</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">StartupMessageWriter</span> <span class="p">:</span> <span class="n">IStartable</span>
<span class="p">{</span>
   <span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;App is starting up!&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then register your component and <strong>be sure to specify</strong> it as <code class="docutils literal notranslate"><span class="pre">IStartable</span></code> or the action won’t be called:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span>
   <span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">StartupMessageWriter</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IStartable</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>
</pre></div>
</div>
<p>When the container is built, the type will be activated and the <code class="docutils literal notranslate"><span class="pre">IStartable.Start()</span></code> method will be called. In this example, a message will be written to the console.</p>
<p>The order in which components are started is not defined, however, as of Autofac 4.7.0 when a component implementing <code class="docutils literal notranslate"><span class="pre">IStartable</span></code> depends on another component that is <code class="docutils literal notranslate"><span class="pre">IStartable</span></code>, the <code class="docutils literal notranslate"><span class="pre">Start()</span></code> method is guaranteed to have been called on the dependency before the dependent component is activated:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Startable1</span><span class="p">&gt;().</span><span class="n">AsSelf</span><span class="p">().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IStartable</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Startable2</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IStartable</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Startable1</span> <span class="p">:</span> <span class="n">IStartable</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">Startable1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Startable1 activated&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Startable1 started&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Startable2</span> <span class="p">:</span> <span class="n">IStartable</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">Startable2</span><span class="p">(</span><span class="n">Startable1</span> <span class="n">startable1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Startable2 activated&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Startable2 started&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Will output the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Startable1</span> <span class="n">activated</span>
<span class="n">Startable1</span> <span class="n">started</span>
<span class="n">Startable2</span> <span class="n">activated</span>
<span class="n">Startable2</span> <span class="n">started</span>
</pre></div>
</div>
</div>
<div class="section" id="auto-activated-components">
<h4><a class="toc-backref" href="#id2">Auto-Activated Components</a><a class="headerlink" href="#auto-activated-components" title="Permalink to this headline">¶</a></h4>
<p>An <strong>auto-activated component</strong> is a component that simply needs to be activated one time when the container is built. This is a “warm start” style of behavior where no method on the component is called and no interface needs to be implemented - a single instance of the component will be resolved with no reference to the instance held.</p>
<p>To register an auto-activated component, use the <code class="docutils literal notranslate"><span class="pre">AutoActivate()</span></code> registration extension.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span>
   <span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TypeRequiringWarmStart</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">AsSelf</span><span class="p">()</span>
   <span class="p">.</span><span class="n">AutoActivate</span><span class="p">();</span>
</pre></div>
</div>
<p>Note: If you <em>omit</em> the <code class="docutils literal notranslate"><span class="pre">AsSelf()</span></code> or <code class="docutils literal notranslate"><span class="pre">As&lt;T&gt;()</span></code> service registration calls when you register an <code class="docutils literal notranslate"><span class="pre">AutoActivate()</span></code> component, the component will <em>only</em> be registered to auto-activate and won’t necessarily be resolvable “as itself” after container build.</p>
</div>
<div class="section" id="container-build-callbacks">
<h4><a class="toc-backref" href="#id3">Container Build Callbacks</a><a class="headerlink" href="#container-build-callbacks" title="Permalink to this headline">¶</a></h4>
<p>You can register any arbitrary action to happen at container build time by registering a build callback. A build callback is an <code class="docutils literal notranslate"><span class="pre">Action&lt;IContainer&gt;</span></code> and will get the built container prior to that container being returned from <code class="docutils literal notranslate"><span class="pre">ContainerBuilder.Build</span></code>. Build callbacks execute in the order they are registered:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span>
   <span class="p">.</span><span class="n">RegisterBuildCallback</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">DbContext</span><span class="p">&gt;());</span>

<span class="c1">// The callback will run after the container is built</span>
<span class="c1">// but before it&#39;s returned.</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>You can use build callbacks as another way to automatically start/warm up an object on container build. Do that by using them in conjunction with <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">the lifetime event OnActivated</span></a> and <code class="docutils literal notranslate"><span class="pre">SingleInstance</span></code> registrations.</p>
<p>A long/contrived example in unit test form:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">TestClass</span>
<span class="p">{</span>
  <span class="c1">// Create a dependency chain like</span>
  <span class="c1">//    ==&gt; 2 ==+</span>
  <span class="c1">// 4 =+       ==&gt; 1</span>
  <span class="c1">//    ==&gt; 3 ==+</span>
  <span class="c1">// 4 needs 2 and 3</span>
  <span class="c1">// 2 needs 1</span>
  <span class="c1">// 3 needs 1</span>
  <span class="c1">// Dependencies should start up in the order</span>
  <span class="c1">// 1, 2, 3, 4</span>
  <span class="c1">// or</span>
  <span class="c1">// 1, 3, 2, 4</span>
  <span class="k">private</span> <span class="k">class</span> <span class="nc">Dependency1</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="nf">Dependency1</span><span class="p">(</span><span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency1.ctor&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">Dependency2</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Dependency2</span><span class="p">(</span><span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dependency1</span> <span class="n">dependency</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
      <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency2.ctor&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency2.Initialize&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">Dependency3</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Dependency3</span><span class="p">(</span><span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dependency1</span> <span class="n">dependency</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
      <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency3.ctor&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency3.Initialize&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">Dependency4</span>
  <span class="p">{</span>
    <span class="k">private</span> <span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Dependency4</span><span class="p">(</span><span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dependency2</span> <span class="n">dependency2</span><span class="p">,</span> <span class="n">Dependency3</span> <span class="n">dependency3</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
      <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency4.ctor&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Dependency4.Initialize&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Xunit passes this to the ctor of the test class</span>
  <span class="c1">// so we can capture console output.</span>
  <span class="k">private</span> <span class="n">ITestOutputHelper</span> <span class="n">_output</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">TestClass</span><span class="p">(</span><span class="n">ITestOutputHelper</span> <span class="n">output</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
  <span class="p">}</span>

<span class="na">  [Fact]</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">OnActivatedDependencyChain</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_output</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ITestOutputHelper</span><span class="p">&gt;();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Dependency1</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>

    <span class="c1">// The OnActivated replaces the need for IStartable. When an instance</span>
    <span class="c1">// is activated/created, it&#39;ll run the Initialize method as specified. Using</span>
    <span class="c1">// SingleInstance means that only happens once.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Dependency2</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">().</span><span class="n">OnActivated</span><span class="p">(</span><span class="n">args</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">Initialize</span><span class="p">());</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Dependency3</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">().</span><span class="n">OnActivated</span><span class="p">(</span><span class="n">args</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">Initialize</span><span class="p">());</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Dependency4</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">().</span><span class="n">OnActivated</span><span class="p">(</span><span class="n">args</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">Initialize</span><span class="p">());</span>

    <span class="c1">// Notice these aren&#39;t in dependency order.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterBuildCallback</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency4</span><span class="p">&gt;());</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterBuildCallback</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency2</span><span class="p">&gt;());</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterBuildCallback</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency1</span><span class="p">&gt;());</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterBuildCallback</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency3</span><span class="p">&gt;());</span>

    <span class="c1">// This will run the build callbacks.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="c1">// These effectively do NOTHING. OnActivated won&#39;t be called again</span>
    <span class="c1">// because they&#39;re SingleInstance.</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency1</span><span class="p">&gt;();</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency2</span><span class="p">&gt;();</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency3</span><span class="p">&gt;();</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Dependency4</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This sample unit test will generate this output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Dependency1</span><span class="o">.</span><span class="n">ctor</span>
<span class="n">Dependency2</span><span class="o">.</span><span class="n">ctor</span>
<span class="n">Dependency3</span><span class="o">.</span><span class="n">ctor</span>
<span class="n">Dependency4</span><span class="o">.</span><span class="n">ctor</span>
<span class="n">Dependency2</span><span class="o">.</span><span class="n">Initialize</span>
<span class="n">Dependency3</span><span class="o">.</span><span class="n">Initialize</span>
<span class="n">Dependency4</span><span class="o">.</span><span class="n">Initialize</span>
</pre></div>
</div>
<p>You’ll see from the output that the callbacks and <code class="docutils literal notranslate"><span class="pre">OnActivated</span></code> methods executed in dependency order. If you must have the activations <em>and</em> the startups all happen in dependency order (not just the activations/resolutions), this is the workaround.</p>
<p>Note if you don’t use <code class="docutils literal notranslate"><span class="pre">SingleInstance</span></code> then <code class="docutils literal notranslate"><span class="pre">OnActivated</span></code> will be called for <em>every new instance of the dependency</em>. Since “warm start” objects are usually singletons and are expensive to create, this is generally what you want anyway.</p>
</div>
<div class="section" id="tips">
<h4><a class="toc-backref" href="#id4">Tips</a><a class="headerlink" href="#tips" title="Permalink to this headline">¶</a></h4>
<p><strong>Order</strong>: In general, startup logic happens in the order <code class="docutils literal notranslate"><span class="pre">IStartable.Start()</span></code>, <code class="docutils literal notranslate"><span class="pre">AutoActivate</span></code>, build callbacks. That said, it is <em>not guaranteed</em>. For example, as noted in the <code class="docutils literal notranslate"><span class="pre">IStartable</span></code> docs above, things will happen in dependency order rather than registration order. Further, Autofac reserves the right to change this order (e.g., refactor the calls to <code class="docutils literal notranslate"><span class="pre">IStartable.Start()</span></code> and <code class="docutils literal notranslate"><span class="pre">AutoActivate</span></code> into build callbacks). If you need to control the specific order in which initialization logic runs, it’s better to write your own initialization logic where you can control the order.</p>
<p><strong>Avoid creating lifetime scopes during IStartable.Start or AutoActivate</strong>: If your startup logic includes the creation of a lifetime scope from which components will be resolved, this scope won’t have all the startables executed yet. By creating the scope, you’re forcing a race condition. This sort of logic would be better to execute in custom logic after the container is built rather than as part of an <code class="docutils literal notranslate"><span class="pre">IStartable</span></code>.</p>
<p><strong>Avoid overusing startup logic</strong>: The ability to run startup logic on container build may feel like it’s also a good fit for orchestrating general application startup logic. Given the ordering and other challenges you may run into, it is recommended you keep <em>application startup</em> logic separate from <em>dependency startup</em> logic.</p>
<p><strong>Consider OnActivated and SingleInstance for lazy initialization</strong>: Instead of using build callbacks or startup logic, consider using <a class="reference internal" href="index.html#document-lifetime/events"><span class="doc">the lifetime event OnActivated</span></a> with a <code class="docutils literal notranslate"><span class="pre">SingleInstance</span></code> registration so the initialization can happen on an object but not be tied to the order of container build.</p>
</div>
</div>
</div>
</div>
<span id="document-configuration/index"></span><div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-configuration/xml"></span><div class="section" id="json-xml-configuration">
<h3>JSON/XML Configuration<a class="headerlink" href="#json-xml-configuration" title="Permalink to this headline">¶</a></h3>
<p>Most IoC containers provide a programmatic interface as well as JSON/XML file-based configuration support, and Autofac is no exception.</p>
<p>Autofac encourages programmatic configuration through the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> class. Using the programmatic interface is central to the design of the container. JSON or XML is recommended when concrete classes cannot be chosen or configured at compile-time.</p>
<p>Before diving too deeply into JSON/XML configuration, be sure to read <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Modules</span></a> - this explains how to handle more complex scenarios than the basic JSON/XML component registration will allow. Configuration in JSON/XML is not a feature-for-feature replacement for programmatic configuration, so complex scenarios may require a combination of JSON/XML and modules.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#configuring-with-microsoft-configuration-4-0" id="id4">Configuring With Microsoft Configuration (4.0+)</a><ul>
<li><a class="reference internal" href="#quick-start" id="id5">Quick Start</a></li>
<li><a class="reference internal" href="#default-assembly" id="id6">Default Assembly</a></li>
<li><a class="reference internal" href="#components" id="id7">Components</a></li>
<li><a class="reference internal" href="#modules" id="id8">Modules</a></li>
<li><a class="reference internal" href="#type-names" id="id9">Type Names</a></li>
<li><a class="reference internal" href="#differences-from-legacy-configuration" id="id10">Differences from Legacy Configuration</a></li>
<li><a class="reference internal" href="#additional-tips" id="id11">Additional Tips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuring-with-application-configuration-legacy-pre-4-0" id="id12">Configuring With Application Configuration (Legacy Pre-4.0)</a><ul>
<li><a class="reference internal" href="#setup" id="id13">Setup</a></li>
<li><a class="reference internal" href="#id2" id="id14">Components</a></li>
<li><a class="reference internal" href="#id3" id="id15">Modules</a></li>
<li><a class="reference internal" href="#additional-config-files" id="id16">Additional Config Files</a></li>
<li><a class="reference internal" href="#configuring-the-container" id="id17">Configuring the Container</a></li>
<li><a class="reference internal" href="#multiple-files-or-sections" id="id18">Multiple Files or Sections</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="configuring-with-microsoft-configuration-4-0">
<h4><a class="toc-backref" href="#id4">Configuring With Microsoft Configuration (4.0+)</a><a class="headerlink" href="#configuring-with-microsoft-configuration-4-0" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Microsoft Configuration applies to the 4.0+ version of Autofac.Configuration. It does not work with previous versions of the configuration package.</p>
</div>
<p>With the release of <a class="reference external" href="https://www.nuget.org/packages/Microsoft.Extensions.Configuration">Microsoft.Extensions.Configuration</a>, and Autofac.Configuration 4.0.0, Autofac takes advantage of the more flexible configuration model not previously available when limited to application configuration files. If you were using the <code class="docutils literal notranslate"><span class="pre">app.config</span></code> or <code class="docutils literal notranslate"><span class="pre">web.config</span></code> based configuration available before, you will need to migrate your configuration to the new format and update the way you set configuration with your application container.</p>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id5">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>The basic steps to getting configuration set up with your application are:</p>
<ol class="arabic simple">
<li>Set up your configuration in JSON or XML files that can be read by <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code>.<ul>
<li>JSON configuration uses <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.Json</span></code></li>
<li>XML configuration uses <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.Xml</span></code></li>
</ul>
</li>
<li>Build the configuration using the <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.ConfigurationBuilder</span></code>.</li>
<li>Create a new <code class="docutils literal notranslate"><span class="pre">Autofac.Configuration.ConfigurationModule</span></code> and pass the built <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.IConfiguration</span></code> into it.</li>
<li>Register the <code class="docutils literal notranslate"><span class="pre">Autofac.Configuration.ConfigurationModule</span></code> with your container.</li>
</ol>
<p>A configuration file with some simple registrations looks like this:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;defaultAssembly&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator&quot;</span><span class="p">,</span>
  <span class="nt">&quot;components&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span>
    <span class="p">}],</span>
    <span class="nt">&quot;injectProperties&quot;</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Division.Divide, Autofac.Example.Calculator.Division&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span>
    <span class="p">}],</span>
    <span class="nt">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;places&quot;</span><span class="p">:</span> <span class="mi">4</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>JSON is cleaner and easier to read, but if you prefer XML, the same configuration looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span>
<span class="nt">&lt;autofac</span> <span class="na">defaultAssembly=</span><span class="s">&quot;Autofac.Example.Calculator&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;components</span> <span class="na">name=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;type&gt;</span>Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition<span class="nt">&lt;/type&gt;</span>
        <span class="nt">&lt;services</span> <span class="na">name=</span><span class="s">&quot;0&quot;</span> <span class="na">type=</span><span class="s">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;injectProperties&gt;</span>true<span class="nt">&lt;/injectProperties&gt;</span>
    <span class="nt">&lt;/components&gt;</span>
    <span class="nt">&lt;components</span> <span class="na">name=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;type&gt;</span>Autofac.Example.Calculator.Division.Divide, Autofac.Example.Calculator.Division<span class="nt">&lt;/type&gt;</span>
        <span class="nt">&lt;services</span> <span class="na">name=</span><span class="s">&quot;0&quot;</span> <span class="na">type=</span><span class="s">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;injectProperties&gt;</span>true<span class="nt">&lt;/injectProperties&gt;</span>
        <span class="nt">&lt;parameters&gt;</span>
            <span class="nt">&lt;places&gt;</span>4<span class="nt">&lt;/places&gt;</span>
        <span class="nt">&lt;/parameters&gt;</span>
    <span class="nt">&lt;/components&gt;</span>
<span class="nt">&lt;/autofac&gt;</span>
</pre></div>
</div>
<p><em>Note the ordinal “naming” of components and services in XML - this is due to the way Microsoft.Extensions.Configuration handles ordinal collections (arrays).</em></p>
<p>Build up your configuration and register it with the Autofac <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add the configuration to the ConfigurationBuilder.</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConfigurationBuilder</span><span class="p">();</span>
<span class="c1">// config.AddJsonFile comes from Microsoft.Extensions.Configuration.Json</span>
<span class="c1">// config.AddXmlFile comes from Microsoft.Extensions.Configuration.Xml</span>
<span class="n">config</span><span class="p">.</span><span class="n">AddJsonFile</span><span class="p">(</span><span class="s">&quot;autofac.json&quot;</span><span class="p">);</span>

<span class="c1">// Register the ConfigurationModule with Autofac.</span>
<span class="kt">var</span> <span class="n">module</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConfigurationModule</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="default-assembly">
<h5><a class="toc-backref" href="#id6">Default Assembly</a><a class="headerlink" href="#default-assembly" title="Permalink to this headline">¶</a></h5>
<p>You can specify a “default assembly” option in the configuration to help write types in a shorter fashion. If you don’t specify an assembly-qualified type name in a type or interface reference, it will be assumed to be in the default assembly.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;defaultAssembly&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="components">
<h5><a class="toc-backref" href="#id7">Components</a><a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h5>
<p>Components are the most common thing that you’ll register. You can specify several things on each component from lifetime scope to parameters.</p>
<p>Components are added to a top-level <code class="docutils literal notranslate"><span class="pre">components</span></code> element in configuration. Inside that is an array of the components you want to register.</p>
<p>This example shows one component that has <em>all of the options</em> on it, just for syntax illustration purposes. You wouldn’t actually use every one of these in every component registration.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;components&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span>
    <span class="p">},</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.Api.IAddOperation&quot;</span><span class="p">,</span>
      <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;add&quot;</span>
    <span class="p">}],</span>
    <span class="nt">&quot;autoActivate&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;injectProperties&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;instanceScope&quot;</span><span class="p">:</span> <span class="s2">&quot;per-dependency&quot;</span><span class="p">,</span>
    <span class="nt">&quot;metadata&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;answer&quot;</span><span class="p">,</span>
      <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;System.Int32, mscorlib&quot;</span>
    <span class="p">}],</span>
    <span class="nt">&quot;ownership&quot;</span><span class="p">:</span> <span class="s2">&quot;external&quot;</span><span class="p">,</span>
    <span class="nt">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;places&quot;</span><span class="p">:</span> <span class="mi">4</span>
    <span class="p">},</span>
    <span class="nt">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;DictionaryProp&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span>
      <span class="p">},</span>
      <span class="nt">&quot;ListProp&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="61%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Element Name</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">type</span></code></td>
<td>The only required thing. The concrete class of the component (assembly-qualified if in an assembly other than the default).</td>
<td>Any .NET type name that can be created through reflection.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">services</span></code></td>
<td>An array of <a class="reference internal" href="index.html#document-register/registration"><span class="doc">services exposed by the component</span></a>. Each service must have a <code class="docutils literal notranslate"><span class="pre">type</span></code> and may optionally specify a <code class="docutils literal notranslate"><span class="pre">key</span></code>.</td>
<td>Any .NET type name that can be created through reflection.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">autoActivate</span></code></td>
<td>A Boolean indicating if the component should <a class="reference internal" href="index.html#document-lifetime/startup"><span class="doc">auto-activate</span></a>.</td>
<td><code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">injectProperties</span></code></td>
<td>A Boolean indicating whether <a class="reference internal" href="index.html#document-register/prop-method-injection"><span class="doc">property (setter) injection</span></a> for the component should be enabled.</td>
<td><code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">instanceScope</span></code></td>
<td><a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">Instance scope</span></a> for the component.</td>
<td><code class="docutils literal notranslate"><span class="pre">singleinstance</span></code>, <code class="docutils literal notranslate"><span class="pre">perlifetimescope</span></code>, <code class="docutils literal notranslate"><span class="pre">perdependency</span></code>, <code class="docutils literal notranslate"><span class="pre">perrequest</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">metadata</span></code></td>
<td>An array of <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">metadata values</span></a> to associate with the component. Each item specifies the <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, and <code class="docutils literal notranslate"><span class="pre">value</span></code>.</td>
<td>Any <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">metadata values</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ownership</span></code></td>
<td>Allows you to control <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">whether the lifetime scope disposes the component or your code does</span></a>.</td>
<td><code class="docutils literal notranslate"><span class="pre">lifetimescope</span></code>, <code class="docutils literal notranslate"><span class="pre">external</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">parameters</span></code></td>
<td>A name/value dictionary where the name of each element is the name of a constructor parameter and the value is the value to inject.</td>
<td>Any parameter in the constructor of the component type.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">properties</span></code></td>
<td>A name/value dictionary where the name of each element is the name of a property and the value is the value to inject.</td>
<td>Any settable property on the component type.</td>
</tr>
</tbody>
</table>
<p>Note that both <code class="docutils literal notranslate"><span class="pre">parameters</span></code> and <code class="docutils literal notranslate"><span class="pre">properties</span></code> support dictionary and enumerable values. You can see an example of how to specify those in the JSON structure, above.</p>
</div>
<div class="section" id="modules">
<h5><a class="toc-backref" href="#id8">Modules</a><a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h5>
<p>When using <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">modules</span></a> with Autofac, you can register those modules along with components when using configuration.</p>
<p>Modules are added to a top-level <code class="docutils literal notranslate"><span class="pre">modules</span></code> element in configuration. Inside that is an array of the modules you want to register.</p>
<p>This example shows one module that has <em>all of the options</em> on it, just for syntax illustration purposes. You wouldn’t actually use every one of these in every module registration.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;modules&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Autofac.Example.Calculator.OperationModule, Autofac.Example.Calculator&quot;</span><span class="p">,</span>
    <span class="nt">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;places&quot;</span><span class="p">:</span> <span class="mi">4</span>
    <span class="p">},</span>
    <span class="nt">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;DictionaryProp&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span>
      <span class="p">},</span>
      <span class="nt">&quot;ListProp&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="56%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Element Name</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">type</span></code></td>
<td>The only required thing. The concrete class of the module (assembly-qualified if in an assembly other than the default).</td>
<td>Any .NET type name that derives from <code class="docutils literal notranslate"><span class="pre">Autofac.Module</span></code> that can be created through reflection.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">parameters</span></code></td>
<td>A name/value dictionary where the name of each element is the name of a constructor parameter and the value is the value to inject.</td>
<td>Any parameter in the constructor of the module type.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">properties</span></code></td>
<td>A name/value dictionary where the name of each element is the name of a property and the value is the value to inject.</td>
<td>Any settable property on the module type.</td>
</tr>
</tbody>
</table>
<p>Note that both <code class="docutils literal notranslate"><span class="pre">parameters</span></code> and <code class="docutils literal notranslate"><span class="pre">properties</span></code> support dictionary and enumerable values. You can see an example of how to specify those in the JSON structure, above.</p>
<p>You are allowed to register <em>the same module multiple times using different parameter/property sets</em> if you so choose.</p>
</div>
<div class="section" id="type-names">
<h5><a class="toc-backref" href="#id9">Type Names</a><a class="headerlink" href="#type-names" title="Permalink to this headline">¶</a></h5>
<p>In all cases where you see a type name (component type, service types, module type) it is expected to be <a class="reference external" href="https://msdn.microsoft.com/en-us/library/yfsftwz6(v=vs.110).aspx">the standard, assembly qualified type name</a> that you would normally be able to pass to <code class="docutils literal notranslate"><span class="pre">Type.GetType(string</span> <span class="pre">typename)</span></code>. If the type is in the <code class="docutils literal notranslate"><span class="pre">defaultAssembly</span></code> you can leave the assembly name off, but it doens’t hurt to put it there regardless.</p>
<p>Assembly qualified type names have the full type with namespace, a comma, and the name of the assembly, like <code class="docutils literal notranslate"><span class="pre">Autofac.Example.Calculator.OperationModule,</span> <span class="pre">Autofac.Example.Calculator</span></code>. In that case, <code class="docutils literal notranslate"><span class="pre">Autofac.Example.Calculator.OperationModule</span></code> is the type and it’s in the <code class="docutils literal notranslate"><span class="pre">Autofac.Example.Calculator</span></code> assembly.</p>
<p>Generics are a little more complicated. Configuration does not support open generics so you have to specify the fully qualified name of each of the generic parameters, too.</p>
<p>For example, say you have a repository <code class="docutils literal notranslate"><span class="pre">IRepository&lt;T&gt;</span></code> in a <code class="docutils literal notranslate"><span class="pre">ConfigWithGenericsDemo</span></code> assembly. Let’s also say you have a class <code class="docutils literal notranslate"><span class="pre">StringRepository</span></code> that implements <code class="docutils literal notranslate"><span class="pre">IRepository&lt;string&gt;</span></code>. To register that in configuration, it would look like this:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;components&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ConfigWithGenericsDemo.StringRepository, ConfigWithGenericsDemo&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ConfigWithGenericsDemo.IRepository`1[[System.String, mscorlib]], ConfigWithGenericsDemo&quot;</span>
    <span class="p">}]</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you’re having a difficult time figuring out what your type name is, you can always do something like this in code:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Write the type name to the Debug output window and</span>
<span class="c1">// copy/paste it out of there into your config.</span>
<span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;).</span><span class="n">AssemblyQualifiedName</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="differences-from-legacy-configuration">
<h5><a class="toc-backref" href="#id10">Differences from Legacy Configuration</a><a class="headerlink" href="#differences-from-legacy-configuration" title="Permalink to this headline">¶</a></h5>
<p>When migrating from the legacy (pre 4.0 version) <code class="docutils literal notranslate"><span class="pre">app.config</span></code> based format to the new format, there are some key changes to be aware of:</p>
<ul class="simple">
<li><strong>There is no ConfigurationSettingsReader.</strong> <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> has entirely replaced the old XML format configuration. The legacy configuration documentation does not apply to the 4.0+ series of configuration package.</li>
<li><strong>Multiple configuration files handled differently.</strong> The legacy configuration had a <code class="docutils literal notranslate"><span class="pre">files</span></code> element that would automatically pull several files together at once for configuration. Use the <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.ConfigurationBuilder</span></code> to accomplish this now.</li>
<li><strong>AutoActivate is supported.</strong> You can specify <a class="reference internal" href="index.html#document-lifetime/startup"><span class="doc">components should auto-activate</span></a> now, a feature previously unavailable in configuration.</li>
<li><strong>XML uses element children rather than attributes.</strong> This helps keep the XML and JSON parsing the same when using <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> so you can combine XML and JSON configuration sources correctly.</li>
<li><strong>Using XML requires you to name components and services with numbers.</strong> <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> requires every configuration item to have a name and a value. The way it supports ordinal collections (arrays) is that it implicitly gives unnamed elements in a collection names with numbers (“0”, “1”, and so on). You can see an example of this in the quick start, above. If you don’t go with JSON, you need to watch for this requirement from <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> or you won’t get what you expect.</li>
<li><strong>Per-request lifetime scope is supported.</strong> Previously you couldn’t configure elements to have <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">per-request lifetime scope</span></a>. Now you can.</li>
<li><strong>Dashes in names/values are gone.</strong> Names of XML elements used to include dashes like <code class="docutils literal notranslate"><span class="pre">inject-properties</span></code> - to work with the JSON configuration format, these are now camel-case, like <code class="docutils literal notranslate"><span class="pre">injectProperties</span></code>.</li>
<li><strong>Services get specified in a child element.</strong> The legacy configuration allowed a service to be declared right at the top of the component. The new system requires all services be in the <code class="docutils literal notranslate"><span class="pre">services</span></code> collection.</li>
</ul>
</div>
<div class="section" id="additional-tips">
<h5><a class="toc-backref" href="#id11">Additional Tips</a><a class="headerlink" href="#additional-tips" title="Permalink to this headline">¶</a></h5>
<p>The new <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> mechanism adds a lot of flexibility. Things you may want to take advantage of:</p>
<ul class="simple">
<li><strong>Environment variable support.</strong> You can use <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.EnvironmentVariables</span></code> to enable configuration changes based on the environment. A quick way to debug, patch, or fix something without touching code might be to switch an Autofac registration based on environment.</li>
<li><strong>Easy configuration merging.</strong> The <code class="docutils literal notranslate"><span class="pre">ConfigurationBuilder</span></code> allows you to create configuration from a lot of sources and merge them into one. If you have a lot of configuration, consider scanning for your configuration files and building the configuration dynamically rather than hardcoding paths.</li>
<li><strong>Custom configuration sources.</strong> You can implement <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration.ConfigurationProvider</span></code> yourself backed by more than just files. If you want to centralize configuration, consider a database or REST API backed configuration source.</li>
</ul>
</div>
</div>
<div class="section" id="configuring-with-application-configuration-legacy-pre-4-0">
<h4><a class="toc-backref" href="#id12">Configuring With Application Configuration (Legacy Pre-4.0)</a><a class="headerlink" href="#configuring-with-application-configuration-legacy-pre-4-0" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Legacy application configuration as described below applies to the 3.x and earlier versions of Autofac.Configuration. It does not work with the 4.0+ version of the package.</p>
</div>
<p>Prior to the release of <a class="reference external" href="https://www.nuget.org/packages/Microsoft.Extensions.Configuration">Microsoft.Extensions.Configuration</a> and the updated configuration model, Autofac tied into standard .NET application configuration files. (<code class="docutils literal notranslate"><span class="pre">app.config</span></code> / <code class="docutils literal notranslate"><span class="pre">web.config</span></code>). In the 3.x series of the Autofac.Configuration package, this was the way to configure things.</p>
<div class="section" id="setup">
<h5><a class="toc-backref" href="#id13">Setup</a><a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h5>
<p>Using the legacy configuration mechanism, you need to declare a section handler somewhere near the top of your config file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;configuration&gt;
    &lt;configSections&gt;
        &lt;section name=&quot;autofac&quot; type=&quot;Autofac.Configuration.SectionHandler, Autofac.Configuration&quot;/&gt;
    &lt;/configSections&gt;
</pre></div>
</div>
<p>Then, provide a section describing your components:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">autofac</span> <span class="n">defaultAssembly</span><span class="o">=</span><span class="s2">&quot;Autofac.Example.Calculator.Api&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">components</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">component</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition&quot;</span>
            <span class="n">service</span><span class="o">=</span><span class="s2">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span> <span class="o">/&gt;</span>

        <span class="o">&lt;</span><span class="n">component</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Autofac.Example.Calculator.Division.Divide, Autofac.Example.Calculator.Division&quot;</span>
            <span class="n">service</span><span class="o">=</span><span class="s2">&quot;Autofac.Example.Calculator.Api.IOperation&quot;</span> <span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="n">parameter</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;places&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;4&quot;</span> <span class="o">/&gt;</span>
            <span class="o">&lt;/</span><span class="n">parameters</span><span class="o">&gt;</span>
        <span class="o">&lt;/</span><span class="n">component</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">defaultAssembly</span></code> attribute is optional, allowing namespace-qualified rather than fully-qualified type names to be used. This can save some clutter and typing, especially if you use one configuration file per assembly (see Additional Config Files below.)</p>
</div>
<div class="section" id="id2">
<h5><a class="toc-backref" href="#id14">Components</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>Components are the most common thing that you’ll register. You can specify several things on each component from lifetime scope to parameters.</p>
<div class="section" id="component-attributes">
<h6>Component Attributes<a class="headerlink" href="#component-attributes" title="Permalink to this headline">¶</a></h6>
<p>The following can be used as attributes on the <code class="docutils literal notranslate"><span class="pre">component</span></code> element (defaults are the same as for the programmatic API):</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="59%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute Name</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">type</span></code></td>
<td>The only required attribute. The concrete class of the component (assembly-qualified if in an assembly other than the default.)</td>
<td>Any .NET type name that can be created through reflection.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">service</span></code></td>
<td>A service exposed by the component. For more than one service, use the nested <code class="docutils literal notranslate"><span class="pre">services</span></code> element.</td>
<td>As for <code class="docutils literal notranslate"><span class="pre">type</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">instance-scope</span></code></td>
<td>Instance scope - see <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">Instance Scope</span></a>.</td>
<td><code class="docutils literal notranslate"><span class="pre">per-dependency</span></code>, <code class="docutils literal notranslate"><span class="pre">single-instance</span></code> or <code class="docutils literal notranslate"><span class="pre">per-lifetime-scope</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">instance-ownership</span></code></td>
<td>Container’s ownership over the instances - see the <code class="docutils literal notranslate"><span class="pre">InstanceOwnership</span></code> enumeration.</td>
<td><code class="docutils literal notranslate"><span class="pre">lifetime-scope</span></code> or <code class="docutils literal notranslate"><span class="pre">external</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">name</span></code></td>
<td>A string name for the component.</td>
<td>Any non-empty string value.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">inject-properties</span></code></td>
<td>Enable property (setter) injection for the component.</td>
<td><code class="docutils literal notranslate"><span class="pre">yes</span></code>, <code class="docutils literal notranslate"><span class="pre">no</span></code>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="component-child-elements">
<h6>Component Child Elements<a class="headerlink" href="#component-child-elements" title="Permalink to this headline">¶</a></h6>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Element</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">services</span></code></td>
<td>A list of <code class="docutils literal notranslate"><span class="pre">service</span></code> elements, whose element content contains the names of types exposed as services by the component (see the <code class="docutils literal notranslate"><span class="pre">service</span></code> attribute.)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">parameters</span></code></td>
<td>A list of explicit constructor parameters to set on the instances (see example above.)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">properties</span></code></td>
<td>A list of explicit property values to set (syntax as for <code class="docutils literal notranslate"><span class="pre">parameters</span></code>.)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">metadata</span></code></td>
<td>A list of <code class="docutils literal notranslate"><span class="pre">item</span></code> nodes with <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span></code> attributes.</td>
</tr>
</tbody>
</table>
<p>There are some features missing from the XML configuration syntax that are available through the programmatic API - for example registration of generics. Using modules is recommended in these cases.</p>
</div>
</div>
<div class="section" id="id3">
<h5><a class="toc-backref" href="#id15">Modules</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>Configuring the container using components is very fine-grained and can get verbose quickly. Autofac has support for packaging components into <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Modules</span></a> in order to encapsulate implementation while providing flexible configuration.</p>
<p>Modules are registered by type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">modules</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">module</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;MyModule&quot;</span> <span class="o">/&gt;</span>
</pre></div>
</div>
<p>You can add nested <code class="docutils literal notranslate"><span class="pre">parameters</span></code> and <code class="docutils literal notranslate"><span class="pre">properties</span></code> to a module registration in the same manner as for components above.</p>
</div>
<div class="section" id="additional-config-files">
<h5><a class="toc-backref" href="#id16">Additional Config Files</a><a class="headerlink" href="#additional-config-files" title="Permalink to this headline">¶</a></h5>
<p>You can include additional config files using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">files</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">file</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Controllers.config&quot;</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;controllers&quot;</span> <span class="o">/&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-the-container">
<h5><a class="toc-backref" href="#id17">Configuring the Container</a><a class="headerlink" href="#configuring-the-container" title="Permalink to this headline">¶</a></h5>
<p>First, you must <strong>reference Autofac.Configuration.dll in from your project</strong>.</p>
<p>To configure the container use a <code class="docutils literal notranslate"><span class="pre">ConfigurationSettingsReader</span></code> initialised with the name you gave to your XML configuration section:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">ConfigurationSettingsReader</span><span class="p">(</span><span class="s">&quot;mycomponents&quot;</span><span class="p">));</span>
<span class="c1">// Register other components and call Build() to create the container.</span>
</pre></div>
</div>
<p>The container settings reader will override default components already registered; you can write your application so that it will run with sensible defaults and then override only those component registrations necessary for a particular deployment.</p>
</div>
<div class="section" id="multiple-files-or-sections">
<h5><a class="toc-backref" href="#id18">Multiple Files or Sections</a><a class="headerlink" href="#multiple-files-or-sections" title="Permalink to this headline">¶</a></h5>
<p>You can use multiple settings readers in the same container, to read different sections or even different config files if the filename is supplied to the <code class="docutils literal notranslate"><span class="pre">ConfigurationSettingsReader</span></code> constructor.</p>
</div>
</div>
</div>
<span id="document-configuration/modules"></span><div class="section" id="modules">
<h3>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>IoC uses <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a> as the basic building blocks of an application. Providing access to the constructor parameters and properties of components is very commonly used as a means to achieve <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">deployment-time configuration</span></a>.</p>
<p>This is generally a dubious practice for the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Constructors can change</strong>: Changes to the constructor signature or properties of a component can break deployed <code class="docutils literal notranslate"><span class="pre">App.config</span></code> files - these problems can appear very late in the development process.</li>
<li><strong>JSON/XML gets hard to maintain</strong>: Configuration files for large numbers of components can become unwieldy to maintain.</li>
<li><strong>“Code” starts showing up in configuration</strong>: Exposing the properties and constructor parameters of classes is an unpleasant breach of the ‘encapsulation’ of the application’s internals - these details don’t belong in configuration files.</li>
</ul>
</div></blockquote>
<p>This is where modules can help.</p>
<p><strong>A module is a small class that can be used to bundle up a set of related components behind a ‘facade’ to simplify configuration and deployment.</strong> The module exposes a deliberate, restricted set of configuration parameters that can vary independently of the components used to implement the module.</p>
<p>The components within a module still make use dependencies at the component/service level to access components from other modules.</p>
<p><strong>Modules do not, themselves, go through dependency injection.</strong> They are used to configure the container, they are not actually registered and resolved like other components. If your module takes a constructor parameter, for example, you need to pass that in yourself. It won’t come from the container.</p>
</div>
<div class="section" id="advantages-of-modules">
<h4>Advantages of Modules<a class="headerlink" href="#advantages-of-modules" title="Permalink to this headline">¶</a></h4>
<div class="section" id="decreased-configuration-complexity">
<h5>Decreased Configuration Complexity<a class="headerlink" href="#decreased-configuration-complexity" title="Permalink to this headline">¶</a></h5>
<p>When configuring an application by IoC it is often necessary to set the parameters spread between multiple components. Modules group related configuration items into one place to reduce the burden of looking up the correct component for a setting.</p>
<p>The implementer of a module determines how the module’s configuration parameters map to the properties and constructor parameters of the components inside.</p>
</div>
<div class="section" id="configuration-parameters-are-explicit">
<h5>Configuration Parameters are Explicit<a class="headerlink" href="#configuration-parameters-are-explicit" title="Permalink to this headline">¶</a></h5>
<p>Configuring an application directly through its components creates a large surface area that will need to be considered when upgrading the application. When it is possible to set potentially any property of any class through a configuration file that will differ at every site, refactoring is no longer safe.</p>
<p>Creating modules limits the configuration parameters that a user can configure, and makes it explicit to the maintenance programmer which parameters these are.</p>
<p>You can also avoid a trade-off between what makes a good program element and what makes a good configuration parameter.</p>
</div>
<div class="section" id="abstraction-from-the-internal-application-architecture">
<h5>Abstraction from the Internal Application Architecture<a class="headerlink" href="#abstraction-from-the-internal-application-architecture" title="Permalink to this headline">¶</a></h5>
<p>Configuring an application through its components means that the configuration needs to differ depending on things like, for example, the use of an <code class="docutils literal notranslate"><span class="pre">enum</span></code> vs. creation of strategy classes. Using modules hides these details of the application’s structure, keeping configuration succinct.</p>
</div>
<div class="section" id="better-type-safety">
<h5>Better Type Safety<a class="headerlink" href="#better-type-safety" title="Permalink to this headline">¶</a></h5>
<p>A small reduction in type safety will always exist when the classes making up the application can vary based on deployment. Registering large numbers of components through XML configuration, however, exacerbates this problem.</p>
<p>Modules are constructed programmatically, so all of the component registration logic within them can be checked at compile time.</p>
</div>
<div class="section" id="dynamic-configuration">
<h5>Dynamic Configuration<a class="headerlink" href="#dynamic-configuration" title="Permalink to this headline">¶</a></h5>
<p>Configuring components within modules is dynamic: the behaviour of a module can vary based on the runtime environment. This is hard, if not impossible, with purely component-based configuration.</p>
</div>
<div class="section" id="advanced-extensions">
<h5>Advanced Extensions<a class="headerlink" href="#advanced-extensions" title="Permalink to this headline">¶</a></h5>
<p>Modules can be used for more than just simple type registrations - you can also attach to component resolution events and extend how parameters are resolved or perform other extensions. The <a class="reference internal" href="index.html#document-examples/log4net"><span class="doc">log4net integration module example</span></a> shows one such module.</p>
</div>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>In Autofac, modules implement the <code class="docutils literal notranslate"><span class="pre">Autofac.Core.IModule</span></code> interface. Generally they will derive from the <code class="docutils literal notranslate"><span class="pre">Autofac.Module</span></code> abstract class.</p>
<p>This module provides the <code class="docutils literal notranslate"><span class="pre">IVehicle</span></code> service:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CarTransportModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">bool</span> <span class="n">ObeySpeedLimit</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Car</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDriver</span><span class="p">&gt;())).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IVehicle</span><span class="p">&gt;();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ObeySpeedLimit</span><span class="p">)</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">SaneDriver</span><span class="p">()).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDriver</span><span class="p">&gt;();</span>
    <span class="k">else</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CrazyDriver</span><span class="p">()).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDriver</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="encapsulated-configuration">
<h5>Encapsulated Configuration<a class="headerlink" href="#encapsulated-configuration" title="Permalink to this headline">¶</a></h5>
<p>Our <code class="docutils literal notranslate"><span class="pre">CarTransportModule</span></code> provides the <code class="docutils literal notranslate"><span class="pre">ObeySpeedLimit</span></code> configuration parameter without exposing the fact that this is implemented by choosing between a sane or a crazy driver. Clients using the module can use it by declaring their intentions:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">CarTransportModule</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ObeySpeedLimit</span> <span class="p">=</span> <span class="k">true</span>
<span class="p">});</span>
</pre></div>
</div>
<p>or in <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">configuration format</span></a>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;modules&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;MyNamespace.CarTransportModule, MyAssembly&quot;</span><span class="p">,</span>
    <span class="nt">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;ObeySpeedLimit&quot;</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is valuable because the implementation of the module can vary without a flow on effect. That’s the idea of encapsulation, after all.</p>
</div>
<div class="section" id="flexibility-to-override">
<h5>Flexibility to Override<a class="headerlink" href="#flexibility-to-override" title="Permalink to this headline">¶</a></h5>
<p>Although clients of the <code class="docutils literal notranslate"><span class="pre">CarTransportModule</span></code> are probably primarily concerned with the <code class="docutils literal notranslate"><span class="pre">IVehicle</span></code> service, the module registers its <code class="docutils literal notranslate"><span class="pre">IDriver</span></code> dependency with the container as well. This ensures that the configuration is still able to be overridden at deployment time in the same way as if the components that make up the module had been registered independently.</p>
<p>It is a ‘best practice’ when using Autofac to add any XML configuration <em>after</em> programmatic configuration, e.g.:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">CarTransportModule</span><span class="p">());</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">ConfigurationSettingsReader</span><span class="p">());</span>
</pre></div>
</div>
<p>In this way, ‘emergency’ overrides can be made in <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">a configuration file</span></a>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;components&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;MyNamespace.LearnerDriver, MyAssembly&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;MyNamespace.IDriver, MyAssembly&quot;</span>
    <span class="p">}]</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So, modules increase encapsulation but don’t preclude you from tinkering with their innards if you have to.</p>
</div>
</div>
<div class="section" id="adapting-to-the-deployment-environment">
<h4>Adapting to the Deployment Environment<a class="headerlink" href="#adapting-to-the-deployment-environment" title="Permalink to this headline">¶</a></h4>
<p>Modules can be dynamic - that is, they can configure themselves to their execution environment.</p>
<p>When a module is loaded, it can do nifty things like check the environment:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">OSVersion</span><span class="p">.</span><span class="n">Platform</span> <span class="p">==</span> <span class="n">PlatformID</span><span class="p">.</span><span class="n">Unix</span><span class="p">)</span>
    <span class="n">RegisterUnixPathFormatter</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nf">RegisterWindowsPathFormatter</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="common-use-cases-for-modules">
<h4>Common Use Cases for Modules<a class="headerlink" href="#common-use-cases-for-modules" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>Configure related services that provide a subsystem, e.g. data access with NHibernate</li>
<li>Package optional application features as ‘plug-ins’</li>
<li>Provide pre-built packages for integration with a system, e.g. an accounting system</li>
<li>Register a number of similar services that are often used together, e.g. a set of file format converters</li>
<li>New or customised mechanisms for configuring the container, e.g. JSON/XML configuration is implemented using a module; configuration using attributes could be added this way</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
</div>
<span id="document-integration/index"></span><div class="section" id="application-integration">
<h2>Application Integration<a class="headerlink" href="#application-integration" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-integration/aspnet"></span><div class="section" id="asp-net">
<h3>ASP.NET<a class="headerlink" href="#asp-net" title="Permalink to this headline">¶</a></h3>
<p>Autofac offers integration into several ASP.NET application types. The integration libraries provide features like easy connection of your Autofac container to the application lifecycle as well as support for things like <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">per-request component lifetime</span></a>.</p>
<p><strong>These pages explain ASP.NET classic integration.</strong> If you are using ASP.NET Core, <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">see the ASP.NET Core integration page</span></a>.</p>
<div class="toctree-wrapper compound">
<span id="document-integration/owin"></span><div class="section" id="owin">
<h4>OWIN<a class="headerlink" href="#owin" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://owin.org/">OWIN (Open Web Interface for .NET)</a> is a simpler model for composing web-based applications without tying the application to the web server. To do this, a concept of “middleware” is used to create a pipeline through which requests travel.</p>
<p>Due to the differences in the way OWIN handles the application pipeline (detecting when a request starts/ends, etc.) integrating Autofac into an OWIN application is slightly different than the way it gets integrated into more “standard” ASP.NET apps. <a class="reference external" href="http://www.asp.net/aspnet/overview/owin-and-katana/an-overview-of-project-katana">You can read about OWIN and how it works on this overview.</a></p>
<p><strong>The important thing to remember is that order of OWIN middleware registration matters.</strong> Middleware gets processed in order of registration, like a chain, so you need to register foundational things (like Autofac middleware) first.</p>
<div class="section" id="quick-start">
<h5>Quick Start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To take advantage of Autofac in your OWIN pipeline:</p>
<ul class="simple">
<li>Reference the <code class="docutils literal notranslate"><span class="pre">Autofac.Owin</span></code> package from NuGet.</li>
<li>Build your Autofac container.</li>
<li>Register the Autofac middleware with OWIN and pass it the container.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configuration</span><span class="p">(</span><span class="n">IAppBuilder</span> <span class="n">app</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="c1">// Register dependencies, then...</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="c1">// Register the Autofac middleware FIRST. This also adds</span>
    <span class="c1">// Autofac-injected middleware registered with the container.</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMiddleware</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>

    <span class="c1">// ...then register your other middleware not registered</span>
    <span class="c1">// with Autofac.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Check out the individual <a class="reference internal" href="index.html#document-integration/aspnet"><span class="doc">ASP.NET integration library</span></a> pages for specific details on different app types and how they handle OWIN support.</p>
</div>
<div class="section" id="dependency-injection-in-middleware">
<h5>Dependency Injection in Middleware<a class="headerlink" href="#dependency-injection-in-middleware" title="Permalink to this headline">¶</a></h5>
<p>Normally when you register OWIN middleware with your application, you use the extension methods that come with the middleware. For example <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">Web API</span></a> has the <code class="docutils literal notranslate"><span class="pre">app.UseWebApi(config);</span></code> extension. Middleware registered in this fashion is statically defined and will not have dependencies injected.</p>
<p>For custom middleware, you can allow Autofac to inject dependencies into the middleware by registering it with your application container rather than registering it with a static extension.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyCustomMiddleware</span><span class="p">&gt;();</span>
<span class="c1">//...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// This will add the Autofac middleware as well as the middleware</span>
<span class="c1">// registered in the container.</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMiddleware</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
<p>When you call <code class="docutils literal notranslate"><span class="pre">app.UseAutofacMiddleware(container);</span></code> the Autofac middleware itself will be added to the pipeline, after which any <code class="docutils literal notranslate"><span class="pre">Microsoft.Owin.OwinMiddleware</span></code> classes registered with the container will also be added to the pipeline.</p>
<p>Middleware registered in this way will be resolved from the request lifetime scope for each request passing through the OWIN pipeline.</p>
</div>
<div class="section" id="controlling-middleware-order">
<h5>Controlling Middleware Order<a class="headerlink" href="#controlling-middleware-order" title="Permalink to this headline">¶</a></h5>
<p>For a simple scenario, <code class="docutils literal notranslate"><span class="pre">app.UseAutofacMiddleware(container);</span></code> will handle both adding an Autofac lifetime to the OWIN request scope as well as adding middleware that is registered with Autofac into the pipeline.</p>
<p>If you want more control over when DI-enabled middleware is added to the pipeline, you can use the <code class="docutils literal notranslate"><span class="pre">UseAutofacLifetimeScopeInjector</span></code> and <code class="docutils literal notranslate"><span class="pre">UseMiddlewareFromContainer</span></code> extensions.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyCustomMiddleware</span><span class="p">&gt;();</span>
<span class="c1">//...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// This adds ONLY the Autofac lifetime scope to the pipeline.</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseAutofacLifetimeScopeInjector</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>

<span class="c1">// Now you can add middleware from the container into the pipeline</span>
<span class="c1">// wherever you like. For example, this adds custom DI-enabled middleware</span>
<span class="c1">// AFTER the Web API middleware/handling.</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseWebApi</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseMiddlewareFromContainer</span><span class="p">&lt;</span><span class="n">MyCustomMiddleware</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h5>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>There is an example project showing Web API in conjunction with OWIN self hosting <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/WebApiExample.OwinSelfHost">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/mvc"></span><div class="section" id="mvc">
<h4>MVC<a class="headerlink" href="#mvc" title="Permalink to this headline">¶</a></h4>
<p>Autofac is always kept up to date to support the latest version of ASP.NET MVC, so documentation is also kept up with the latest. Generally speaking, the integration remains fairly consistent across versions.</p>
<p>MVC integration requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Mvc5/">Autofac.Mvc5 NuGet package</a>.</p>
<p>MVC integration provides dependency injection integration for controllers, model binders, action filters, and views. It also adds <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime support</span></a>.</p>
<p><strong>This page explains ASP.NET classic MVC integration.</strong> If you are using ASP.NET Core, <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">see the ASP.NET Core integration page</span></a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id2">Quick Start</a></li>
<li><a class="reference internal" href="#register-controllers" id="id3">Register Controllers</a></li>
<li><a class="reference internal" href="#set-the-dependency-resolver" id="id4">Set the Dependency Resolver</a></li>
<li><a class="reference internal" href="#register-model-binders" id="id5">Register Model Binders</a></li>
<li><a class="reference internal" href="#register-web-abstractions" id="id6">Register Web Abstractions</a></li>
<li><a class="reference internal" href="#enable-property-injection-for-view-pages" id="id7">Enable Property Injection for View Pages</a></li>
<li><a class="reference internal" href="#enable-property-injection-for-action-filters" id="id8">Enable Property Injection for Action Filters</a></li>
<li><a class="reference internal" href="#enable-injection-of-action-parameters" id="id9">Enable Injection of Action Parameters</a></li>
<li><a class="reference internal" href="#owin-integration" id="id10">OWIN Integration</a></li>
<li><a class="reference internal" href="#using-plugin-assemblies" id="id11">Using “Plugin” Assemblies</a></li>
<li><a class="reference internal" href="#using-the-current-autofac-dependencyresolver" id="id12">Using the Current Autofac DependencyResolver</a></li>
<li><a class="reference internal" href="#glimpse-integration" id="id13">Glimpse Integration</a></li>
<li><a class="reference internal" href="#unit-testing" id="id14">Unit Testing</a></li>
<li><a class="reference internal" href="#example" id="id15">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id2">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with MVC you need to reference the MVC integration NuGet package, register your controllers, and set the dependency resolver. You can optionally enable other features as well.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

  <span class="c1">// Register your MVC controllers. (MvcApplication is the name of</span>
  <span class="c1">// the class in Global.asax.)</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterControllers</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">MvcApplication</span><span class="p">).</span><span class="n">Assembly</span><span class="p">);</span>

  <span class="c1">// OPTIONAL: Register model binders that require DI.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModelBinders</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">MvcApplication</span><span class="p">).</span><span class="n">Assembly</span><span class="p">);</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModelBinderProvider</span><span class="p">();</span>

  <span class="c1">// OPTIONAL: Register web abstractions like HttpContextBase.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AutofacWebTypesModule</span><span class="p">&gt;();</span>

  <span class="c1">// OPTIONAL: Enable property injection in view pages.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterSource</span><span class="p">(</span><span class="k">new</span> <span class="n">ViewRegistrationSource</span><span class="p">());</span>

  <span class="c1">// OPTIONAL: Enable property injection into action filters.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterFilterProvider</span><span class="p">();</span>

  <span class="c1">// OPTIONAL: Enable action method parameter injection (RARE).</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">InjectActionInvoker</span><span class="p">();</span>

  <span class="c1">// Set the dependency resolver to be Autofac.</span>
  <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
  <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sections below go into further detail about what each of these features do and how to use them.</p>
</div>
<div class="section" id="register-controllers">
<h5><a class="toc-backref" href="#id3">Register Controllers</a><a class="headerlink" href="#register-controllers" title="Permalink to this headline">¶</a></h5>
<p>At application startup, while building your Autofac container, you should register your MVC controllers and their dependencies. This typically happens in an OWIN startup class or in the <code class="docutils literal notranslate"><span class="pre">Application_Start</span></code> method in <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// You can register controllers all at once using assembly scanning...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterControllers</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">MvcApplication</span><span class="p">).</span><span class="n">Assembly</span><span class="p">);</span>

<span class="c1">// ...or you can register individual controlllers manually.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HomeController</span><span class="p">&gt;().</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that ASP.NET MVC requests controllers by their concrete types, so registering them <code class="docutils literal notranslate"><span class="pre">As&lt;IController&gt;()</span></code> is incorrect. Also, if you register controllers manually and choose to specify lifetimes, you must register them as <code class="docutils literal notranslate"><span class="pre">InstancePerDependency()</span></code> or <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> - <strong>ASP.NET MVC will throw an exception if you try to reuse a controller instance for multiple requests</strong>.</p>
</div>
<div class="section" id="set-the-dependency-resolver">
<h5><a class="toc-backref" href="#id4">Set the Dependency Resolver</a><a class="headerlink" href="#set-the-dependency-resolver" title="Permalink to this headline">¶</a></h5>
<p>After building your container pass it into a new instance of the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> class. Use the static <code class="docutils literal notranslate"><span class="pre">DependencyResolver.SetResolver</span></code> method to let ASP.NET MVC know that it should locate services using the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code>. This is Autofac’s implementation of the <code class="docutils literal notranslate"><span class="pre">IDependencyResolver</span></code> interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="register-model-binders">
<h5><a class="toc-backref" href="#id5">Register Model Binders</a><a class="headerlink" href="#register-model-binders" title="Permalink to this headline">¶</a></h5>
<p>An optional step you can take is to enable dependency injection for model binders. Similar to controllers, model binders (classes that implement <code class="docutils literal notranslate"><span class="pre">IModelBinder</span></code>) can be registered in the container at application startup. You can do this with the <code class="docutils literal notranslate"><span class="pre">RegisterModelBinders()</span></code> method. You must also remember to register the <code class="docutils literal notranslate"><span class="pre">AutofacModelBinderProvider</span></code> using the <code class="docutils literal notranslate"><span class="pre">RegisterModelBinderProvider()</span></code> extension method. This is Autofac’s implementation of the <code class="docutils literal notranslate"><span class="pre">IModelBinderProvider</span></code> interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterModelBinders</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModelBinderProvider</span><span class="p">();</span>
</pre></div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">RegisterModelBinders()</span></code> extension method uses assembly scanning to add the model binders you need to specify what type(s) the model binders (<code class="docutils literal notranslate"><span class="pre">IModelBinder</span></code> implementations) are to be registered for.</p>
<p>This is done by using the <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Mvc.ModelBinderTypeAttribute</span></code>, like so:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[ModelBinderType(typeof(string))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">StringBinder</span> <span class="p">:</span> <span class="n">IModelBinder</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">object</span> <span class="nf">BindModel</span><span class="p">(</span><span class="n">ControllerContext</span> <span class="n">controllerContext</span><span class="p">,</span> <span class="n">ModelBindingContext</span> <span class="n">bindingContext</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Implementation here</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multiple instances of the <code class="docutils literal notranslate"><span class="pre">ModelBinderTypeAttribute</span></code> can be added to a class if it is to be registered for multiple types.</p>
</div>
<div class="section" id="register-web-abstractions">
<h5><a class="toc-backref" href="#id6">Register Web Abstractions</a><a class="headerlink" href="#register-web-abstractions" title="Permalink to this headline">¶</a></h5>
<p>The MVC integration includes an Autofac module that will add <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">HTTP request lifetime scoped</span></a> registrations for the web abstraction classes. This will allow you to put the web abstraction as a dependency in your class and get the correct value injected at runtime.</p>
<p>The following abstract classes are included:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">HttpContextBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpRequestBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpResponseBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpServerUtilityBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpSessionStateBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpApplicationStateBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpBrowserCapabilitiesBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpFileCollectionBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">RequestContext</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpCachePolicyBase</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">VirtualPathProvider</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">UrlHelper</span></code></li>
</ul>
<p>To use these abstractions add the <code class="docutils literal notranslate"><span class="pre">AutofacWebTypesModule</span></code> to the container using the standard <code class="docutils literal notranslate"><span class="pre">RegisterModule()</span></code> method.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AutofacWebTypesModule</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="enable-property-injection-for-view-pages">
<h5><a class="toc-backref" href="#id7">Enable Property Injection for View Pages</a><a class="headerlink" href="#enable-property-injection-for-view-pages" title="Permalink to this headline">¶</a></h5>
<p>You can make <a class="reference internal" href="index.html#document-register/prop-method-injection"><span class="doc">property injection</span></a> available to your MVC views by adding the <code class="docutils literal notranslate"><span class="pre">ViewRegistrationSource</span></code> to your <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> before building the application container.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterSource</span><span class="p">(</span><span class="k">new</span> <span class="n">ViewRegistrationSource</span><span class="p">());</span>
</pre></div>
</div>
<p>Your view page must inherit from one of the base classes that MVC supports for creating views. When using the Razor view engine this will be the <code class="docutils literal notranslate"><span class="pre">WebViewPage</span></code> class.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">CustomViewPage</span> <span class="p">:</span> <span class="n">WebViewPage</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IDependency</span> <span class="n">Dependency</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ViewPage</span></code>, <code class="docutils literal notranslate"><span class="pre">ViewMasterPage</span></code> and <code class="docutils literal notranslate"><span class="pre">ViewUserControl</span></code> classes are supported when using the web forms view engine.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">CustomViewPage</span> <span class="p">:</span> <span class="n">ViewPage</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IDependency</span> <span class="n">Dependency</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ensure that your actual view page inherits from your custom base class. This can be achieved using the <code class="docutils literal notranslate"><span class="pre">&#64;inherits</span></code> directive inside your <code class="docutils literal notranslate"><span class="pre">.cshtml</span></code> file for the Razor view engine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@inherits</span> <span class="n">Example</span><span class="o">.</span><span class="n">Views</span><span class="o">.</span><span class="n">Shared</span><span class="o">.</span><span class="n">CustomViewPage</span>
</pre></div>
</div>
<p>When using the web forms view engine you set the <code class="docutils literal notranslate"><span class="pre">Inherits</span></code> attribute on the <code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">Page</span></code> directive inside your <code class="docutils literal notranslate"><span class="pre">.aspx</span></code> file instead.</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">Page</span> <span class="n">Language</span><span class="p">=</span><span class="s">&quot;C#&quot;</span> <span class="n">MasterPageFile</span><span class="p">=</span><span class="s">&quot;~/Views/Shared/Site.Master&quot;</span> <span class="n">Inherits</span><span class="p">=</span><span class="s">&quot;Example.Views.Shared.CustomViewPage&quot;</span><span class="nt">%&gt;</span>
</pre></div>
</div>
<p><strong>Due to an issue with ASP.NET MVC internals, dependency injection is not available for Razor layout pages.</strong> Razor views will work, but layout pages won’t. <a class="reference external" href="https://github.com/autofac/Autofac/issues/349#issuecomment-33025529">See issue #349 for more information.</a></p>
</div>
<div class="section" id="enable-property-injection-for-action-filters">
<h5><a class="toc-backref" href="#id8">Enable Property Injection for Action Filters</a><a class="headerlink" href="#enable-property-injection-for-action-filters" title="Permalink to this headline">¶</a></h5>
<p>To make use of property injection for your filter attributes call the <code class="docutils literal notranslate"><span class="pre">RegisterFilterProvider()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> before building your container and providing it to the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterFilterProvider</span><span class="p">();</span>
</pre></div>
</div>
<p>This allows you to add properties to your filter attributes and any matching dependencies that are registered in the container will be injected into the properties.</p>
<p>For example, the action filter below will have the <code class="docutils literal notranslate"><span class="pre">ILogger</span></code> instance injected from the container (assuming you register an <code class="docutils literal notranslate"><span class="pre">ILogger</span></code>. Note that <strong>the attribute itself does not need to be registered in the container</strong>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CustomActionFilter</span> <span class="p">:</span> <span class="n">ActionFilterAttribute</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">ILogger</span> <span class="n">Logger</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnActionExecuting</span><span class="p">(</span><span class="n">ActionExecutingContext</span> <span class="n">filterContext</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Logger</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&quot;OnActionExecuting&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same simple approach applies to the other filter attribute types such as authorization attributes.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CustomAuthorizeAttribute</span> <span class="p">:</span> <span class="n">AuthorizeAttribute</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">ILogger</span> <span class="n">Logger</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">AuthorizeCore</span><span class="p">(</span><span class="n">HttpContextBase</span> <span class="n">httpContext</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Logger</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&quot;AuthorizeCore&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After applying the attributes to your actions as usual your work is done.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[CustomActionFilter]</span>
<span class="na">[CustomAuthorizeAttribute]</span>
<span class="k">public</span> <span class="n">ActionResult</span> <span class="nf">Index</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="enable-injection-of-action-parameters">
<h5><a class="toc-backref" href="#id9">Enable Injection of Action Parameters</a><a class="headerlink" href="#enable-injection-of-action-parameters" title="Permalink to this headline">¶</a></h5>
<p>While not common, some folks want to have Autofac populate parameters in action methods when they’re called. <strong>It is recommended you use constructor injection on your controller rather than action method injection</strong> but you can enable action method injection if you desire:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The Autofac ExtensibleActionInvoker attempts to resolve parameters</span>
<span class="c1">// from the request lifetime scope IF the model binder can&#39;t bind</span>
<span class="c1">// to the parameter.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ExtensibleActionInvoker</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IActionInvoker</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">InjectActionInvoker</span><span class="p">();</span>
</pre></div>
</div>
<p>Note you can use the <code class="docutils literal notranslate"><span class="pre">InjectActionInvoker()</span></code> mechanism with your own custom invoker, too.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyCustomActionInvoker</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IActionInvoker</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">InjectActionInvoker</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="owin-integration">
<h5><a class="toc-backref" href="#id10">OWIN Integration</a><a class="headerlink" href="#owin-integration" title="Permalink to this headline">¶</a></h5>
<p>If you are using MVC <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">as part of an OWIN application</span></a>, you need to:</p>
<ul class="simple">
<li>Do all the stuff for standard MVC integration - register controllers, set the dependency resolver, etc.</li>
<li>Set up your app with the <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">base Autofac OWIN integration</span></a>.</li>
<li>Add a reference to the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Mvc5.Owin/">Autofac.Mvc5.Owin</a> NuGet package.</li>
<li>In your application startup class, register the Autofac MVC middleware after registering the base Autofac middleware.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configuration</span><span class="p">(</span><span class="n">IAppBuilder</span> <span class="n">app</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// STANDARD MVC SETUP:</span>

    <span class="c1">// Register your MVC controllers.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterControllers</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">MvcApplication</span><span class="p">).</span><span class="n">Assembly</span><span class="p">);</span>

    <span class="c1">// Run other optional steps, like registering model binders,</span>
    <span class="c1">// web abstractions, etc., then set the dependency resolver</span>
    <span class="c1">// to be Autofac.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
    <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>

    <span class="c1">// OWIN MVC SETUP:</span>

    <span class="c1">// Register the Autofac middleware FIRST, then the Autofac MVC middleware.</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMiddleware</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMvc</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Minor gotcha: MVC doesn’t run 100% in the OWIN pipeline.</strong> It still needs <code class="docutils literal notranslate"><span class="pre">HttpContext.Current</span></code> and some other non-OWIN things. At application startup, when MVC registers routes, it instantiates an <code class="docutils literal notranslate"><span class="pre">IControllerFactory</span></code> that ends up creating two request lifetime scopes. It only happens during app startup at route registration time, not once requests start getting handled, but it’s something to be aware of. This is an artifact of the two pipelines being mangled together. <a class="reference external" href="https://github.com/autofac/Autofac.Mvc/issues/5">We looked into ways to try working around it</a> but were unable to do so in a clean fashion.</p>
</div>
<div class="section" id="using-plugin-assemblies">
<h5><a class="toc-backref" href="#id11">Using “Plugin” Assemblies</a><a class="headerlink" href="#using-plugin-assemblies" title="Permalink to this headline">¶</a></h5>
<p>If you have controllers in a “plugin assembly” that isn’t referenced by the main application <a class="reference external" href="http://www.paraesthesia.com/archive/2013/01/21/putting-controllers-in-plugin-assemblies-for-asp-net-mvc.aspx">you’ll need to register your controller plugin assembly with the ASP.NET BuildManager</a>.</p>
<p>You can do this through configuration or programmatically.</p>
<p><strong>If you choose configuration</strong>, you need to add your plugin assembly to the <code class="docutils literal notranslate"><span class="pre">/configuration/system.web/compilation/assemblies</span></code> list. If your plugin assembly isn’t in the <code class="docutils literal notranslate"><span class="pre">bin</span></code> folder, you also need to update the <code class="docutils literal notranslate"><span class="pre">/configuration/runtime/assemblyBinding/probing</span></code> path.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;runtime&gt;</span>
    <span class="nt">&lt;assemblyBinding</span> <span class="na">xmlns=</span><span class="s">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span><span class="nt">&gt;</span>
      <span class="c">&lt;!--</span>
<span class="c">          If you put your plugin in a folder that isn&#39;t bin, add it to the probing path</span>
<span class="c">      --&gt;</span>
      <span class="nt">&lt;probing</span> <span class="na">privatePath=</span><span class="s">&quot;bin;bin\plugins&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/assemblyBinding&gt;</span>
  <span class="nt">&lt;/runtime&gt;</span>
  <span class="nt">&lt;system.web&gt;</span>
    <span class="nt">&lt;compilation&gt;</span>
      <span class="nt">&lt;assemblies&gt;</span>
        <span class="nt">&lt;add</span> <span class="na">assembly=</span><span class="s">&quot;The.Name.Of.Your.Plugin.Assembly.Here&quot;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/assemblies&gt;</span>
    <span class="nt">&lt;/compilation&gt;</span>
  <span class="nt">&lt;/system.web&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</div>
<p><strong>If you choose programmatic registration</strong>, you need to do it during pre-application-start before the ASP.NET <code class="docutils literal notranslate"><span class="pre">BuildManager</span></code> kicks in.</p>
<p>Create an initializer class to do the assembly scanning/loading and registration with the <code class="docutils literal notranslate"><span class="pre">BuildManager</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Web.Compilation</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">MyNamespace</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Initializer</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">pluginFolder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DirectoryInfo</span><span class="p">(</span><span class="n">HostingEnvironment</span><span class="p">.</span><span class="n">MapPath</span><span class="p">(</span><span class="s">&quot;~/plugins&quot;</span><span class="p">));</span>
      <span class="kt">var</span> <span class="n">pluginAssemblies</span> <span class="p">=</span> <span class="n">pluginFolder</span><span class="p">.</span><span class="n">GetFiles</span><span class="p">(</span><span class="s">&quot;*.dll&quot;</span><span class="p">,</span> <span class="n">SearchOption</span><span class="p">.</span><span class="n">AllDirectories</span><span class="p">);</span>
      <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">pluginAssemblyFile</span> <span class="k">in</span> <span class="n">pluginAssemblyFiles</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="kt">var</span> <span class="n">asm</span> <span class="p">=</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">LoadFrom</span><span class="p">(</span><span class="n">pluginAssemblyFile</span><span class="p">.</span><span class="n">FullName</span><span class="p">);</span>
        <span class="n">BuildManager</span><span class="p">.</span><span class="n">AddReferencedAssembly</span><span class="p">(</span><span class="n">asm</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then be sure to register your pre-application-start code with an assembly attribute:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[assembly: PreApplicationStartMethod(typeof(Initializer), &quot;Initialize&quot;)]</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-current-autofac-dependencyresolver">
<h5><a class="toc-backref" href="#id12">Using the Current Autofac DependencyResolver</a><a class="headerlink" href="#using-the-current-autofac-dependencyresolver" title="Permalink to this headline">¶</a></h5>
<p>Once you set the MVC <code class="docutils literal notranslate"><span class="pre">DependencyResolver</span></code> to an <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> as a shortcut to getting the current dependency resolver and casting it to an <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code>.</p>
<p>Unfortunately, there are some gotchas around the use of <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> that can result in things not working quite right. Usually these issues arise by using a product like <a class="reference external" href="http://getglimpse.com/">Glimpse</a> or <a class="reference external" href="http://www.castleproject.org/projects/dynamicproxy/">Castle DynamicProxy</a> that “wrap” or “decorate” the dependency resolver to add functionality. If the current dependency resolver is decorated or otherwise wrapped/proxied, you can’t cast it to <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> and there’s no single way to “unwrap it” or get to the actual resolver.</p>
<p>Prior to version 3.3.3 of the Autofac MVC integration, we tracked the current dependency resolver by dynamically adding it to the request lifetime scope. This got us around issues where we couldn’t unwrap the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> from a proxy… but it meant that <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> would only work during a request lifetime - you couldn’t use it in background tasks or at application startup.</p>
<p>Starting with version 3.3.3, the logic for locating <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> changed to first attempt to cast the current dependency resolver; then to specifically look for signs it was wrapped using <a class="reference external" href="http://www.castleproject.org/projects/dynamicproxy/">Castle DynamicProxy</a> and unwrap it via reflection. Failing that… we can’t find the current <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> so we throw an <code class="docutils literal notranslate"><span class="pre">InvalidOperationException</span></code> with a message like:</p>
<blockquote>
<div>The dependency resolver is of type ‘Some.Other.DependencyResolver’ but was expected to be of type ‘Autofac.Integration.Mvc.AutofacDependencyResolver’. It also does not appear to be wrapped using DynamicProxy from the Castle Project. This issue could be the result of a change in the DynamicProxy implementation or the use of a different proxy library to wrap the dependency resolver.</div></blockquote>
<p>The typical place where this is seen is when using the action filter provider via <code class="docutils literal notranslate"><span class="pre">ContainerBuilder.RegisterFilterProvider()</span></code>. The filter provider needs to access the Autofac dependency resolver and uses <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> to do it.</p>
<p>If you see this, it means you’re decorating the resolver in a way that can’t be unwrapped and functions that rely on <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> will fail. The current solution is to not decorate the dependency resolver.</p>
</div>
<div class="section" id="glimpse-integration">
<h5><a class="toc-backref" href="#id13">Glimpse Integration</a><a class="headerlink" href="#glimpse-integration" title="Permalink to this headline">¶</a></h5>
<p>Integration of an MVC application with Glimpse when using Autofac is pretty much the same as with any other integration. <strong>However, if you use action method parameter injection</strong> (e.g., with <code class="docutils literal notranslate"><span class="pre">builder.InjectActionInvoker()</span></code>) then Glimpse execution inspection will fail.</p>
<p>You can work around this by adding the following to your Glimpse configuration:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span>  <span class="nt">&lt;glimpse</span> <span class="na">defaultRuntimePolicy=</span><span class="s">&quot;On&quot;</span> <span class="na">endpointBaseUri=</span><span class="s">&quot;~/Glimpse.axd&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;inspectors&gt;</span>
      <span class="nt">&lt;ignoredTypes&gt;</span>
        <span class="nt">&lt;add</span> <span class="na">type=</span><span class="s">&quot;Glimpse.Mvc.Inspector.ExecutionInspector, Glimpse.Mvc&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/ignoredTypes&gt;</span>
    <span class="nt">&lt;/inspectors&gt;</span>
    <span class="nt">&lt;tabs&gt;</span>
      <span class="nt">&lt;ignoredTypes&gt;</span>
        <span class="nt">&lt;add</span> <span class="na">type=</span><span class="s">&quot;Glimpse.Mvc.Tab.Execution, Glimpse.Mvc&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/ignoredTypes&gt;</span>
    <span class="nt">&lt;/tabs&gt;</span>
<span class="nt">&lt;/glimpse&gt;</span>
</pre></div>
</div>
<p>Again, you <strong>only need to do this if you’re using the action parameter injection</strong>. This is one of the many reasons it’s recommended to use controller constructor injection instead of action method parameter injection.</p>
<p>For more info on why this is (including links to the associated info from Glimpse), <a class="reference external" href="https://github.com/autofac/Autofac.Mvc/issues/7">check out this issue</a>.</p>
</div>
<div class="section" id="unit-testing">
<h5><a class="toc-backref" href="#id14">Unit Testing</a><a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h5>
<p>When unit testing an ASP.NET MVC app that uses Autofac where you have <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code> components registered, you’ll get an exception when you try to resolve those components because there’s no HTTP request lifetime during a unit test.</p>
<p>The <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime scope</span></a> topic outlines strategies for testing and troubleshooting per-request-scope components.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id15">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>There is an example project showing ASP.NET MVC integration <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MvcExample">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/webapi"></span><div class="section" id="web-api">
<h4>Web API<a class="headerlink" href="#web-api" title="Permalink to this headline">¶</a></h4>
<p>Web API 2 integration requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.WebApi2">Autofac.WebApi2 NuGet package</a>.</p>
<p>Web API integration requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.WebApi/">Autofac.WebApi NuGet package</a>.</p>
<p>Web API integration provides dependency injection integration for controllers, model binders, and action filters. It also adds <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime support</span></a>.</p>
<p><strong>This page explains ASP.NET classic Web API integration.</strong> If you are using ASP.NET Core, <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">see the ASP.NET Core integration page</span></a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id1">Quick Start</a></li>
<li><a class="reference internal" href="#get-the-httpconfiguration" id="id2">Get the HttpConfiguration</a></li>
<li><a class="reference internal" href="#register-controllers" id="id3">Register Controllers</a></li>
<li><a class="reference internal" href="#set-the-dependency-resolver" id="id4">Set the Dependency Resolver</a></li>
<li><a class="reference internal" href="#provide-filters-via-dependency-injection" id="id5">Provide Filters via Dependency Injection</a><ul>
<li><a class="reference internal" href="#register-the-filter-provider" id="id6">Register the Filter Provider</a></li>
<li><a class="reference internal" href="#implement-the-filter-interface" id="id7">Implement the Filter Interface</a><ul>
<li><a class="reference internal" href="#standard-action-filter-interface" id="id8">Standard Action Filter Interface</a></li>
<li><a class="reference internal" href="#continuation-action-filter-interface" id="id9">Continuation Action Filter Interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#register-the-filter" id="id10">Register the Filter</a></li>
<li><a class="reference internal" href="#filter-overrides" id="id11">Filter Overrides</a></li>
<li><a class="reference internal" href="#setting-the-response-in-an-autofac-action-filter" id="id12">Setting the Response in an Autofac Action Filter</a></li>
<li><a class="reference internal" href="#standard-web-api-filter-attributes-are-singletons" id="id13">Standard Web API Filter Attributes are Singletons</a></li>
<li><a class="reference internal" href="#instance-filters-don-t-get-injected" id="id14">Instance Filters Don’t Get Injected</a></li>
</ul>
</li>
<li><a class="reference internal" href="#provide-model-binders-via-dependency-injection" id="id15">Provide Model Binders via Dependency Injection</a><ul>
<li><a class="reference internal" href="#register-the-binder-provider" id="id16">Register the Binder Provider</a></li>
<li><a class="reference internal" href="#register-model-binders" id="id17">Register Model Binders</a></li>
<li><a class="reference internal" href="#mark-parameters-with-modelbinderattribute" id="id18">Mark Parameters With ModelBinderAttribute</a></li>
</ul>
</li>
<li><a class="reference internal" href="#per-controller-type-services" id="id19">Per-Controller-Type Services</a><ul>
<li><a class="reference internal" href="#add-the-controller-configuration-attribute" id="id20">Add the Controller Configuration Attribute</a></li>
<li><a class="reference internal" href="#supported-services" id="id21">Supported Services</a></li>
<li><a class="reference internal" href="#service-registration" id="id22">Service Registration</a></li>
<li><a class="reference internal" href="#clearing-existing-services" id="id23">Clearing Existing Services</a></li>
<li><a class="reference internal" href="#per-controller-type-service-limitations" id="id24">Per-Controller-Type Service Limitations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#batching" id="id25">Batching</a></li>
<li><a class="reference internal" href="#owin-integration" id="id26">OWIN Integration</a></li>
<li><a class="reference internal" href="#unit-testing" id="id27">Unit Testing</a></li>
<li><a class="reference internal" href="#example" id="id28">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id1">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with Web API you need to reference the Web API integration NuGet package, register your controllers, and set the dependency resolver. You can optionally enable other features as well.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

  <span class="c1">// Get your HttpConfiguration.</span>
  <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">GlobalConfiguration</span><span class="p">.</span><span class="n">Configuration</span><span class="p">;</span>

  <span class="c1">// Register your Web API controllers.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

  <span class="c1">// OPTIONAL: Register the Autofac filter provider.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterWebApiFilterProvider</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>

  <span class="c1">// OPTIONAL: Register the Autofac model binder provider.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterWebApiModelBinderProvider</span><span class="p">();</span>

  <span class="c1">// Set the dependency resolver to be Autofac.</span>
  <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
  <span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sections below go into further detail about what each of these features do and how to use them.</p>
</div>
<div class="section" id="get-the-httpconfiguration">
<h5><a class="toc-backref" href="#id2">Get the HttpConfiguration</a><a class="headerlink" href="#get-the-httpconfiguration" title="Permalink to this headline">¶</a></h5>
<p>In Web API, setting up the application requires you to update properties and set values on an <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> object. Depending on how you’re hosting your application, where you get this configuration may be different. Through the documentation, we’ll refer to “your <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code>” and you’ll need to make a choice of how to get it.</p>
<p>For standard IIS hosting, the <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> is <code class="docutils literal notranslate"><span class="pre">GlobalConfiguration.Configuration</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">GlobalConfiguration</span><span class="p">.</span><span class="n">Configuration</span><span class="p">;</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
<p>For self hosting, the <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> is your <code class="docutils literal notranslate"><span class="pre">HttpSelfHostConfiguration</span></code> instance.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpSelfHostConfiguration</span><span class="p">(</span><span class="s">&quot;http://localhost:8080&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
<p>For OWIN integration, the <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> is the one you create in your app startup class and pass to the Web API middleware.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpConfiguration</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="register-controllers">
<h5><a class="toc-backref" href="#id3">Register Controllers</a><a class="headerlink" href="#register-controllers" title="Permalink to this headline">¶</a></h5>
<p>At application startup, while building your Autofac container, you should register your Web API controllers and their dependencies. This typically happens in an OWIN startup class or in the <code class="docutils literal notranslate"><span class="pre">Application_Start</span></code> method in <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code>.</p>
<p>By default types that implement <code class="docutils literal notranslate"><span class="pre">IHttpController</span></code> and have a name with the suffix <code class="docutils literal notranslate"><span class="pre">Controller</span></code> will be registered.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// You can register controllers all at once using assembly scanning...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

<span class="c1">// ...or you can register individual controllers manually.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ValuesController</span><span class="p">&gt;().</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<p>If your controllers do not follow the standard naming convention you may choose to provide a custom suffix using an overload of the <code class="docutils literal notranslate"><span class="pre">RegisterApiControllers</span></code> method.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// You can also use assembly scanning to register controllers with a custom suffix.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="s">&quot;MyCustomSuffix&quot;</span><span class="p">,</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="set-the-dependency-resolver">
<h5><a class="toc-backref" href="#id4">Set the Dependency Resolver</a><a class="headerlink" href="#set-the-dependency-resolver" title="Permalink to this headline">¶</a></h5>
<p>After building your container pass it into a new instance of the <code class="docutils literal notranslate"><span class="pre">AutofacWebApiDependencyResolver</span></code> class. Attach the new resolver to your <code class="docutils literal notranslate"><span class="pre">HttpConfiguration.DependencyResolver</span></code> to let Web API know that it should locate services using the <code class="docutils literal notranslate"><span class="pre">AutofacWebApiDependencyResolver</span></code>. This is Autofac’s implementation of the <code class="docutils literal notranslate"><span class="pre">IDependencyResolver</span></code> interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="provide-filters-via-dependency-injection">
<h5><a class="toc-backref" href="#id5">Provide Filters via Dependency Injection</a><a class="headerlink" href="#provide-filters-via-dependency-injection" title="Permalink to this headline">¶</a></h5>
<p>Because attributes are created via the reflection API you don’t get to call the constructor yourself.
That leaves you with no other option except for property injection when working with attributes.
The Autofac integration with Web API provides a mechanism that allows you to create classes that
implement the filter interfaces
(<code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code>, <code class="docutils literal notranslate"><span class="pre">IAutofacContinuationActionFilter</span></code>, <code class="docutils literal notranslate"><span class="pre">IAutofacAuthorizationFilter</span></code> and <code class="docutils literal notranslate"><span class="pre">IAutofacExceptionFilter</span></code>)
and wire them up to the desired controller or action method using the registration syntax on the container builder.</p>
<div class="section" id="register-the-filter-provider">
<h6><a class="toc-backref" href="#id6">Register the Filter Provider</a><a class="headerlink" href="#register-the-filter-provider" title="Permalink to this headline">¶</a></h6>
<p>You need to register the Autofac filter provider implementation because it does the work of wiring up the filter
based on the registration. This is done by calling the <code class="docutils literal notranslate"><span class="pre">RegisterWebApiFilterProvider</span></code> method on the container
builder and providing an <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> instance.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterWebApiFilterProvider</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="implement-the-filter-interface">
<h6><a class="toc-backref" href="#id7">Implement the Filter Interface</a><a class="headerlink" href="#implement-the-filter-interface" title="Permalink to this headline">¶</a></h6>
<p>Instead of deriving from one of the existing Web API filter attributes your class implements the
appropriate filter interface defined in the integration.</p>
<div class="section" id="standard-action-filter-interface">
<h7><a class="toc-backref" href="#id8">Standard Action Filter Interface</a><a class="headerlink" href="#standard-action-filter-interface" title="Permalink to this headline">¶</a></h7>
<p>The <code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code> interface lets you define a filter that gets invoked before and after
the execution of your action, in a similar way as if you derived from <code class="docutils literal notranslate"><span class="pre">ActionFilterAttribute</span></code>.</p>
<p>The filter below is an action filter and
implements <code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code> instead of <code class="docutils literal notranslate"><span class="pre">System.Web.Http.Filters.IActionFilter</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">LoggingActionFilter</span> <span class="p">:</span> <span class="n">IAutofacActionFilter</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">ILogger</span> <span class="n">_logger</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">LoggingActionFilter</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">Task</span> <span class="nf">OnActionExecutingAsync</span><span class="p">(</span><span class="n">HttpActionContext</span> <span class="n">actionContext</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">actionContext</span><span class="p">.</span><span class="n">ActionDescriptor</span><span class="p">.</span><span class="n">ActionName</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">Task</span> <span class="nf">OnActionExecutedAsync</span><span class="p">(</span><span class="n">HttpActionExecutedContext</span> <span class="n">actionExecutedContext</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">actionExecutedContext</span><span class="p">.</span><span class="n">ActionContext</span><span class="p">.</span><span class="n">ActionDescriptor</span><span class="p">.</span><span class="n">ActionName</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note in the sample there’s no actual async code that runs so it returns <code class="docutils literal notranslate"><span class="pre">Task.FromResult(0)</span></code>, which is a common way to return an “empty task.”
If your filter does require async code, you can return a real <code class="docutils literal notranslate"><span class="pre">Task</span></code> object or use <code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> code just like any other asynchronous method.</p>
</div>
<div class="section" id="continuation-action-filter-interface">
<h7><a class="toc-backref" href="#id9">Continuation Action Filter Interface</a><a class="headerlink" href="#continuation-action-filter-interface" title="Permalink to this headline">¶</a></h7>
<p>In addition to the regular <code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code> in the example above, there is also an <code class="docutils literal notranslate"><span class="pre">IAutofacContinuationActionFilter</span></code>. This interface
also functions as an Action Filter, but rather than having an <code class="docutils literal notranslate"><span class="pre">OnActionExecutingAsync</span></code> and <code class="docutils literal notranslate"><span class="pre">OnActionExecutedAsync</span></code> method, it follows the continuation
style with a single <code class="docutils literal notranslate"><span class="pre">ExecuteActionFilterAsync</span></code> method that takes a callback to run the next filter in the chain.</p>
<p>You may want to use <code class="docutils literal notranslate"><span class="pre">IAutofacContinuationActionFilter</span></code> instead of <code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code> if you want to wrap the entire request in a <code class="docutils literal notranslate"><span class="pre">using</span></code> block,
such as when you want to allocate a <code class="docutils literal notranslate"><span class="pre">TransactionScope</span></code> to the request, like so:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">TransactionScopeFilter</span> <span class="p">:</span> <span class="n">IAutofacContinuationActionFilter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="n">ExecuteActionFilterAsync</span><span class="p">(</span>
        <span class="n">HttpActionContext</span> <span class="n">actionContext</span><span class="p">,</span>
        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;&gt;</span> <span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="p">(</span><span class="k">new</span> <span class="n">TransactionScope</span><span class="p">(</span><span class="n">TransactionScopeAsyncFlowOption</span><span class="p">.</span><span class="n">Enabled</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">await</span> <span class="nf">next</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The regular <code class="docutils literal notranslate"><span class="pre">IAutofacActionFilter</span></code> runs inside a continuation filter, so async context is also preserved there between
<code class="docutils literal notranslate"><span class="pre">OnActionExecutingAsync</span></code>, the action method itself, and the <code class="docutils literal notranslate"><span class="pre">OnActionExecutedAsync</span></code> of the filter.</p>
</div>
</div>
</div>
<div class="section" id="register-the-filter">
<h6><a class="toc-backref" href="#id10">Register the Filter</a><a class="headerlink" href="#register-the-filter" title="Permalink to this headline">¶</a></h6>
<p>For the filter to execute you need to register it with the container and inform it which controller (or controllers), and optionally action, should be targeted.
This is done using <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> extension methods, which exist for each of the filter types:</p>
<ul class="simple">
<li>ActionFilter</li>
<li>ActionFilterOverride</li>
<li>AuthenticationFilter</li>
<li>AuthenticationFilterOverride</li>
<li>AuthorizationFilter</li>
<li>AuthorizationFilterOverrideW</li>
<li>ExceptionFilter</li>
<li>ExceptionFilterOverride</li>
</ul>
<p>For each of the filter types, there are a couple of registration methods:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">AsWebApi{FilterType}ForAllControllers</span></code></dt>
<dd>Register this filter to run for all action methods on all controllers, in the same way as registering a global Web API filter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AsWebApi{FilterType}For&lt;TController&gt;()</span></code></dt>
<dd><p class="first">Register the filter for the specified controller, in the same way that placing
an attribute based filter at the controller level would.</p>
<p>Specifying a base controller class will cause this filter to be applied to all controllers that derive from it.</p>
<p>This method takes an optional lambda expression that indicates a specific method on the controller the filter should be applied to,
as if you were applying a filter attribute to a specific action.</p>
<p>In the example below an Action filter is being applied to the <code class="docutils literal notranslate"><span class="pre">Get</span></code> action method on the <code class="docutils literal notranslate"><span class="pre">ValuesController</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">LoggingActionFilter</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()))</span>
    <span class="p">.</span><span class="n">AsWebApiActionFilterFor</span><span class="p">&lt;</span><span class="n">ValuesController</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="k">default</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
    <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<p class="last">When applying the filter to an action method that requires a parameter use the <code class="docutils literal notranslate"><span class="pre">default</span></code> keyword with the data type of the parameter
as a placeholder in your lambda expression. For example, the <code class="docutils literal notranslate"><span class="pre">Get</span></code> action method in the example above required an <code class="docutils literal notranslate"><span class="pre">int</span></code> parameter
and used <code class="docutils literal notranslate"><span class="pre">default(int)</span></code> as a strongly-typed placeholder in the lambda expression.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AsWebApi{FilterType}Where()</span></code></dt>
<dd><p class="first">The <code class="docutils literal notranslate"><span class="pre">*Where</span></code> methods allow you to specify a predicate that can make more advanced custom decisions about which actions and/or controllers to attach to.</p>
<p>In the example below an Exception filter is being applied to all POST methods:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">LoggingExceptionFilter</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()))</span>
    <span class="p">.</span><span class="n">AsWebApiExceptionFilterWhere</span><span class="p">(</span><span class="n">action</span> <span class="p">=&gt;</span> <span class="n">action</span><span class="p">.</span><span class="n">SupportedHttpMethods</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">HttpMethod</span><span class="p">.</span><span class="n">Post</span><span class="p">))</span>
    <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<p>There is also a version of the predicate that receives an <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code> that you can use to consume services inside your predicate:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">LoggingExceptionFilter</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()))</span>
    <span class="p">.</span><span class="n">AsWebApiExceptionFilterWhere</span><span class="p">((</span><span class="n">scope</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IFilterConfig</span><span class="p">&gt;().</span><span class="n">ShouldFilter</span><span class="p">(</span><span class="n">action</span><span class="p">))</span>
    <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Filter predicates are invoked once for each action/filter combination; they are not invoked on every request.</p>
</div>
</dd>
</dl>
<p>You can apply as many filters as you want. Registering a filter of one type does not remove or replace previously registered filters.</p>
<p>You can chain your filter registrations together to attach a filter against multiple controllers, like so:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">LoggingActionFilter</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()))</span>
    <span class="p">.</span><span class="n">AsWebApiActionFilterFor</span><span class="p">&lt;</span><span class="n">LoginController</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">AsWebApiActionFilterFor</span><span class="p">&lt;</span><span class="n">ValuesController</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="k">default</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
    <span class="p">.</span><span class="n">AsWebApiActionFilterFor</span><span class="p">&lt;</span><span class="n">ValuesController</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Post</span><span class="p">(</span><span class="k">default</span><span class="p">(</span><span class="kt">string</span><span class="p">)))</span>
    <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="filter-overrides">
<h6><a class="toc-backref" href="#id11">Filter Overrides</a><a class="headerlink" href="#filter-overrides" title="Permalink to this headline">¶</a></h6>
<p>When registering filters, there are basic registration methods like <code class="docutils literal notranslate"><span class="pre">AsWebApiActionFilterFor&lt;TController&gt;()</span></code> and override registration methods
like <code class="docutils literal notranslate"><span class="pre">AsWebApiActionFilterOverrideFor&lt;TController&gt;()</span></code>.</p>
<p>The point of the override methods is to provide a way to ensure certain filters execute first.
You can have as many overrides as you want - these aren’t <em>replacement</em> filters, just filters that run <em>first</em>.</p>
<p>Filters will run in the order:</p>
<ul class="simple">
<li>Controller-scoped overrides</li>
<li>Action-scoped overrides</li>
<li>Controller scoped filters</li>
<li>Action scoped filters</li>
</ul>
</div>
<div class="section" id="setting-the-response-in-an-autofac-action-filter">
<h6><a class="toc-backref" href="#id12">Setting the Response in an Autofac Action Filter</a><a class="headerlink" href="#setting-the-response-in-an-autofac-action-filter" title="Permalink to this headline">¶</a></h6>
<p>In the same way as with standard Web API filters,  you are able to set the <code class="docutils literal notranslate"><span class="pre">HttpResponseMessage</span></code> in the
<code class="docutils literal notranslate"><span class="pre">OnActionExecutingAsync</span></code> method of an action filter.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RequestRejectionFilter</span> <span class="p">:</span> <span class="n">IAutofacActionFilter</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">Task</span> <span class="nf">OnActionExecutingAsync</span><span class="p">(</span><span class="n">HttpActionContext</span> <span class="n">actionContext</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Request is not valid for some reason.</span>
    <span class="n">actionContext</span><span class="p">.</span><span class="n">Response</span> <span class="p">=</span> <span class="n">actionContext</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">CreateErrorResponse</span><span class="p">(</span><span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">BadRequest</span><span class="p">,</span> <span class="s">&quot;Request not valid&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="n">Task</span> <span class="nf">OnActionExecutedAsync</span><span class="p">(</span><span class="n">HttpActionExecutedContext</span> <span class="n">actionExecutedContext</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To match the standard Web API behaviour, if you set the <code class="docutils literal notranslate"><span class="pre">Response</span></code> property, then no subsequent action filters will be
invoked. However, any action filters already invoked will have <code class="docutils literal notranslate"><span class="pre">OnActionExecutedAsync</span></code> called with the appropriate response populated.</p>
</div>
<div class="section" id="standard-web-api-filter-attributes-are-singletons">
<h6><a class="toc-backref" href="#id13">Standard Web API Filter Attributes are Singletons</a><a class="headerlink" href="#standard-web-api-filter-attributes-are-singletons" title="Permalink to this headline">¶</a></h6>
<p>You may notice that if you use the standard Web API filters that you can’t use <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code> dependencies.</p>
<p>Unlike the filter provider in <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">MVC</span></a>, the one in Web API does not allow you to specify that the filter instances should not be cached.
This means that <strong>all filter attributes in Web API are effectively singleton instances that exist for the entire lifetime of the application.</strong></p>
<p>If you are trying to get per-request dependencies in a filter, you’ll find that will only work if you use the Autofac filter interfaces.
Using the standard Web API filters, the dependencies will be injected once - the first time the filter is resolved - and never again.</p>
<p>The singleton nature of the existing Web API filter attributes is why we need our own filter interfaces.</p>
<p><strong>If you are unable to use the Autofac interfaces and you need per-request or instance-per-dependency services in your filters, you must use service location.</strong>
Luckily, Web API makes getting the current request scope very easy - it comes right along with the <code class="docutils literal notranslate"><span class="pre">HttpRequestMessage</span></code>.</p>
<p>Here’s an example of a filter that uses service location with the Web API <code class="docutils literal notranslate"><span class="pre">IDependencyScope</span></code> to get per-request dependencies:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ServiceCallActionFilterAttribute</span> <span class="p">:</span> <span class="n">ActionFilterAttribute</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnActionExecuting</span><span class="p">(</span><span class="n">HttpActionContext</span> <span class="n">actionContext</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Get the request lifetime scope so you can resolve services.</span>
    <span class="kt">var</span> <span class="n">requestScope</span> <span class="p">=</span> <span class="n">actionContext</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">GetDependencyScope</span><span class="p">();</span>

    <span class="c1">// Resolve the service you want to use.</span>
    <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">requestScope</span><span class="p">.</span><span class="n">GetService</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IMyService</span><span class="p">))</span> <span class="k">as</span> <span class="n">IMyService</span><span class="p">;</span>

    <span class="c1">// Do the rest of the work in the filter.</span>
    <span class="n">service</span><span class="p">.</span><span class="n">DoWork</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="instance-filters-don-t-get-injected">
<h6><a class="toc-backref" href="#id14">Instance Filters Don’t Get Injected</a><a class="headerlink" href="#instance-filters-don-t-get-injected" title="Permalink to this headline">¶</a></h6>
<p>When setting up filters, you may want to manually add filters to a collection like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="p">.</span><span class="n">Filters</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">MyActionFilter</span><span class="p">());</span>
</pre></div>
</div>
<p><strong>Autofac will not inject properties on filters registered this way.</strong> This is somewhat similar to when you use <code class="docutils literal notranslate"><span class="pre">RegisterInstance</span></code>
to put a pre-constructed instance of an object into Autofac - Autofac won’t inject or modify pre-constructed instances.
This same holds true for filter instances that are pre-constructed and added to a filter collection.
As with attribute filters (as noted above), you can work around this by using service location rather than property injection.</p>
</div>
</div>
<div class="section" id="provide-model-binders-via-dependency-injection">
<h5><a class="toc-backref" href="#id15">Provide Model Binders via Dependency Injection</a><a class="headerlink" href="#provide-model-binders-via-dependency-injection" title="Permalink to this headline">¶</a></h5>
<p>The Autofac integration with Web API provides the ability to resolve your model binders using dependency injection and associate binders with types using a fluent interface.</p>
<div class="section" id="register-the-binder-provider">
<h6><a class="toc-backref" href="#id16">Register the Binder Provider</a><a class="headerlink" href="#register-the-binder-provider" title="Permalink to this headline">¶</a></h6>
<p>You need to register the Autofac model binder provider so it can resolve any registered <code class="docutils literal notranslate"><span class="pre">IModelBinder</span></code> implementations when needed. This is done by calling the <code class="docutils literal notranslate"><span class="pre">RegisterWebApiModelBinderProvider</span></code> method on the container builder.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterWebApiModelBinderProvider</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="register-model-binders">
<h6><a class="toc-backref" href="#id17">Register Model Binders</a><a class="headerlink" href="#register-model-binders" title="Permalink to this headline">¶</a></h6>
<p>Once you’ve implemented <code class="docutils literal notranslate"><span class="pre">System.Web.Http.ModelBinding.IModelBinder</span></code> to handle binding concerns, register it with Autofac and let Autofac know which types should be bound using that binder.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span>
  <span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">AutomobileBinder</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">AsModelBinderForTypes</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CarModel</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">TruckModel</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="mark-parameters-with-modelbinderattribute">
<h6><a class="toc-backref" href="#id18">Mark Parameters With ModelBinderAttribute</a><a class="headerlink" href="#mark-parameters-with-modelbinderattribute" title="Permalink to this headline">¶</a></h6>
<p>Even if you have your model binder registered, you still need to mark your parameters with the <code class="docutils literal notranslate"><span class="pre">[ModelBinder]</span></code> attribute so Web API knows to use a model binder instead of a media type formatter to bind your model. You don’t have to specify the model binder type anymore, but you do have to mark the parameter with the attribute. <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api">This is also mentioned in the Web API documentation.</a></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="n">HttpResponseMessage</span> <span class="nf">Post</span><span class="p">([</span><span class="n">ModelBinder</span><span class="p">]</span> <span class="n">CarModel</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="per-controller-type-services">
<h5><a class="toc-backref" href="#id19">Per-Controller-Type Services</a><a class="headerlink" href="#per-controller-type-services" title="Permalink to this headline">¶</a></h5>
<p>Web API has an interesting feature that allows you to configure the set of Web API services (those such as <code class="docutils literal notranslate"><span class="pre">IActionValueBinder</span></code>) that should be used per-controller-type by adding an attribute that implements the <code class="docutils literal notranslate"><span class="pre">IControllerConfiguration</span></code> interface to your controller.</p>
<p>Through the <code class="docutils literal notranslate"><span class="pre">Services</span></code> property on the <code class="docutils literal notranslate"><span class="pre">HttpControllerSettings</span></code> parameter passed to the <code class="docutils literal notranslate"><span class="pre">IControllerConfiguration.Initialize</span></code> method you can override the global set of services. This attribute-based approach seems to encourage you to directly instantiate service instances and then override the ones registered globally. Autofac allows these per-controller-type services to be configured through the container instead of being buried away in an attribute without dependency injection support.</p>
<div class="section" id="add-the-controller-configuration-attribute">
<h6><a class="toc-backref" href="#id20">Add the Controller Configuration Attribute</a><a class="headerlink" href="#add-the-controller-configuration-attribute" title="Permalink to this headline">¶</a></h6>
<p>There is no escaping adding an attribute to the controller that the configuration should be applied to because that is the extension point defined by Web API. The Autofac integration includes an <code class="docutils literal notranslate"><span class="pre">AutofacControllerConfigurationAttribute</span></code> that you can apply to your Web API controllers to indicate that they require per-controller-type configuration.</p>
<p>The point to remember here is that <strong>the actual configuration of what services should be applied will be done when you build your container</strong> and there is no need to implement any of that in an actual attribute. In this case, the attribute can be considered as purely a marker that indicates that the container will define the configuration information and provide the service instances.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[AutofacControllerConfiguration]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ValuesController</span> <span class="p">:</span> <span class="n">ApiController</span>
<span class="p">{</span>
  <span class="c1">// Implementation...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="supported-services">
<h6><a class="toc-backref" href="#id21">Supported Services</a><a class="headerlink" href="#supported-services" title="Permalink to this headline">¶</a></h6>
<p>The supported services can be divided into single-style or multiple-style services. For example, you can only have one <code class="docutils literal notranslate"><span class="pre">IHttpActionInvoker</span></code> but you can have multiple <code class="docutils literal notranslate"><span class="pre">ModelBinderProvider</span></code> services.</p>
<p>You can use dependency injection for the following single-style services:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IHttpActionInvoker</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">HttpActionSelector</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ActionValueBinder</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IBodyModelValidator</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IContentNegotiator</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IHttpControllerActivator</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ModelMetadataProvider</span></code></li>
</ul>
<p>The following multiple style services are supported:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ModelBinderProvider</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ModelValidatorProvider</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ValueProviderFactory</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">MediaTypeFormatter</span></code></li>
</ul>
<p>In the list of the multiple-style services above the <code class="docutils literal notranslate"><span class="pre">MediaTypeFormatter</span></code> is actually the odd one out. Technically, it isn’t actually a service and is added to the <code class="docutils literal notranslate"><span class="pre">MediaTypeFormatterCollection</span></code> on the <code class="docutils literal notranslate"><span class="pre">HttpControllerSettings</span></code> instance and not the <code class="docutils literal notranslate"><span class="pre">ControllerServices</span></code> container. We figured that there was no reason to exclude <code class="docutils literal notranslate"><span class="pre">MediaTypeFormatter</span></code> instances from dependency injection support and made sure that they could be resolved from the container per-controller type, too.</p>
</div>
<div class="section" id="service-registration">
<h6><a class="toc-backref" href="#id22">Service Registration</a><a class="headerlink" href="#service-registration" title="Permalink to this headline">¶</a></h6>
<p>Here is an example of registering a custom <code class="docutils literal notranslate"><span class="pre">IHttpActionSelector</span></code> implementation as <code class="docutils literal notranslate"><span class="pre">InstancePerApiControllerType()</span></code> for the <code class="docutils literal notranslate"><span class="pre">ValuesController</span></code>. When applied to a controller type all derived controllers will also receive the same configuration; the <code class="docutils literal notranslate"><span class="pre">AutofacControllerConfigurationAttribute</span></code> is inherited by derived controller types and the same behavior applies to the registrations in the container. When you register a single-style service it will always replace the default service configured at the global level.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CustomActionSelector</span><span class="p">())</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHttpActionSelector</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerApiControllerType</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ValuesController</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="clearing-existing-services">
<h6><a class="toc-backref" href="#id23">Clearing Existing Services</a><a class="headerlink" href="#clearing-existing-services" title="Permalink to this headline">¶</a></h6>
<p>By default, multiple-style services are appended to the existing set of services configured at the global level. When registering multiple-style services with the container you can choose to clear the existing set of services so that only the ones you have registered as <code class="docutils literal notranslate"><span class="pre">InstancePerApiControllerType()</span></code> will be used. This is done by setting the <code class="docutils literal notranslate"><span class="pre">clearExistingServices</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">true</span></code> on the <code class="docutils literal notranslate"><span class="pre">InstancePerApiControllerType()</span></code> method. Existing services of that type will be removed if any of the registrations for the multiple-style service indicate that they want that to happen.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CustomModelBinderProvider</span><span class="p">())</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ModelBinderProvider</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerApiControllerType</span><span class="p">(</span>
          <span class="k">typeof</span><span class="p">(</span><span class="n">ValuesController</span><span class="p">),</span>
          <span class="n">clearExistingServices</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="per-controller-type-service-limitations">
<h6><a class="toc-backref" href="#id24">Per-Controller-Type Service Limitations</a><a class="headerlink" href="#per-controller-type-service-limitations" title="Permalink to this headline">¶</a></h6>
<p>If you are using per-controller-type services, it is not possible to take dependencies on other services that are registered as <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code>. The problem is that Web API is caching these services and is not requesting them from the container each time a controller of that type is created. It is most likely not possible for Web API to easily add that support that without introducing the notion of a key (for the controller type) into the DI integration, which would mean that all containers would need to support keyed services.</p>
</div>
</div>
<div class="section" id="batching">
<h5><a class="toc-backref" href="#id25">Batching</a><a class="headerlink" href="#batching" title="Permalink to this headline">¶</a></h5>
<p>If you choose to use the <a class="reference external" href="https://blogs.msdn.microsoft.com/webdev/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata/">Web API batching functionality</a>, be aware that the initial multipart request to the batch endpoint is where Web API creates the request lifetime scope. The child requests that are part of the batch all take place in-memory and will share that same request lifetime scope - you won’t get a different scope for each child request in the batch.</p>
<p>This is due to the way the batch handling is designed within Web API and copies properties from the parent request to the child request. One of the properties that is intentionally copied by the ASP.NET Web API framework from parent to children is the request lifetime scope. There is no workaround for this and is outside the control of Autofac.</p>
</div>
<div class="section" id="owin-integration">
<h5><a class="toc-backref" href="#id26">OWIN Integration</a><a class="headerlink" href="#owin-integration" title="Permalink to this headline">¶</a></h5>
<p>If you are using Web API <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">as part of an OWIN application</span></a>, you need to:</p>
<ul class="simple">
<li>Do all the stuff for standard Web API integration - register controllers, set the dependency resolver, etc.</li>
<li>Set up your app with the <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">base Autofac OWIN integration</span></a>.</li>
<li>Add a reference to the <a class="reference external" href="https://www.nuget.org/packages/Autofac.WebApi2.Owin/">Autofac.WebApi2.Owin</a> NuGet package.</li>
<li>In your application startup class, register the Autofac Web API middleware after registering the base Autofac middleware.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configuration</span><span class="p">(</span><span class="n">IAppBuilder</span> <span class="n">app</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// STANDARD WEB API SETUP:</span>

    <span class="c1">// Get your HttpConfiguration. In OWIN, you&#39;ll create one</span>
    <span class="c1">// rather than using GlobalConfiguration.</span>
    <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpConfiguration</span><span class="p">();</span>

    <span class="c1">// Register your Web API controllers.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterApiControllers</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

    <span class="c1">// Run other optional steps, like registering filters,</span>
    <span class="c1">// per-controller-type services, etc., then set the dependency resolver</span>
    <span class="c1">// to be Autofac.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
    <span class="n">config</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>

    <span class="c1">// OWIN WEB API SETUP:</span>

    <span class="c1">// Register the Autofac middleware FIRST, then the Autofac Web API middleware,</span>
    <span class="c1">// and finally the standard Web API middleware.</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMiddleware</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacWebApi</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseWebApi</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common error in OWIN integration is use of the <code class="docutils literal notranslate"><span class="pre">GlobalConfiguration.Configuration</span></code>. <strong>In OWIN you create the configuration from scratch.</strong> You should not reference <code class="docutils literal notranslate"><span class="pre">GlobalConfiguration.Configuration</span></code> anywhere when using the OWIN integration.</p>
</div>
<div class="section" id="unit-testing">
<h5><a class="toc-backref" href="#id27">Unit Testing</a><a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h5>
<p>When unit testing an ASP.NET Web API app that uses Autofac where you have <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code> components registered, you’ll get an exception when you try to resolve those components because there’s no HTTP request lifetime during a unit test.</p>
<p>The <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime scope</span></a> topic outlines strategies for testing and troubleshooting per-request-scope components.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id28">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>There is an example project showing Web API in conjunction with OWIN self hosting <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/WebApiExample.OwinSelfHost">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/signalr"></span><div class="section" id="signalr">
<h4>SignalR<a class="headerlink" href="#signalr" title="Permalink to this headline">¶</a></h4>
<p>SignalR integration requires the <a class="reference external" href="https://nuget.org/packages/Autofac.SignalR/">Autofac.SignalR NuGet package</a>.</p>
<p>SignalR integration provides dependency injection integration for SignalR hubs. <strong>Due to SignalR internals, there is no support in SignalR for per-request lifetime dependencies.</strong></p>
<p>Along with this documentation that’s Autofac specific, you may also be interested in the <a class="reference external" href="http://www.asp.net/signalr/overview/advanced/dependency-injection">Microsoft documentation on SignalR and dependency injection.</a></p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id1">Quick Start</a></li>
<li><a class="reference internal" href="#register-hubs" id="id2">Register Hubs</a></li>
<li><a class="reference internal" href="#set-the-dependency-resolver" id="id3">Set the Dependency Resolver</a></li>
<li><a class="reference internal" href="#managing-dependency-lifetimes" id="id4">Managing Dependency Lifetimes</a></li>
<li><a class="reference internal" href="#owin-integration" id="id5">OWIN Integration</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id1">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with SignalR you need to reference the SignalR integration NuGet package, register your hubs, and set the dependency resolver.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

  <span class="c1">// Register your SignalR hubs.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterHubs</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

  <span class="c1">// Set the dependency resolver to be Autofac.</span>
  <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
  <span class="n">GlobalHost</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sections below go into further detail about what each of these features do and how to use them.</p>
</div>
<div class="section" id="register-hubs">
<h5><a class="toc-backref" href="#id2">Register Hubs</a><a class="headerlink" href="#register-hubs" title="Permalink to this headline">¶</a></h5>
<p>At application startup, while building your Autofac container, you should register your SignalR hubs and their dependencies. This typically happens in an OWIN startup class or in the <code class="docutils literal notranslate"><span class="pre">Application_Start</span></code> method in <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// You can register hubs all at once using assembly scanning...</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterHubs</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

<span class="c1">// ...or you can register individual hubs manually.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ChatHub</span><span class="p">&gt;().</span><span class="n">ExternallyOwned</span><span class="p">();</span>
</pre></div>
</div>
<p>If you register individual hubs, make sure they are registered as <code class="docutils literal notranslate"><span class="pre">ExternallyOwned()</span></code>. This ensures SignalR is allowed to control disposal of the hubs rather than Autofac.</p>
</div>
<div class="section" id="set-the-dependency-resolver">
<h5><a class="toc-backref" href="#id3">Set the Dependency Resolver</a><a class="headerlink" href="#set-the-dependency-resolver" title="Permalink to this headline">¶</a></h5>
<p>After building your container pass it into a new instance of the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> class. Attach the new resolver to your <code class="docutils literal notranslate"><span class="pre">GlobalHost.DependencyResolver</span></code> (or <code class="docutils literal notranslate"><span class="pre">HubConfiguration.Resolver</span></code> if you’re using OWIN) to let SignalR know that it should locate services using the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code>. This is Autofac’s implementation of the <code class="docutils literal notranslate"><span class="pre">IDependencyResolver</span></code> interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="n">GlobalHost</span><span class="p">.</span><span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="managing-dependency-lifetimes">
<h5><a class="toc-backref" href="#id4">Managing Dependency Lifetimes</a><a class="headerlink" href="#managing-dependency-lifetimes" title="Permalink to this headline">¶</a></h5>
<p>Given there is no support for per-request dependencies, <strong>all dependencies resolved for SignalR hubs come from the root container</strong>.</p>
<ul class="simple">
<li>If you have <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> components, they will live for the lifetime of the application because Autofac will <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">hold them until the lifetime scope/container is disposed</span></a>. You should register these as <code class="docutils literal notranslate"><span class="pre">ExternallyOwned()</span></code>.</li>
<li>Any components registered as <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code> will effectively be singletons. Given there’s one root lifetime scope, you’ll only get the one instance.</li>
</ul>
<p>To make managing your hub dependency lifetimes easier you can have the root lifetime scope injected into the constructor of your hub. Next, create a child lifetime scope that you can use for the duration of your hub invocation and resolve the required services. Finally, make sure you dispose the child lifetime when the hub is disposed by SignalR. (This is similar to service location, but it’s the only way to get a “per-hub” sort of scope. No, it’s not awesome.)</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MyHub</span> <span class="p">:</span> <span class="n">Hub</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">ILifetimeScope</span> <span class="n">_hubLifetimeScope</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">ILogger</span> <span class="n">_logger</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MyHub</span><span class="p">(</span><span class="n">ILifetimeScope</span> <span class="n">lifetimeScope</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Create a lifetime scope for the hub.</span>
    <span class="n">_hubLifetimeScope</span> <span class="p">=</span> <span class="n">lifetimeScope</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">();</span>

    <span class="c1">// Resolve dependencies from the hub lifetime scope.</span>
    <span class="n">_logger</span> <span class="p">=</span> <span class="n">_hubLifetimeScope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// You can use your dependency field here!</span>
    <span class="n">_logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Received message: &quot;</span> <span class="p">+</span> <span class="n">message</span><span class="p">);</span>

    <span class="n">Clients</span><span class="p">.</span><span class="n">All</span><span class="p">.</span><span class="n">addMessage</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">(</span><span class="kt">bool</span> <span class="n">disposing</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Dispose the hub lifetime scope when the hub is disposed.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">disposing</span> <span class="p">&amp;&amp;</span> <span class="n">_hubLifetimeScope</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_hubLifetimeScope</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">base</span><span class="p">.</span><span class="n">Dispose</span><span class="p">(</span><span class="n">disposing</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If this is a common pattern in your application, you might consider creating a base/abstract hub from which other hubs can derive to save all the copy/paste creation/disposal of scopes.</p>
<p><strong>Injecting a lifetime scope into your hub does not give you per-request lifetime scopes.</strong> It just gives you a way to manage dependency lifetime in a more active way than resolving everything from the root container. Using <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code>, even with this workaround, will still fail. You may want to read <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">the FAQ on per-request scope</span></a> for more info.</p>
</div>
<div class="section" id="owin-integration">
<h5><a class="toc-backref" href="#id5">OWIN Integration</a><a class="headerlink" href="#owin-integration" title="Permalink to this headline">¶</a></h5>
<p>If you are using SignalR <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">as part of an OWIN application</span></a>, you need to:</p>
<ul class="simple">
<li>Do all the stuff for standard SignalR integration - register controllers, set the dependency resolver, etc.</li>
<li>Set up your app with the <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">base Autofac OWIN integration</span></a>.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configuration</span><span class="p">(</span><span class="n">IAppBuilder</span> <span class="n">app</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// STANDARD SIGNALR SETUP:</span>

    <span class="c1">// Get your HubConfiguration. In OWIN, you&#39;ll create one</span>
    <span class="c1">// rather than using GlobalHost.</span>
    <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HubConfiguration</span><span class="p">();</span>

    <span class="c1">// Register your SignalR hubs.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterHubs</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">());</span>

    <span class="c1">// Set the dependency resolver to be Autofac.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
    <span class="n">config</span><span class="p">.</span><span class="n">Resolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>

    <span class="c1">// OWIN SIGNALR SETUP:</span>

    <span class="c1">// Register the Autofac middleware FIRST, then the standard SignalR middleware.</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseAutofacMiddleware</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
    <span class="n">app</span><span class="p">.</span><span class="n">MapSignalR</span><span class="p">(</span><span class="s">&quot;/signalr&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

    <span class="c1">// To add custom HubPipeline modules, you have to get the HubPipeline</span>
    <span class="c1">// from the dependency resolver, for example:</span>
    <span class="kt">var</span> <span class="n">hubPipeline</span> <span class="p">=</span> <span class="n">config</span><span class="p">.</span><span class="n">Resolver</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IHubPipeline</span><span class="p">&gt;();</span>
    <span class="n">hubPipeline</span><span class="p">.</span><span class="n">AddModule</span><span class="p">(</span><span class="k">new</span> <span class="n">MyPipelineModule</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common error in OWIN integration is use of the <code class="docutils literal notranslate"><span class="pre">GlobalHost</span></code>. <strong>In OWIN you create the configuration from scratch.</strong> You should not reference <code class="docutils literal notranslate"><span class="pre">GlobalHost</span></code> anywhere when using the OWIN integration. <a class="reference external" href="http://www.asp.net/signalr/overview/advanced/dependency-injection">Microsoft has documentation about this and other IoC integration concerns here.</a></p>
</div>
</div>
<span id="document-integration/webforms"></span><div class="section" id="web-forms">
<h4>Web Forms<a class="headerlink" href="#web-forms" title="Permalink to this headline">¶</a></h4>
<p>ASP.NET web forms integration requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Web/">Autofac.Web NuGet package</a>.</p>
<p>Web forms integration provides dependency injection integration for code-behind classes. It also adds <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime support</span></a>.</p>
<p><strong>This page explains ASP.NET classic web forms integration.</strong> If you are using ASP.NET Core, <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">see the ASP.NET Core integration page</span></a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id1">Quick Start</a></li>
<li><a class="reference internal" href="#add-modules-to-web-config" id="id2">Add Modules to Web.config</a></li>
<li><a class="reference internal" href="#implement-icontainerprovideraccessor-in-global-asax" id="id3">Implement IContainerProviderAccessor in Global.asax</a></li>
<li><a class="reference internal" href="#tips-and-tricks" id="id4">Tips and Tricks</a><ul>
<li><a class="reference internal" href="#structuring-pages-and-user-controls-for-di" id="id5">Structuring Pages and User Controls for DI</a></li>
<li><a class="reference internal" href="#manual-property-injection" id="id6">Manual Property Injection</a></li>
<li><a class="reference internal" href="#explicit-injection-via-attributes" id="id7">Explicit Injection via Attributes</a></li>
<li><a class="reference internal" href="#dependency-injection-via-base-page-class" id="id8">Dependency Injection via Base Page Class</a></li>
<li><a class="reference internal" href="#custom-dependency-injection-modules" id="id9">Custom Dependency Injection Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example" id="id10">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id1">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with web forms you need to reference the web forms integration NuGet package, add the modules to <code class="docutils literal notranslate"><span class="pre">web.config</span></code>, and implement <code class="docutils literal notranslate"><span class="pre">IContainerProviderAccessor</span></code> on your <code class="docutils literal notranslate"><span class="pre">Global</span></code> application class.</p>
<p>Add the modules to <code class="docutils literal notranslate"><span class="pre">web.config</span></code>:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;system.web&gt;</span>
    <span class="nt">&lt;httpModules&gt;</span>
      <span class="c">&lt;!-- This section is used for IIS6 --&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;PropertyInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.PropertyInjectionModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/httpModules&gt;</span>
  <span class="nt">&lt;/system.web&gt;</span>
  <span class="nt">&lt;system.webServer&gt;</span>
    <span class="c">&lt;!-- This section is used for IIS7 --&gt;</span>
    <span class="nt">&lt;modules&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;PropertyInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.PropertyInjectionModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/modules&gt;</span>
  <span class="nt">&lt;/system.webServer&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</div>
<p>Implement <code class="docutils literal notranslate"><span class="pre">IContainerProviderAccessor</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Global</span> <span class="p">:</span> <span class="n">HttpApplication</span><span class="p">,</span> <span class="n">IContainerProviderAccessor</span>
<span class="p">{</span>
  <span class="c1">// Provider that holds the application container.</span>
  <span class="k">static</span> <span class="n">IContainerProvider</span> <span class="n">_containerProvider</span><span class="p">;</span>

  <span class="c1">// Instance property that will be used by Autofac HttpModules</span>
  <span class="c1">// to resolve and inject dependencies.</span>
  <span class="k">public</span> <span class="n">IContainerProvider</span> <span class="n">ContainerProvider</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_containerProvider</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Build up your application container and register your dependencies.</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeDependency</span><span class="p">&gt;();</span>
    <span class="c1">// ... continue registering dependencies...</span>

    <span class="c1">// Once you&#39;re done registering things, set the container</span>
    <span class="c1">// provider up with your registrations.</span>
    <span class="n">_containerProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerProvider</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sections below go into further detail about what each of these features do and how to use them.</p>
</div>
<div class="section" id="add-modules-to-web-config">
<h5><a class="toc-backref" href="#id2">Add Modules to Web.config</a><a class="headerlink" href="#add-modules-to-web-config" title="Permalink to this headline">¶</a></h5>
<p>The way that Autofac manages component lifetimes and adds dependency injection into the ASP.NET pipeline is through the use of <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.ihttpmodule.aspx">IHttpModule</a> implementations. You need to configure these modules in <code class="docutils literal notranslate"><span class="pre">web.config</span></code>.</p>
<p>The following snippet config shows the modules configured.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;system.web&gt;</span>
    <span class="nt">&lt;httpModules&gt;</span>
      <span class="c">&lt;!-- This section is used for IIS6 --&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;PropertyInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.PropertyInjectionModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/httpModules&gt;</span>
  <span class="nt">&lt;/system.web&gt;</span>
  <span class="nt">&lt;system.webServer&gt;</span>
    <span class="c">&lt;!-- This section is used for IIS7 --&gt;</span>
    <span class="nt">&lt;modules&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;PropertyInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.PropertyInjectionModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/modules&gt;</span>
  <span class="nt">&lt;/system.webServer&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</div>
<p>Note that while there are two different sections the modules appear in - one each for IIS6 and IIS7 - <strong>it is recommended that you have both in place</strong>. The ASP.NET Developer Server uses the IIS6 settings even if your target deployment environment is IIS7. If you use IIS Express it will use the IIS7 settings.</p>
<p>The modules you see there do some interesting things:</p>
<ul class="simple">
<li><strong>The ContainerDisposalModule</strong> lets Autofac dispose of any components created during request processing as soon as the request completes.</li>
<li><strong>The PropertyInjectionModule</strong> injects dependencies into pages before the page lifecycle executes. An alternative <code class="docutils literal notranslate"><span class="pre">UnsetPropertyInjectionModule</span></code> is also provided which will only set properties on web forms/controls that have null values. (Use only one or the other, but not both.)</li>
</ul>
</div>
<div class="section" id="implement-icontainerprovideraccessor-in-global-asax">
<h5><a class="toc-backref" href="#id3">Implement IContainerProviderAccessor in Global.asax</a><a class="headerlink" href="#implement-icontainerprovideraccessor-in-global-asax" title="Permalink to this headline">¶</a></h5>
<p>The dependency injection modules expect that the <code class="docutils literal notranslate"><span class="pre">HttpApplication</span></code> instance supports <code class="docutils literal notranslate"><span class="pre">IContainerProviderAccessor</span></code>. A complete global application class is shown below:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Global</span> <span class="p">:</span> <span class="n">HttpApplication</span><span class="p">,</span> <span class="n">IContainerProviderAccessor</span>
<span class="p">{</span>
  <span class="c1">// Provider that holds the application container.</span>
  <span class="k">static</span> <span class="n">IContainerProvider</span> <span class="n">_containerProvider</span><span class="p">;</span>

  <span class="c1">// Instance property that will be used by Autofac HttpModules</span>
  <span class="c1">// to resolve and inject dependencies.</span>
  <span class="k">public</span> <span class="n">IContainerProvider</span> <span class="n">ContainerProvider</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_containerProvider</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Build up your application container and register your dependencies.</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeDependency</span><span class="p">&gt;();</span>
    <span class="c1">// ... continue registering dependencies...</span>

    <span class="c1">// Once you&#39;re done registering things, set the container</span>
    <span class="c1">// provider up with your registrations.</span>
    <span class="n">_containerProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerProvider</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.IContainerProvider</span></code> exposes two useful properties: <code class="docutils literal notranslate"><span class="pre">ApplicationContainer</span></code> and <code class="docutils literal notranslate"><span class="pre">RequestLifetime</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ApplicationContainer</span></code> is the root container that was built at application start-up.</li>
<li><code class="docutils literal notranslate"><span class="pre">RequestLifetime</span></code> is a component <a class="reference internal" href="index.html#document-lifetime/index"><span class="doc">lifetime scope</span></a> based on the application container that will be disposed of at the end of the current web request. It can be used whenever manual dependency resolution/service lookup is required. The components that it contains (apart from any singletons) will be specific to the current request (this is where <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime dependencies</span></a> are resolved).</li>
</ul>
</div>
<div class="section" id="tips-and-tricks">
<h5><a class="toc-backref" href="#id4">Tips and Tricks</a><a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">¶</a></h5>
<div class="section" id="structuring-pages-and-user-controls-for-di">
<h6><a class="toc-backref" href="#id5">Structuring Pages and User Controls for DI</a><a class="headerlink" href="#structuring-pages-and-user-controls-for-di" title="Permalink to this headline">¶</a></h6>
<p>In order to inject dependencies into web forms pages (<code class="docutils literal notranslate"><span class="pre">System.Web.UI.Page</span></code> instances) or user controls (<code class="docutils literal notranslate"><span class="pre">System.Web.UI.UserControl</span></code> instances) <strong>you must expose their dependencies as public properties that allow setting</strong>. This enables the <code class="docutils literal notranslate"><span class="pre">PropertyInjectionModule</span></code> to populate those properties for you.</p>
<p>Be sure to register the dependencies you’ll need at application startup.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Component</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;().</span><span class="n">InstancePerRequest</span><span class="p">();</span>
<span class="c1">// ... continue registering dependencies and then build the</span>
<span class="c1">// container provider...</span>
<span class="n">_containerProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerProvider</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
</pre></div>
</div>
<p>Then in your page codebehind, create public get/set properties for the dependencies you’ll need:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// MyPage.aspx.cs</span>
<span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MyPage</span> <span class="p">:</span> <span class="n">Page</span>
<span class="p">{</span>
  <span class="c1">// This property will be set for you by the PropertyInjectionModule.</span>
  <span class="k">public</span> <span class="n">IService</span> <span class="n">MyService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">protected</span> <span class="k">void</span> <span class="nf">Page_Load</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Now you can use the property that was set for you.</span>
    <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">MyService</span><span class="p">.</span><span class="n">GetMessage</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This same process of public property injection will work for user controls, too - just register the components at application startup and provide public get/set properties for the dependencies.</p>
<p>It is important to note <strong>in the case of user controls that properties will only be automatically injected if the control is created and added to the page’s Controls collection by the PreLoad step of the page request lifecycle</strong>. Controls created dynamically either in code or through templates like the Repeater will not be visible at this point and must have their properties manually injected.</p>
</div>
<div class="section" id="manual-property-injection">
<h6><a class="toc-backref" href="#id6">Manual Property Injection</a><a class="headerlink" href="#manual-property-injection" title="Permalink to this headline">¶</a></h6>
<p>In some cases, like in programmatic creation of user controls or other objects, you may need to manually inject properties on an object. To do this, you need to:</p>
<ul class="simple">
<li>Get the current application instance.</li>
<li>Cast it to <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.IContainerProviderAccessor</span></code>.</li>
<li>Get the container provider from the application instance.</li>
<li>Get the <code class="docutils literal notranslate"><span class="pre">RequestLifetime</span></code> from the <code class="docutils literal notranslate"><span class="pre">IContainerProvider</span></code> and use the <code class="docutils literal notranslate"><span class="pre">InjectProperties()</span></code> method to inject the properties on the object.</li>
</ul>
<p>In code, that looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">cpa</span> <span class="p">=</span> <span class="p">(</span><span class="n">IContainerProviderAccessor</span><span class="p">)</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">ApplicationInstance</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">cp</span> <span class="p">=</span> <span class="n">cpa</span><span class="p">.</span><span class="n">ContainerProvider</span><span class="p">;</span>
<span class="n">cp</span><span class="p">.</span><span class="n">RequestLifetime</span><span class="p">.</span><span class="n">InjectProperties</span><span class="p">(</span><span class="n">objectToSet</span><span class="p">);</span>
</pre></div>
</div>
<p>Note you need both the <code class="docutils literal notranslate"><span class="pre">Autofac</span></code> and <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web</span></code> namespaces in there to make property injection work because <code class="docutils literal notranslate"><span class="pre">InjectProperties()</span></code> is an extension method in the <code class="docutils literal notranslate"><span class="pre">Autofac</span></code> namespace.</p>
</div>
<div class="section" id="explicit-injection-via-attributes">
<h6><a class="toc-backref" href="#id7">Explicit Injection via Attributes</a><a class="headerlink" href="#explicit-injection-via-attributes" title="Permalink to this headline">¶</a></h6>
<p>When adding dependency injection to an existing application, it is sometimes desirable to distinguish between web forms pages that will have their dependencies injected and those that will not. The <code class="docutils literal notranslate"><span class="pre">InjectPropertiesAttribute</span></code> in <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web</span></code>, coupled with the <code class="docutils literal notranslate"><span class="pre">AttributedInjectionModule</span></code> help to achieve this.</p>
<p><strong>If you choose to use the AttributedInjectionModule, no dependencies will be automatically injected into public properties unless they’re marked with a special attribute.</strong></p>
<p>First, remove the <code class="docutils literal notranslate"><span class="pre">PropertyInjectionModule</span></code> from your <code class="docutils literal notranslate"><span class="pre">web.config</span></code> file and replace it with the <code class="docutils literal notranslate"><span class="pre">AttributedInjectionModule</span></code>:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;system.web&gt;</span>
    <span class="nt">&lt;httpModules&gt;</span>
      <span class="c">&lt;!-- This section is used for IIS6 --&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;AttributedInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.AttributedInjectionModule, Autofac.Integration.Web&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/httpModules&gt;</span>
  <span class="nt">&lt;/system.web&gt;</span>
  <span class="nt">&lt;system.webServer&gt;</span>
    <span class="c">&lt;!-- This section is used for IIS7 --&gt;</span>
    <span class="nt">&lt;modules&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;ContainerDisposal&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.ContainerDisposalModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;add</span>
        <span class="na">name=</span><span class="s">&quot;AttributedInjection&quot;</span>
        <span class="na">type=</span><span class="s">&quot;Autofac.Integration.Web.Forms.AttributedInjectionModule, Autofac.Integration.Web&quot;</span>
        <span class="na">preCondition=</span><span class="s">&quot;managedHandler&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/modules&gt;</span>
  <span class="nt">&lt;/system.webServer&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</div>
<p>Once this is in place, pages and controls will not have their dependencies injected by default. Instead, they must be marked with the <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.Forms.InjectPropertiesAttribute</span></code> or <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.Forms.InjectUnsetPropertiesAttribute</span></code>. The difference:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">InjectPropertiesAttribute</span></code> will always set public properties on the page/control if there are associated components registered with Autofac.</li>
<li><code class="docutils literal notranslate"><span class="pre">InjectUnsetPropertiesAttribute</span></code> will only set the public properties on the page/control if they are null and the associated components are registered.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[InjectProperties]</span>
<span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MyPage</span> <span class="p">:</span> <span class="n">Page</span>
<span class="p">{</span>
  <span class="c1">// This property will be set for you by the AttributedInjectionModule.</span>
  <span class="k">public</span> <span class="n">IService</span> <span class="n">MyService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// ...use the property later as needed.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="dependency-injection-via-base-page-class">
<h6><a class="toc-backref" href="#id8">Dependency Injection via Base Page Class</a><a class="headerlink" href="#dependency-injection-via-base-page-class" title="Permalink to this headline">¶</a></h6>
<p>If you would rather not automatically inject properties using a module (e.g., the <code class="docutils literal notranslate"><span class="pre">AttributedInjectionModule</span></code> or <code class="docutils literal notranslate"><span class="pre">PropertyInjectionModule</span></code> as mentioned earlier), you can integrate Autofac in a more manual manner by creating a base page class that does manual property injection during the <code class="docutils literal notranslate"><span class="pre">PreInit</span></code> phase of the page request lifecycle.</p>
<p>This option allows you to derive pages that require dependency injection from a common base page class. Doing this may be desirable if you have only a very few pages that require dependency injection and you don’t want the <code class="docutils literal notranslate"><span class="pre">AttributedInjectionModule</span></code> in the pipeline. (You still need the <code class="docutils literal notranslate"><span class="pre">ContainerDisposalModule</span></code>.) If you have more than a small few pages it may be beneficial to consider explicit injection via attributes.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Page_PreInit</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">cpa</span> <span class="p">=</span> <span class="p">(</span><span class="n">IContainerProviderAccessor</span><span class="p">)</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">ApplicationInstance</span><span class="p">;</span>
  <span class="kt">var</span> <span class="n">cp</span> <span class="p">=</span> <span class="n">cpa</span><span class="p">.</span><span class="n">ContainerProvider</span><span class="p">;</span>
  <span class="n">cp</span><span class="p">.</span><span class="n">RequestLifetime</span><span class="p">.</span><span class="n">InjectProperties</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-dependency-injection-modules">
<h6><a class="toc-backref" href="#id9">Custom Dependency Injection Modules</a><a class="headerlink" href="#custom-dependency-injection-modules" title="Permalink to this headline">¶</a></h6>
<p>If the provided <em>Property</em>, <em>Unset Property</em>, and <em>Attributed</em> dependency injection models are unsuitable, it is very easy to create a custom injection behavior. Simply subclass <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.DependencyInjectionModule</span></code> and use the result in <code class="docutils literal notranslate"><span class="pre">Web.config</span></code>.</p>
<p>There is one abstract member to implement:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">abstract</span> <span class="n">IInjectionBehaviour</span> <span class="nf">GetInjectionBehaviourForHandlerType</span><span class="p">(</span><span class="n">Type</span> <span class="n">handlerType</span><span class="p">);</span>
</pre></div>
</div>
<p>The returned <code class="docutils literal notranslate"><span class="pre">IInjectionBehaviour</span></code> can be one of the predefined <code class="docutils literal notranslate"><span class="pre">NoInjection</span></code>, <code class="docutils literal notranslate"><span class="pre">PropertyInjection</span></code>, or <code class="docutils literal notranslate"><span class="pre">UnsetPropertyInjection</span></code> properties; or a custom implementation of the <code class="docutils literal notranslate"><span class="pre">IInjectionBehaviour</span></code> interface.</p>
</div>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id10">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>There is an example project showing ASP.NET web forms integration <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/WebFormsExample">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/ria"></span><div class="section" id="ria-domain-services">
<h4>RIA / Domain Services<a class="headerlink" href="#ria-domain-services" title="Permalink to this headline">¶</a></h4>
<p>Domain Services integration requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Extras.DomainServices/">Autofac.Extras.DomainServices NuGet package</a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id1">Quick Start</a></li>
<li><a class="reference internal" href="#example" id="id2">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id1">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with RIA/domain services app you need to reference the Domain Services integration NuGet package, register services, and register the integration module.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Global</span> <span class="p">:</span> <span class="n">HttpApplication</span><span class="p">,</span> <span class="n">IContainerProviderAccessor</span>
<span class="p">{</span>
  <span class="c1">// The IContainerProviderAccessor and IContainerProvider</span>
  <span class="c1">// interfaces are part of the web integration and are used</span>
  <span class="c1">// for registering/resolving dependencies on a per-request</span>
  <span class="c1">// basis.</span>
  <span class="k">private</span> <span class="k">static</span> <span class="n">IContainerProvider</span> <span class="n">_containerProvider</span><span class="p">;</span>

  <span class="k">public</span> <span class="n">IContainerProvider</span> <span class="n">ContainerProvider</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_containerProvider</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// Register your domain services.</span>
    <span class="n">builder</span>
      <span class="p">.</span><span class="n">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">())</span>
      <span class="p">.</span><span class="n">AssignableTo</span><span class="p">&lt;</span><span class="n">DomainService</span><span class="p">&gt;();</span>

    <span class="c1">// Add the RIA Services module so the &quot;Initialize&quot;</span>
    <span class="c1">// method gets called on your resolved services.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AutofacDomainServiceModule</span><span class="p">&gt;();</span>

    <span class="c1">// Build the container and set the container provider</span>
    <span class="c1">// as in standard web integration.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
    <span class="n">_containerProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerProvider</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>

    <span class="c1">// Replace the DomainService.Factory with</span>
    <span class="c1">// AutofacDomainServiceFactory so things get resolved.</span>
    <span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDomainServiceFactory</span><span class="p">(</span><span class="n">_containerProvider</span><span class="p">);</span>
    <span class="n">DomainService</span><span class="p">.</span><span class="n">Factory</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you write your domain services, use constructor injection and other standard patterns just like any other Autofac/IoC usage.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id2">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>The Autofac examples repository (at tag <code class="docutils literal notranslate"><span class="pre">3.5.2</span></code>) has a <a class="reference external" href="https://github.com/autofac/Examples/tree/v3.5.2/src/DomainServicesExample">Domain Services project</a> that is consumed by a Silverlight application.</p>
</div>
</div>
</div>
</div>
<span id="document-integration/netcore"></span><div class="section" id="net-core">
<h3>.NET Core<a class="headerlink" href="#net-core" title="Permalink to this headline">¶</a></h3>
<p>.NET Core comes with a <a class="reference external" href="http://blog.ploeh.dk/2014/05/19/conforming-container/">conforming container</a> in the form of <a class="reference external" href="https://github.com/aspnet/DependencyInjection">Microsoft.Extensions.DependencyInjection</a>. The <code class="docutils literal notranslate"><span class="pre">Autofac.Extensions.DependencyInjection</span></code> package implements the abstractions for this to provide DI via Autofac.</p>
<p>The integration with <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">ASP.NET Core</span></a> is very similar to this since the whole framework has unified the abstraction around dependency injection. Our <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">ASP.NET Core integration docs</span></a> have more info on specific topics relating to ASP.NET Core (and generically hosted application) usage.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id1">Quick Start</a></li>
<li><a class="reference internal" href="#using-a-child-scope-as-a-root" id="id2">Using a Child Scope as a Root</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h4><a class="toc-backref" href="#id1">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h4>
<p>To take advantage of Autofac in your .NET Core application via the <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.DependencyInjection</span></code> package:</p>
<ul class="simple">
<li>Reference the <code class="docutils literal notranslate"><span class="pre">Autofac.Extensions.DependencyInjection</span></code> package from NuGet.</li>
<li>During application startup (e.g., in the <code class="docutils literal notranslate"><span class="pre">Program</span></code> or  <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class)…<ul>
<li>Register services in an <code class="docutils literal notranslate"><span class="pre">IServiceCollection</span></code> using framework extensions.</li>
<li>Populate those registered services into Autofac.</li>
<li>Add Autofac registrations and overrides.</li>
<li>Build your container.</li>
<li>Create an <code class="docutils literal notranslate"><span class="pre">AutofacServiceProvider</span></code> using the container.</li>
</ul>
</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// The Microsoft.Extensions.DependencyInjection.ServiceCollection</span>
    <span class="c1">// has extension methods provided by other .NET Core libraries to</span>
    <span class="c1">// regsiter services with DI.</span>
    <span class="kt">var</span> <span class="n">serviceCollection</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ServiceCollection</span><span class="p">();</span>

    <span class="c1">// The Microsoft.Extensions.Logging package provides this one-liner</span>
    <span class="c1">// to add logging services.</span>
    <span class="n">serviceCollection</span><span class="p">.</span><span class="n">AddLogging</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">containerBuilder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="c1">// Once you&#39;ve registered everything in the ServiceCollection, call</span>
    <span class="c1">// Populate to bring those registrations into Autofac. This is</span>
    <span class="c1">// just like a foreach over the list of things in the collection</span>
    <span class="c1">// to add them to Autofac.</span>
    <span class="n">containerBuilder</span><span class="p">.</span><span class="n">Populate</span><span class="p">(</span><span class="n">serviceCollection</span><span class="p">);</span>

    <span class="c1">// Make your Autofac registrations. Order is important!</span>
    <span class="c1">// If you make them BEFORE you call Populate, then the</span>
    <span class="c1">// registrations in the ServiceCollection will override Autofac</span>
    <span class="c1">// registrations; if you make them AFTER Populate, the Autofac</span>
    <span class="c1">// registrations will override. You can make registrations</span>
    <span class="c1">// before or after Populate, however you choose.</span>
    <span class="n">containerBuilder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MessageHandler</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandler</span><span class="p">&gt;();</span>

    <span class="c1">// Creating a new AutofacServiceProvider makes the container</span>
    <span class="c1">// available to your app using the Microsoft IServiceProvider</span>
    <span class="c1">// interface so you can use those abstractions rather than</span>
    <span class="c1">// binding directly to Autofac.</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">containerBuilder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">serviceProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacServiceProvider</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>You don’t have to use Microsoft.Extensions.DependencyInjection.</strong> If you aren’t writing a .NET Core app that requires it or if you’re not using any of the DI extensions provided by other libraries you can consume Autofac directly. You also may only need to do the <code class="docutils literal notranslate"><span class="pre">Populate()</span></code> call and not need the <code class="docutils literal notranslate"><span class="pre">AutofacServiceProvider</span></code>. Use the pieces that make sense for your app.</p>
</div>
<div class="section" id="using-a-child-scope-as-a-root">
<h4><a class="toc-backref" href="#id2">Using a Child Scope as a Root</a><a class="headerlink" href="#using-a-child-scope-as-a-root" title="Permalink to this headline">¶</a></h4>
<p>In a complex application you may want to keep services registered using <code class="docutils literal notranslate"><span class="pre">Populate()</span></code> in a child lifetime scope. For example, an application that does some self-hosting of ASP.NET Core components may want to keep the MVC registrations and such isolated from the main container. The <code class="docutils literal notranslate"><span class="pre">Populate()</span></code> method offers an overload to allow you to specify a tagged child lifetime scope that should serve as the “container” for items.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you use this, you will not be able to use the ASP.NET Core support for <code class="docutils literal notranslate"><span class="pre">IServiceProviderFactory{TContainerBuilder}</span></code> (the <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code> support). This is because <code class="docutils literal notranslate"><span class="pre">IServiceProviderFactory{TContainerBuilder}</span></code> assumes it’s working at the root level.</p>
</div>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">RootLifetimeTag</span> <span class="p">=</span> <span class="s">&quot;MyIsolatedRoot&quot;</span><span class="p">;</span>

  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">serviceCollection</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ServiceCollection</span><span class="p">();</span>
    <span class="n">serviceCollection</span><span class="p">.</span><span class="n">AddLogging</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">containerBuilder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
    <span class="n">containerBuilder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MessageHandler</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandler</span><span class="p">&gt;();</span>
    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">containerBuilder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="n">RootLifetimeTag</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
      <span class="n">b</span><span class="p">.</span><span class="n">Populate</span><span class="p">(</span><span class="n">serviceCollection</span><span class="p">,</span> <span class="n">RootLifetimeTag</span><span class="p">);</span>
    <span class="p">}))</span>
    <span class="p">{</span>
      <span class="c1">// This service provider will have access to global singletons</span>
      <span class="c1">// and registrations but the &quot;singletons&quot; for things registered</span>
      <span class="c1">// in the service collection will be &quot;rooted&quot; under this</span>
      <span class="c1">// child scope, unavailable to the rest of the application.</span>
      <span class="c1">//</span>
      <span class="c1">// Obviously it&#39;s not super helpful being in this using block,</span>
      <span class="c1">// so likely you&#39;ll create the scope at app startup, keep it</span>
      <span class="c1">// around during the app lifetime, and dispose of it manually</span>
      <span class="c1">// yourself during app shutdown.</span>
      <span class="kt">var</span> <span class="n">serviceProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacServiceProvider</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-integration/aspnetcore"></span><div class="section" id="asp-net-core">
<h3>ASP.NET Core<a class="headerlink" href="#asp-net-core" title="Permalink to this headline">¶</a></h3>
<p>ASP.NET Core (previously ASP.NET 5) changes the way dependency injection frameworks have previously integrated into ASP.NET execution. Previously, each functionality - MVC, Web API, etc. - had its own “dependency resolver” mechanism and just slightly different ways to hook in. ASP.NET Core introduces a <a class="reference external" href="http://blog.ploeh.dk/2014/05/19/conforming-container/">conforming container</a> mechanism via <a class="reference external" href="https://github.com/aspnet/DependencyInjection">Microsoft.Extensions.DependencyInjection</a>, including a unified notion of request lifetime scope, service registration, and so forth.</p>
<p>Further, as of ASP.NET Core 3.0, there’s a “generic app hosting” mechanism in play that can be used in non-ASP.NET Core apps.</p>
<p><strong>This page explains ASP.NET Core and generic .NET Core hosting integration.</strong> If you are using ASP.NET classic, <a class="reference internal" href="index.html#document-integration/aspnet"><span class="doc">see the ASP.NET classic integration page</span></a>.</p>
<p>If you’re using .NET Core without ASP.NET Core (and/or without the generic hosting), <a class="reference internal" href="index.html#document-integration/netcore"><span class="doc">there’s a simpler example here</span></a> showing that integration.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id2">Quick Start</a><ul>
<li><a class="reference internal" href="#asp-net-core-1-1-2-2" id="id3">ASP.NET Core 1.1 - 2.2</a></li>
<li><a class="reference internal" href="#asp-net-core-3-0-and-generic-hosting" id="id4">ASP.NET Core 3.0+ and Generic Hosting</a></li>
<li><a class="reference internal" href="#startup-class" id="id5">Startup Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-method-naming-conventions" id="id6">Configuration Method Naming Conventions</a></li>
<li><a class="reference internal" href="#dependency-injection-hooks" id="id7">Dependency Injection Hooks</a></li>
<li><a class="reference internal" href="#differences-from-asp-net-classic" id="id8">Differences From ASP.NET Classic</a></li>
<li><a class="reference internal" href="#controllers-as-services" id="id9">Controllers as Services</a></li>
<li><a class="reference internal" href="#multitenant-support" id="id10">Multitenant Support</a></li>
<li><a class="reference internal" href="#using-a-child-scope-as-a-root" id="id11">Using a Child Scope as a Root</a></li>
<li><a class="reference internal" href="#example" id="id12">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h4><a class="toc-backref" href="#id2">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Reference the <code class="docutils literal notranslate"><span class="pre">Autofac.Extensions.DependencyInjection</span></code> package from NuGet.</li>
<li>In your <code class="docutils literal notranslate"><span class="pre">Program.Main</span></code> method, attach the hosting mechanism to Autofac. (See the examples below.)</li>
<li>In the <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code> method of your <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class register things into the <code class="docutils literal notranslate"><span class="pre">IServiceCollection</span></code> using extension methods provided by other libraries.</li>
<li>In the <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code> method of your <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class register things directly into an Autofac <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code>.</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">IServiceProvider</span></code> will automatically be created for you, so there’s nothing you have to do but <em>register things</em>.</p>
<div class="section" id="asp-net-core-1-1-2-2">
<h5><a class="toc-backref" href="#id3">ASP.NET Core 1.1 - 2.2</a><a class="headerlink" href="#asp-net-core-1-1-2-2" title="Permalink to this headline">¶</a></h5>
<p>This example shows <strong>ASP.NET Core 1.1 - 2.2</strong> usage, where you call <code class="docutils literal notranslate"><span class="pre">services.AddAutofac()</span></code> on the <code class="docutils literal notranslate"><span class="pre">WebHostBuilder</span></code>. <strong>This is not for ASP.NET Core 3+</strong> or the .NET Core 3+ generic hosting support - ASP.NET Core 3 requires you to specify a service provider factory directly rather than adding it to the service collection.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ASP.NET Core 1.1 - 2.2:</span>
    <span class="c1">// The ConfigureServices call here allows for</span>
    <span class="c1">// ConfigureContainer to be supported in Startup with</span>
    <span class="c1">// a strongly-typed ContainerBuilder.</span>
    <span class="c1">// AddAutofac() is a convenience method for</span>
    <span class="c1">// services.AddSingleton&lt;IServiceProviderFactory&lt;ContainerBuilder&gt;&gt;(new AutofacServiceProviderFactory())</span>
    <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebHostBuilder</span><span class="p">()</span>
        <span class="p">.</span><span class="n">UseKestrel</span><span class="p">()</span>
        <span class="p">.</span><span class="n">ConfigureServices</span><span class="p">(</span><span class="n">services</span> <span class="p">=&gt;</span> <span class="n">services</span><span class="p">.</span><span class="n">AddAutofac</span><span class="p">())</span>
        <span class="p">.</span><span class="n">UseContentRoot</span><span class="p">(</span><span class="n">Directory</span><span class="p">.</span><span class="n">GetCurrentDirectory</span><span class="p">())</span>
        <span class="p">.</span><span class="n">UseIISIntegration</span><span class="p">()</span>
        <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example shows <strong>ASP.NET Core 1.1 - 2.2</strong> usage, where you return an <code class="docutils literal notranslate"><span class="pre">IServiceProvider</span></code> from the <code class="docutils literal notranslate"><span class="pre">ConfigureServices(IServiceCollection</span> <span class="pre">services)</span></code> delegate. <strong>This is not for ASP.NET Core 3+</strong> or the .NET Core 3+ generic hosting support - ASP.NET Core 3 has deprecated the ability to return a service provider from <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>public class Startup
{
  public Startup(IHostingEnvironment env)
  {
    // In ASP.NET Core 3.0 env will be an IWebHostEnvironment , not IHostingEnvironment.
    var builder = new ConfigurationBuilder()
        .SetBasePath(env.ContentRootPath)
        .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
        .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true)
        .AddEnvironmentVariables();
    this.Configuration = builder.Build();
  }

  public IConfigurationRoot Configuration { get; private set; }

  public ILifetimeScope AutofacContainer { get; private set; }

  // ConfigureServices is where you register dependencies and return an `IServiceProvider` implemented by `AutofacServiceProvider`.
  // This is the old, not recommended way, and is NOT SUPPORTED in ASP.NET Core 3.0+.
  public IServiceProvider ConfigureServices(IServiceCollection services)
  {
    // Add services to the collection
    services.AddOptions();

    // Create a container-builder and register dependencies
    var builder = new ContainerBuilder();

    // Populate the service-descriptors added to `IServiceCollection`
    // BEFORE you add things to Autofac so that the Autofac
    // registrations can override stuff in the `IServiceCollection`
    // as needed
    builder.Populate(services);

    // Register your own things directly with Autofac
    builder.RegisterModule(new MyApplicationModule());

    AutofacContainer = builder.Build();

    // this will be used as the service-provider for the application!
    return new AutofacServiceProvider(AutofacContainer);
  }

  // Configure is where you add middleware.
  // You can use IApplicationBuilder.ApplicationServices
  // here if you need to resolve things from the container.
  public void Configure(
    IApplicationBuilder app,
    ILoggerFactory loggerFactory)
  {
    loggerFactory.AddConsole(this.Configuration.GetSection(&quot;Logging&quot;));
    loggerFactory.AddDebug();
    app.UseMvc();
  }
}
</pre></div>
</div>
</div>
<div class="section" id="asp-net-core-3-0-and-generic-hosting">
<h5><a class="toc-backref" href="#id4">ASP.NET Core 3.0+ and Generic Hosting</a><a class="headerlink" href="#asp-net-core-3-0-and-generic-hosting" title="Permalink to this headline">¶</a></h5>
<p><strong>Hosting changed in ASP.NET Core 3.0</strong> and requires a different integration. You can no longer return <code class="docutils literal notranslate"><span class="pre">IServiceProvider</span></code> from <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code>, nor can you add your service provider factory to the service collection.</p>
<p>This is for ASP.NET Core 3+ and the .NET Core 3+ generic hosting support:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ASP.NET Core 3.0+:</span>
    <span class="c1">// The UseServiceProviderFactory call attaches the</span>
    <span class="c1">// Autofac provider to the generic hosting mechanism.</span>
    <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="n">Host</span><span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="p">.</span><span class="n">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacServiceProviderFactory</span><span class="p">())</span>
        <span class="p">.</span><span class="n">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webHostBuilder</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="n">webHostBuilder</span>
            <span class="p">.</span><span class="n">UseContentRoot</span><span class="p">(</span><span class="n">Directory</span><span class="p">.</span><span class="n">GetCurrentDirectory</span><span class="p">())</span>
            <span class="p">.</span><span class="n">UseIISIntegration</span><span class="p">()</span>
            <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="startup-class">
<h5><a class="toc-backref" href="#id5">Startup Class</a><a class="headerlink" href="#startup-class" title="Permalink to this headline">¶</a></h5>
<p>In your Startup class (which is basically the same across all the versions of ASP.NET Core) you then use <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code> to access the Autofac container builder and register things directly with Autofac.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span>public class Startup
{
  public Startup(IHostingEnvironment env)
  {
    // In ASP.NET Core 3.0 `env` will be an IWebHostEnvironment, not IHostingEnvironment.
    var builder = new ConfigurationBuilder()
        .SetBasePath(env.ContentRootPath)
        .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
        .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true)
        .AddEnvironmentVariables();
    this.Configuration = builder.Build();
  }

  public IConfigurationRoot Configuration { get; private set; }

  public ILifetimeScope AutofacContainer { get; private set; }

  // ConfigureServices is where you register dependencies. This gets
  // called by the runtime before the ConfigureContainer method, below.
  public void ConfigureServices(IServiceCollection services)
  {
    // Add services to the collection. Don&#39;t build or return
    // any IServiceProvider or the ConfigureContainer method
    // won&#39;t get called. Don&#39;t create a ContainerBuilder
    // for Autofac here, and don&#39;t call builder.Populate() - that
    // happens in the AutofacServiceProviderFactory for you.
    services.AddOptions();
  }

  // ConfigureContainer is where you can register things directly
  // with Autofac. This runs after ConfigureServices so the things
  // here will override registrations made in ConfigureServices.
  // Don&#39;t build the container; that gets done for you by the factory.
  public void ConfigureContainer(ContainerBuilder builder)
  {
    // Register your own things directly with Autofac here. Don&#39;t
    // call builder.Populate(), that happens in AutofacServiceProviderFactory
    // for you.
    builder.RegisterModule(new MyApplicationModule());
  }

  // Configure is where you add middleware. This is called after
  // ConfigureContainer. You can use IApplicationBuilder.ApplicationServices
  // here if you need to resolve things from the container.
  public void Configure(
    IApplicationBuilder app,
    ILoggerFactory loggerFactory)
  {
    // If, for some reason, you need a reference to the built container, you
    // can use the convenience extension method GetAutofacRoot.
    this.AutofacContainer = app.ApplicationServices.GetAutofacRoot();

    loggerFactory.AddConsole(this.Configuration.GetSection(&quot;Logging&quot;));
    loggerFactory.AddDebug();
    app.UseMvc();
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="configuration-method-naming-conventions">
<h4><a class="toc-backref" href="#id6">Configuration Method Naming Conventions</a><a class="headerlink" href="#configuration-method-naming-conventions" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Configure</span></code>, <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code>, and <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code> methods all support environment-specific naming conventions based on the <code class="docutils literal notranslate"><span class="pre">IHostingEnvironment.EnvironmentName</span></code> in your app. By default, the names are <code class="docutils literal notranslate"><span class="pre">Configure</span></code>, <code class="docutils literal notranslate"><span class="pre">ConfigureServices</span></code>, and <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code>. If you want environment-specific setup you can put the environment name after the <code class="docutils literal notranslate"><span class="pre">Configure</span></code> part, like <code class="docutils literal notranslate"><span class="pre">ConfigureDevelopment</span></code>, <code class="docutils literal notranslate"><span class="pre">ConfigureDevelopmentServices</span></code>, and <code class="docutils literal notranslate"><span class="pre">ConfigureDevelopmentContainer</span></code>. If a method isn’t present with a name matching the environment it’ll fall back to the default.</p>
<p>This means you don’t necessarily have to use <a class="reference internal" href="index.html#document-configuration/index"><span class="doc">Autofac configuration</span></a> to switch configuration between a development and production environment; you can set it up programmatically in <code class="docutils literal notranslate"><span class="pre">Startup</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">Startup</span><span class="p">(</span><span class="n">IHostingEnvironment</span> <span class="n">env</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Do Startup-ish things like read configuration.</span>
  <span class="p">}</span>

  <span class="c1">// This is the default if you don&#39;t have an environment specific method.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Add things to the service collection.</span>
  <span class="p">}</span>

  <span class="c1">// This only gets called if your environment is Development. The</span>
  <span class="c1">// default ConfigureServices won&#39;t be automatically called if this</span>
  <span class="c1">// one is called.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureDevelopmentServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Add things to the service collection that are only for the</span>
    <span class="c1">// development environment.</span>
  <span class="p">}</span>

  <span class="c1">// This is the default if you don&#39;t have an environment specific method.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Add things to the Autofac ContainerBuilder.</span>
  <span class="p">}</span>

  <span class="c1">// This only gets called if your environment is Production. The</span>
  <span class="c1">// default ConfigureContainer won&#39;t be automatically called if this</span>
  <span class="c1">// one is called.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureProductionContainer</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Add things to the ContainerBuilder that are only for the</span>
    <span class="c1">// production environment.</span>
  <span class="p">}</span>

  <span class="c1">// This is the default if you don&#39;t have an environment specific method.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span> <span class="n">ILoggerFactory</span> <span class="n">loggerFactory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Set up the application.</span>
  <span class="p">}</span>

  <span class="c1">// This only gets called if your environment is Staging. The</span>
  <span class="c1">// default Configure won&#39;t be automatically called if this one is called.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureStaging</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span> <span class="n">ILoggerFactory</span> <span class="n">loggerFactory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Set up the application for staging.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a feature of the application hosting in ASP.NET Core - it is not an Autofac behavior. The <a class="reference external" href="https://github.com/aspnet/Hosting/blob/rel/1.1.0/src/Microsoft.AspNetCore.Hosting/Internal/StartupLoader.cs">StartupLoader class in ASP.NET Core</a> is what locates the methods to call during app startup. Check that class out if you want a more in-depth understanding of how this works.</p>
</div>
<div class="section" id="dependency-injection-hooks">
<h4><a class="toc-backref" href="#id7">Dependency Injection Hooks</a><a class="headerlink" href="#dependency-injection-hooks" title="Permalink to this headline">¶</a></h4>
<p>Unlike <a class="reference internal" href="index.html#document-integration/aspnet"><span class="doc">ASP.NET classic integration</span></a>, ASP.NET Core is designed specifically with dependency injection in mind. What that means is if you’re trying to figure out, say, <a class="reference external" href="https://docs.asp.net/en/latest/mvc/views/dependency-injection.html">how to inject services into MVC views</a> that’s now controlled by (and documented by) ASP.NET Core - there’s not anything Autofac-specific you need to do other than set up your service provider as outlined above.</p>
<p>Here are some helpful links into the ASP.NET Core documentation with specific insight into DI integration:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.asp.net/en/latest/fundamentals/dependency-injection.html">ASP.NET Core dependency injection fundamentals</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/mvc/controllers/dependency-injection.html">Controller injection</a></li>
<li><a class="reference external" href="http://www.strathweb.com/2016/03/the-subtle-perils-of-controller-dependency-injection-in-asp-net-core-mvc/">The Subtle Perils of Controller Dependency Injection in ASP.NET Core MVC</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/mvc/controllers/filters.html#configuring-filters">Filter injection</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/mvc/views/dependency-injection.html">View injection</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/security/authorization/dependencyinjection.html">Authorization requirement handlers injection</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/migration/http-modules.html#loading-middleware-options-through-direct-injection">Middleware options injection</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/fundamentals/middleware.html">Middleware ‘Invoke’ method injection</a></li>
<li><a class="reference external" href="https://docs.asp.net/en/latest/data/entity-framework-6.html#setup-connection-strings-and-dependency-injection">Wiring up EF 6 with ASP.NET Core</a></li>
</ul>
</div>
<div class="section" id="differences-from-asp-net-classic">
<h4><a class="toc-backref" href="#id8">Differences From ASP.NET Classic</a><a class="headerlink" href="#differences-from-asp-net-classic" title="Permalink to this headline">¶</a></h4>
<p>If you’ve used Autofac’s other <a class="reference internal" href="index.html#document-integration/aspnet"><span class="doc">ASP.NET integration</span></a> then you may be interested in the key differences as you migrate to using ASP.NET Core.</p>
<ul class="simple">
<li><strong>Use InstancePerLifetimeScope instead of InstancePerRequest.</strong> In previous ASP.NET integration you could register a dependency as <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code> which would ensure only one instance of the dependency would be created per HTTP request. This worked because Autofac was in charge of <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">setting up the per-request lifetime scope</span></a>. With the introduction of <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.DependencyInjection</span></code>, the creation of per-request and other child lifetime scopes is now part of the <a class="reference external" href="http://blog.ploeh.dk/2014/05/19/conforming-container/">conforming container</a> provided by the framework, so all child lifetime scopes are treated equally - there’s no special “request level scope” anymore. Instead of registering your dependencies <code class="docutils literal notranslate"><span class="pre">InstancePerRequest</span></code>, use <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope</span></code> and you should get the same behavior. Note if you are creating <em>your own lifetime scopes</em> during web requests, you will get a new instance in these child scopes.</li>
<li><strong>No more DependencyResolver.</strong> Other ASP.NET integration mechanisms required setting up a custom Autofac-based dependency resolver in various locations. With <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.DependencyInjection</span></code> and the <code class="docutils literal notranslate"><span class="pre">Startup.ConfigureServices</span></code> method, you now just return the <code class="docutils literal notranslate"><span class="pre">IServiceProvider</span></code> and “magic happens.” Within controllers, classes, etc. if you need to manually do service location, get an <code class="docutils literal notranslate"><span class="pre">IServiceProvider</span></code>.</li>
<li><strong>No special middleware.</strong> The <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">OWIN integration</span></a> previously required registration of a special Autofac middleware to manage the request lifetime scope. <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.DependencyInjection</span></code> does the heavy lifting now, so there’s no additional middleware to register.</li>
<li><strong>No manual controller registration.</strong> You used to be required to register all of your controllers with Autofac so DI would work. The ASP.NET Core framework now automatically passes all controllers through service resolution so you don’t have to do that.</li>
<li><strong>No extensions for invoking middleware via dependency injection.</strong> The <a class="reference internal" href="index.html#document-integration/owin"><span class="doc">OWIN integration</span></a> had extensions like <code class="docutils literal notranslate"><span class="pre">UseAutofacMiddleware()</span></code> to allow DI into middleware. This happens automatically now through a combination of <a class="reference external" href="https://docs.asp.net/en/latest/fundamentals/middleware.html">auto-injected constructor parameters and dynamically resolved parameters to the Invoke method of middleware</a>. The ASP.NET Core framework takes care of it all.</li>
<li><strong>MVC and Web API are one thing.</strong> There used to be different ways to hook into DI based on whether you were using MVC or Web API. These two things are combined in ASP.NET Core so there’s only one dependency resolver to set up, only one configuration to maintain.</li>
<li><strong>Controllers aren’t resolved from the container; just controller constructor parameters.</strong> That means controller lifecycles, property injection, and other things aren’t managed by Autofac - they’re managed by ASP.NET Core. You can change that using <code class="docutils literal notranslate"><span class="pre">AddControllersAsServices()</span></code> - see the discussion below.</li>
</ul>
</div>
<div class="section" id="controllers-as-services">
<h4><a class="toc-backref" href="#id9">Controllers as Services</a><a class="headerlink" href="#controllers-as-services" title="Permalink to this headline">¶</a></h4>
<p>By default, ASP.NET Core will resolve the controller <em>parameters</em> from the container but doesn’t actually resolve <em>the controller</em> from the container. This usually isn’t an issue but it does mean:</p>
<ul class="simple">
<li>The lifecycle of the <em>controller</em> is handled by the framework, not the request lifetime.</li>
<li>The lifecycle of <em>controller constructor parameters</em> is handled by the request lifetime.</li>
<li>Special wiring that you may have done during registration of the controller (like setting up property injection) won’t work.</li>
</ul>
<p>You can change this by specifying <code class="docutils literal notranslate"><span class="pre">AddControllersAsServices()</span></code> when you register MVC with the service collection. Doing that will automatically register controller types into the <code class="docutils literal notranslate"><span class="pre">IServiceCollection</span></code> when the service provider factory calls <code class="docutils literal notranslate"><span class="pre">builder.Populate(services)</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="c1">// Omitting extra stuff so you can see the important part...</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Add controllers as services so they&#39;ll be resolved.</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddMvc</span><span class="p">().</span><span class="n">AddControllersAsServices</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// If you want to set up a controller for, say, property injection</span>
    <span class="c1">// you can override the controller registration after populating services.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyController</span><span class="p">&gt;().</span><span class="n">PropertiesAutowired</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a more detailed article <a class="reference external" href="http://www.strathweb.com/2016/03/the-subtle-perils-of-controller-dependency-injection-in-asp-net-core-mvc/">with a walkthrough on Filip Woj’s blog</a>. Note one of the commenters there <a class="reference external" href="http://www.strathweb.com/2016/03/the-subtle-perils-of-controller-dependency-injection-in-asp-net-core-mvc/#comment-2702995712">found some changes based on how RC2 handles controllers as services</a>.</p>
</div>
<div class="section" id="multitenant-support">
<h4><a class="toc-backref" href="#id10">Multitenant Support</a><a class="headerlink" href="#multitenant-support" title="Permalink to this headline">¶</a></h4>
<p>Due to the way ASP.NET Core is eager about generating the request lifetime scope it causes multitenant support to not quite work out of the box. Sometimes the <code class="docutils literal notranslate"><span class="pre">IHttpContextAccessor</span></code>, commonly used in tenant identification, also isn’t set up in time. The <a class="reference external" href="https://github.com/autofac/Autofac.AspNetCore.Multitenant">Autofac.AspNetCore.Multitenant</a> package was added to fix that.</p>
<p>To enable multitenant support:</p>
<ul class="simple">
<li>Add a reference to the <code class="docutils literal notranslate"><span class="pre">Autofac.AspNetCore.Multitenant</span></code> NuGet package.</li>
<li>In your <code class="docutils literal notranslate"><span class="pre">Program.Main</span></code> when building the web host include a call to the <code class="docutils literal notranslate"><span class="pre">UseServiceProviderFactory</span></code> extension and use the <code class="docutils literal notranslate"><span class="pre">AutofacMultitenantServiceProviderFactory</span></code>. Provide a callback that will configure your tenants.</li>
<li>In <code class="docutils literal notranslate"><span class="pre">Startup.ConfigureServices</span></code> and <code class="docutils literal notranslate"><span class="pre">Startup.ConfigureContainer</span></code> register things that go in the <strong>root container</strong> that aren’t tenant-specific.</li>
<li>In the callback (e.g., <code class="docutils literal notranslate"><span class="pre">Startup.ConfigureMultitenantContainer</span></code>) is where you build your multitenant container.</li>
</ul>
<p>Here’s an example of what you do in <code class="docutils literal notranslate"><span class="pre">Program.Main</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="n">Host</span>
      <span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="p">.</span><span class="n">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacMultitenantServiceProviderFactory</span><span class="p">(</span><span class="n">Startup</span><span class="p">.</span><span class="n">ConfigureMultitenantContainer</span><span class="p">))</span>
      <span class="p">.</span><span class="n">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webHostBuilder</span> <span class="p">=&gt;</span> <span class="n">webHostBuilder</span><span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;())</span>
      <span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="k">await</span> <span class="n">host</span><span class="p">.</span><span class="n">RunAsync</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>…and here’s what <code class="docutils literal notranslate"><span class="pre">Startup</span></code> looks like:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
  <span class="c1">// Omitting extra stuff so you can see the important part...</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// This will all go in the ROOT CONTAINER and is NOT TENANT SPECIFIC.</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddMvc</span><span class="p">();</span>

    <span class="c1">// This adds the required middleware to the ROOT CONTAINER and is required for multitenancy to work.</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddAutofacMultitenantRequestServices</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// This will all go in the ROOT CONTAINER and is NOT TENANT SPECIFIC.</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">static</span> <span class="n">MultitenantContainer</span> <span class="nf">ConfigureMultitenantContainer</span><span class="p">(</span><span class="n">IContainer</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// This is the MULTITENANT PART. Set up your tenant-specific stuff here.</span>
    <span class="kt">var</span> <span class="n">strategy</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTenantIdentificationStrategy</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">container</span><span class="p">);</span>
    <span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">cb</span> <span class="p">=&gt;</span> <span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TenantDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;());</span>
    <span class="k">return</span> <span class="n">mtc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-child-scope-as-a-root">
<h4><a class="toc-backref" href="#id11">Using a Child Scope as a Root</a><a class="headerlink" href="#using-a-child-scope-as-a-root" title="Permalink to this headline">¶</a></h4>
<p>In a complex application you may want to keep services partitioned such that the root container is shared across different parts of the app, but a child lifetime scope is used for the hosted portion (e.g., the ASP.NET Core piece).</p>
<p>In standard ASP.NET Core integration and generic hosted application support there’s an <code class="docutils literal notranslate"><span class="pre">AutofacChildLifetimeScopeServiceProviderFactory</span></code> you can use instead of the standard <code class="docutils literal notranslate"><span class="pre">AutofacServiceProviderFactory</span></code>. This allows you to provide configuration actions that will be attached to a specific named lifetime scope rather than a built container.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// create the root-container and register global dependencies</span>
    <span class="kt">var</span> <span class="n">containerBuilder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeGlobalDependency</span><span class="p">&gt;()</span>
      <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISomeGlobalDependency</span><span class="p">&gt;()</span>
      <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">containerBuilder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="c1">// The UseServiceProviderFactory call attaches the</span>
    <span class="c1">// Autofac provider to the generic hosting mechanism.</span>
      <span class="kt">var</span> <span class="n">hostOne</span> <span class="p">=</span> <span class="n">Host</span>
        <span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="p">.</span><span class="n">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacChildLifetimeScopeServiceProviderFactory</span><span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;root-one&quot;</span><span class="p">)))</span>
        <span class="p">.</span><span class="n">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webHostBuilder</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="n">webHostBuilder</span>
            <span class="p">.</span><span class="n">UseContentRoot</span><span class="p">(</span><span class="n">AppContext</span><span class="p">.</span><span class="n">BaseDirectory</span><span class="p">)</span>
            <span class="c1">// Each host listens to a different URL, they have the same root container to share SingleInstance</span>
            <span class="c1">// things, but they each have  their own logical root lifetime scope. Registering things</span>
            <span class="c1">// as `InstancePerMatchingLifetimeScope(&quot;root-one&quot;)` (the name of the scope given above)</span>
            <span class="c1">// will result in a singleton that&#39;s ONLY used by this first host.</span>
            <span class="p">.</span><span class="n">UseUrls</span><span class="p">(</span><span class="s">&quot;http://localhost:5000&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">StartupOne</span><span class="p">&gt;();</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="c1">// The UseServiceProviderFactory call attaches the</span>
    <span class="c1">// Autofac provider to the generic hosting mechanism.</span>
      <span class="kt">var</span> <span class="n">hostTwo</span> <span class="p">=</span> <span class="n">Host</span>
        <span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="p">.</span><span class="n">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacChildLifetimeScopeServiceProviderFactory</span><span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="s">&quot;root-two&quot;</span><span class="p">)))</span>
        <span class="p">.</span><span class="n">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webHostBuilder</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="n">webHostBuilder</span>
            <span class="p">.</span><span class="n">UseContentRoot</span><span class="p">(</span><span class="n">AppContext</span><span class="p">.</span><span class="n">BaseDirectory</span><span class="p">)</span>
            <span class="c1">// As with the first host, the second host will share the root container but have its own</span>
            <span class="c1">// root lifetime scope `root-two`. Things registered `InstancePerMatchingLifetimeScope(&quot;root-two&quot;)`</span>
            <span class="c1">// will be singletons ONLY used by this second host.</span>
            <span class="p">.</span><span class="n">UseUrls</span><span class="p">(</span><span class="s">&quot;http://localhost:5001&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">StartupTwo</span><span class="p">&gt;();</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">hostOne</span><span class="p">.</span><span class="n">RunAsync</span><span class="p">(),</span> <span class="n">hostTwo</span><span class="p">.</span><span class="n">RunAsync</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will change how your <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class works - you won’t use a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> directly in <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code>, now it’s an <code class="docutils literal notranslate"><span class="pre">AutofacChildLifetimeScopeConfigurationAdapter</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">StartupOne</span>
<span class="p">{</span>
  <span class="c1">// IHostingEnvironment when running applications below ASP.NET Core 3.0</span>
  <span class="k">public</span> <span class="nf">Startup</span><span class="p">(</span><span class="n">IWebHostEnvironment</span> <span class="n">env</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Fill this in if needed...</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// The usual ConfigureServices registrations on the service collection...</span>
  <span class="p">}</span>

  <span class="c1">// Here&#39;s the change for child lifetime scope usage! Register your &quot;root&quot;</span>
  <span class="c1">// child lifetime scope things with the adapter.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">AutofacChildLifetimeScopeConfigurationAdapter</span> <span class="n">config</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">config</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">builder</span> <span class="p">=&gt;</span> <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacHostOneModule</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span>
    <span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span>
    <span class="n">ILoggerFactory</span> <span class="n">loggerFactory</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// The usual app configuration stuff...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">StartupTwo</span>
<span class="p">{</span>
  <span class="c1">// IHostingEnvironment when running applications below ASP.NET Core 3.0</span>
  <span class="k">public</span> <span class="nf">Startup</span><span class="p">(</span><span class="n">IWebHostEnvironment</span> <span class="n">env</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Fill this in if needed...</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// The usual ConfigureServices registrations on the service collection...</span>
  <span class="p">}</span>

  <span class="c1">// Here&#39;s the change for child lifetime scope usage! Register your &quot;root&quot;</span>
  <span class="c1">// child lifetime scope things with the adapter.</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">AutofacChildLifetimeScopeConfigurationAdapter</span> <span class="n">config</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">config</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">builder</span> <span class="p">=&gt;</span> <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacHostTwoModule</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span>
    <span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span>
    <span class="n">ILoggerFactory</span> <span class="n">loggerFactory</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// The usual app configuration stuff...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you’re not using the service provider factory, the <code class="docutils literal notranslate"><span class="pre">Populate()</span></code> method offers an overload to allow you to specify a tagged child lifetime scope that should serve as the “container” for items.</p>
<p><a class="reference internal" href="index.html#document-integration/netcore"><span class="doc">The .NET Core integration documentation also shows an example of using a child lifetime scope as a root.</span></a></p>
<p>Using a child lifetime scope as the root is not compatible with multitenant support. You must choose one or the other, not both.</p>
</div>
<div class="section" id="example">
<h4><a class="toc-backref" href="#id12">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>There is an example project showing ASP.NET Core integration <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/AspNetCoreExample">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/blazor"></span><div class="section" id="blazor">
<h3>Blazor<a class="headerlink" href="#blazor" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://docs.microsoft.com/en-gb/aspnet/core/blazor/">ASP.NET Core Blazor</a> uses the generic app hosting in ASP.NET Core 3+ but the two <a class="reference external" href="https://docs.microsoft.com/en-gb/aspnet/core/blazor/hosting-models">hosting models</a> have slightly different integrations.</p>
<p><strong>Server-side</strong> implementations are configured in exactly the same way as any other <a class="reference external" href="aspnetcore">ASP.NET Core 3</a> application.</p>
<p><strong>Client-side</strong> injection is slightly more restricted due to requirements for <a class="reference external" href="https://webassembly.org">WebAssembly</a> hosting.</p>
<p>At present (as of 11/9/2019), some of the features around <code class="docutils literal notranslate"><span class="pre">Startup</span></code> classes are not available: <code class="docutils literal notranslate"><span class="pre">ConfiguresServices</span></code> and <code class="docutils literal notranslate"><span class="pre">ConfigureContainer</span></code> will not be executed by <code class="docutils literal notranslate"><span class="pre">UseBlazorStartup</span></code>.</p>
<p>The alternative is to use <code class="docutils literal notranslate"><span class="pre">UseServiceProviderFactory</span></code> with an instance of <code class="docutils literal notranslate"><span class="pre">AutofacServiceProviderFactory</span></code>. The <code class="docutils literal notranslate"><span class="pre">AutofacServiceProviderFactory</span></code> takes an <code class="docutils literal notranslate"><span class="pre">Action</span></code> on a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> which can be used for any registrations.</p>
<p>Example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">CreateHostBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">Build</span><span class="p">().</span><span class="n">Run</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">static</span> <span class="n">IWebAssemblyHostBuilder</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">BlazorWebAssemblyHost</span><span class="p">.</span><span class="n">CreateDefaultBuilder</span><span class="p">()</span>
      <span class="p">.</span><span class="n">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacServiceProviderFactory</span><span class="p">(</span><span class="n">Register</span><span class="p">))</span>
      <span class="p">.</span><span class="n">UseBlazorStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>

  <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// add any registrations here</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once registered, Blazor components can use <a class="reference external" href="https://docs.microsoft.com/en-gb/aspnet/core/blazor/dependency-injection">dependency injection</a> via the <a class="reference external" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/dependency-injection?view=aspnetcore-3.0#request-a-service-in-a-component">standard &#64;inject Razor directive</a>.</p>
</div>
<span id="document-integration/wcf"></span><div class="section" id="windows-communication-foundation-wcf">
<h3>Windows Communication Foundation (WCF)<a class="headerlink" href="#windows-communication-foundation-wcf" title="Permalink to this headline">¶</a></h3>
<p>WCF integration for both clients and services requires the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Wcf/">Autofac.Wcf NuGet package</a>.</p>
<p>WCF integration provides dependency injection integration for services as well as client proxies.  <strong>Due to WCF internals, there is no explicit support in WCF for per-request lifetime dependencies.</strong></p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#clients" id="id1">Clients</a></li>
<li><a class="reference internal" href="#services" id="id2">Services</a><ul>
<li><a class="reference internal" href="#quick-start" id="id3">Quick Start</a></li>
<li><a class="reference internal" href="#register-service-implementations" id="id4">Register Service Implementations</a><ul>
<li><a class="reference internal" href="#register-by-type" id="id5">Register By Type</a></li>
<li><a class="reference internal" href="#register-by-interface" id="id6">Register by Interface</a></li>
<li><a class="reference internal" href="#register-by-name" id="id7">Register by Name</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pick-the-right-host-factory" id="id8">Pick the Right Host Factory</a></li>
<li><a class="reference internal" href="#svc-less-services" id="id9">Svc-Less Services</a></li>
<li><a class="reference internal" href="#extensionless-services" id="id10">Extensionless Services</a></li>
<li><a class="reference internal" href="#was-hosting-and-non-http-activation" id="id11">WAS Hosting and Non-HTTP Activation</a></li>
<li><a class="reference internal" href="#self-hosting" id="id12">Self-Hosting</a></li>
<li><a class="reference internal" href="#handling-instancecontextmode-single-services" id="id13">Handling InstanceContextMode.Single Services</a><ul>
<li><a class="reference internal" href="#iis-was-hosted" id="id14">IIS/WAS Hosted</a></li>
<li><a class="reference internal" href="#self-hosted" id="id15">Self-Hosted</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulating-a-request-lifetime-scope" id="id16">Simulating a Request Lifetime Scope</a></li>
<li><a class="reference internal" href="#using-decorators-with-services" id="id17">Using Decorators With Services</a></li>
<li><a class="reference internal" href="#example" id="id18">Example</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="clients">
<h4><a class="toc-backref" href="#id1">Clients</a><a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h4>
<p>There are a couple of benefits to using Autofac in conjunction with your service client application:</p>
<ul class="simple">
<li><strong>Deterministic disposal</strong>: Automatically free resources consumed by proxies created by <code class="docutils literal notranslate"><span class="pre">ChannelFactory.CreateChannel&lt;T&gt;()</span></code>.</li>
<li><strong>Easy service proxy injection</strong>: For types that consume services you can easily inject a dependency on the service interface type.</li>
</ul>
<p>During application startup, for each service register a <code class="docutils literal notranslate"><span class="pre">ChannelFactory&lt;T&gt;</span></code> and a function that uses the factory to open channels:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the channel factory for the service. Make it</span>
<span class="c1">// SingleInstance since you don&#39;t need a new one each time.</span>
<span class="n">builder</span>
  <span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">ITrackListing</span><span class="p">&gt;(</span>
    <span class="k">new</span> <span class="nf">BasicHttpBinding</span><span class="p">(),</span>
    <span class="k">new</span> <span class="nf">EndpointAddress</span><span class="p">(</span><span class="s">&quot;http://localhost/TrackListingService&quot;</span><span class="p">)))</span>
  <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>

<span class="c1">// Register the service interface using a lambda that creates</span>
<span class="c1">// a channel from the factory. Include the UseWcfSafeRelease()</span>
<span class="c1">// helper to handle proper disposal.</span>
<span class="n">builder</span>
  <span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">ITrackListing</span><span class="p">&gt;&gt;().</span><span class="n">CreateChannel</span><span class="p">())</span>
  <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ITrackListing</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">UseWcfSafeRelease</span><span class="p">();</span>

<span class="c1">// You can also register other dependencies.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">AlbumPrinter</span><span class="p">&gt;();</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>In this example…</p>
<ul class="simple">
<li>The call to <code class="docutils literal notranslate"><span class="pre">CreateChannel()</span></code> isn’t executed until <code class="docutils literal notranslate"><span class="pre">ITrackListing</span></code> is requested from the container.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">UseWcfSafeRelease()</span></code> configuration option ensures that exception messages are not lost when disposing client channels.</li>
</ul>
<p>When consuming the service, add a constructor dependency as normal. This example shows an application that prints a track listing to the console using the remote <code class="docutils literal notranslate"><span class="pre">ITrackListing</span></code> service. It does this via the <code class="docutils literal notranslate"><span class="pre">AlbumPrinter</span></code> class:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">AlbumPrinter</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">ITrackListing</span> <span class="n">_trackListing</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">AlbumPrinter</span><span class="p">(</span><span class="n">ITrackListing</span> <span class="n">trackListing</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_trackListing</span> <span class="p">=</span> <span class="n">trackListing</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">PrintTracks</span><span class="p">(</span><span class="kt">string</span> <span class="n">artist</span><span class="p">,</span> <span class="kt">string</span> <span class="n">album</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">track</span> <span class="k">in</span> <span class="n">_trackListing</span><span class="p">.</span><span class="n">GetTracks</span><span class="p">(</span><span class="n">artist</span><span class="p">,</span> <span class="n">album</span><span class="p">))</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;{0} - {1}&quot;</span><span class="p">,</span> <span class="n">track</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">track</span><span class="p">.</span><span class="n">Title</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you resolve the <code class="docutils literal notranslate"><span class="pre">AlbumPrinter</span></code> class from a lifetime scope, the channel to the <code class="docutils literal notranslate"><span class="pre">ITrackListing</span></code> service will be injected for you.</p>
<p>Note that, given <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">the service proxy is disposable</span></a>, it should be resolved from a child lifetime scope, not the root container. Thus, if you have to manually resolve it (for whatever reason), be sure you’re creating a child scope from which to do it:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">lifetime</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">albumPrinter</span> <span class="p">=</span> <span class="n">lifetime</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">AlbumPrinter</span><span class="p">&gt;();</span>
  <span class="n">albumPrinter</span><span class="p">.</span><span class="n">PrintTracks</span><span class="p">(</span><span class="s">&quot;The Shins&quot;</span><span class="p">,</span> <span class="s">&quot;Wincing the Night Away&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="services">
<h4><a class="toc-backref" href="#id2">Services</a><a class="headerlink" href="#services" title="Permalink to this headline">¶</a></h4>
<div class="section" id="quick-start">
<h5><a class="toc-backref" href="#id3">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h5>
<p>To get Autofac integrated with WCF on the service side you need to reference the WCF integration NuGet package, register your services, and set the dependency resolver. You also need to update your <code class="docutils literal notranslate"><span class="pre">.svc</span></code> files to reference the Autofac service host factory.</p>
<p>Here’s a sample application startup block:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

  <span class="c1">// Register your service implementations.</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TestService</span><span class="p">.</span><span class="n">Service1</span><span class="p">&gt;();</span>

  <span class="c1">// Set the dependency resolver.</span>
  <span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
  <span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">container</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here’s a sample <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file.</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">ServiceHost</span>
    <span class="n">Service</span><span class="p">=</span><span class="s">&quot;TestService.Service1, TestService&quot;</span>
    <span class="n">Factory</span><span class="p">=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span> <span class="nt">%&gt;</span>
</pre></div>
</div>
<p>The sections below go into further detail about what each of these features do and how to use them.</p>
</div>
<div class="section" id="register-service-implementations">
<h5><a class="toc-backref" href="#id4">Register Service Implementations</a><a class="headerlink" href="#register-service-implementations" title="Permalink to this headline">¶</a></h5>
<p>You can register your service types in one of three ways: by type, by interface, or by name.</p>
<div class="section" id="register-by-type">
<h6><a class="toc-backref" href="#id5">Register By Type</a><a class="headerlink" href="#register-by-type" title="Permalink to this headline">¶</a></h6>
<p>Your first option is to simply register the service implementation type in the container and specify that implementation type in the .svc file. <strong>This is the most common usage.</strong></p>
<p>In your application startup, you’d have code like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TestService</span><span class="p">.</span><span class="n">Service1</span><span class="p">&gt;();</span>
<span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>And your <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file would specify the appropriate service implementation type and host factory, like this:</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">ServiceHost</span>
    <span class="n">Service</span><span class="p">=</span><span class="s">&quot;TestService.Service1, TestService&quot;</span>
    <span class="n">Factory</span><span class="p">=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span> <span class="nt">%&gt;</span>
</pre></div>
</div>
<p>Note that <strong>you need to use the fully-qualified name of your service in the .svc file</strong>, i.e. <code class="docutils literal notranslate"><span class="pre">Service=&quot;Namespace.ServiceType,</span> <span class="pre">AssemblyName&quot;</span></code>.</p>
</div>
<div class="section" id="register-by-interface">
<h6><a class="toc-backref" href="#id6">Register by Interface</a><a class="headerlink" href="#register-by-interface" title="Permalink to this headline">¶</a></h6>
<p>Your second option is to register the contract type in the container and specify the contract in the <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file. This is handy if you don’t want to change the <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file but do want to change the implementation type that will handle requests.</p>
<p>In your application startup, you’d have code like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TestService</span><span class="p">.</span><span class="n">Service1</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">TestService</span><span class="p">.</span><span class="n">IService1</span><span class="p">&gt;();</span>
<span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>And your .svc file would specify the service contract type and host factory, like this:</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">ServiceHost</span>
    <span class="n">Service</span><span class="p">=</span><span class="s">&quot;TestService.IService1, TestService&quot;</span>
    <span class="n">Factory</span><span class="p">=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span> <span class="nt">%&gt;</span>
</pre></div>
</div>
<p>Note that <strong>you need to use the fully-qualified name of your contract in the .svc file</strong>, i.e. <code class="docutils literal notranslate"><span class="pre">Service=&quot;Namespace.IContractType,</span> <span class="pre">AssemblyName&quot;</span></code>.</p>
</div>
<div class="section" id="register-by-name">
<h6><a class="toc-backref" href="#id7">Register by Name</a><a class="headerlink" href="#register-by-name" title="Permalink to this headline">¶</a></h6>
<p>The third option you have is to register a named service implementation in the container and specify that service name in the <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file. This is handy if you want even further abstraction away from the <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file.</p>
<p>In your application startup, you’d have code like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TestService</span><span class="p">.</span><span class="n">Service1</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="s">&quot;my-service&quot;</span><span class="p">);</span>
<span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that the service implementation type is <strong>registered as an object - this is important</strong>. Your service implementation won’t be found if it’s a named service and it’s not registered as an object.</p>
<p>Your <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file specifies the service name you registered and host factory, like this:</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">ServiceHost</span>
    <span class="n">Service</span><span class="p">=</span><span class="s">&quot;my-service&quot;</span>
    <span class="n">Factory</span><span class="p">=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span> <span class="nt">%&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pick-the-right-host-factory">
<h5><a class="toc-backref" href="#id8">Pick the Right Host Factory</a><a class="headerlink" href="#pick-the-right-host-factory" title="Permalink to this headline">¶</a></h5>
<p>WCF offers two service host factories. Autofac has corresponding implementations for each.</p>
<p>If you were using <code class="docutils literal notranslate"><span class="pre">ServiceHostFactory</span></code> in your <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file, update to the <code class="docutils literal notranslate"><span class="pre">AutofacServiceHostFactory</span></code>. This is the most common usage of Autofac and WCF.</p>
<p>If you were using <code class="docutils literal notranslate"><span class="pre">WebServiceHostFactory</span></code> in your <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file, update to <code class="docutils literal notranslate"><span class="pre">AutofacWebServiceHostFactory</span></code>.</p>
</div>
<div class="section" id="svc-less-services">
<h5><a class="toc-backref" href="#id9">Svc-Less Services</a><a class="headerlink" href="#svc-less-services" title="Permalink to this headline">¶</a></h5>
<p>If you want to use services without an <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file, Autofac will work with that.</p>
<p>As shown above, register your service with the container.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Service1</span><span class="p">&gt;();</span>
<span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>To use svc-less services, add a factory entry under the <code class="docutils literal notranslate"><span class="pre">serviceActivation</span></code> element in the <code class="docutils literal notranslate"><span class="pre">web.config</span></code> file. This ensures that the <code class="docutils literal notranslate"><span class="pre">AutofacServiceHostFactory</span></code> is used to activate the service.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;serviceHostingEnvironment</span> <span class="na">aspNetCompatibilityEnabled=</span><span class="s">&quot;true&quot;</span> <span class="na">multipleSiteBindingsEnabled=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;serviceActivations&gt;</span>
    <span class="nt">&lt;add</span> <span class="na">factory=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span>
         <span class="na">relativeAddress=</span><span class="s">&quot;~/Service1.svc&quot;</span>
         <span class="na">service=</span><span class="s">&quot;TestService.Service1, TestService&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/serviceActivations&gt;</span>
<span class="nt">&lt;/serviceHostingEnvironment&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="extensionless-services">
<h5><a class="toc-backref" href="#id10">Extensionless Services</a><a class="headerlink" href="#extensionless-services" title="Permalink to this headline">¶</a></h5>
<p>If you want extensionless services, register your service with the container as shown above.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Service1</span><span class="p">&gt;();</span>
<span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Then define a new <code class="docutils literal notranslate"><span class="pre">ServiceRoute</span></code> using the <code class="docutils literal notranslate"><span class="pre">AutofacServiceHostFactory</span></code> and service implementation type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">RouteTable</span><span class="p">.</span><span class="n">Routes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ServiceRoute</span><span class="p">(</span><span class="s">&quot;Service1&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">AutofacServiceHostFactory</span><span class="p">(),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Service1</span><span class="p">)));</span>
</pre></div>
</div>
<p>Finally, add the <code class="docutils literal notranslate"><span class="pre">UrlRoutingModule</span></code> to the <cite>web.config</cite> file.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;system.webServer&gt;</span>
  <span class="nt">&lt;modules</span> <span class="na">runAllManagedModulesForAllRequests=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;add</span> <span class="na">name=</span><span class="s">&quot;UrlRoutingModule&quot;</span> <span class="na">type=</span><span class="s">&quot;System.Web.Routing.UrlRoutingModule, System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/modules&gt;</span>
  <span class="nt">&lt;handlers&gt;</span>
    <span class="nt">&lt;add</span> <span class="na">name=</span><span class="s">&quot;UrlRoutingHandler&quot;</span> <span class="na">preCondition=</span><span class="s">&quot;integratedMode&quot;</span> <span class="na">verb=</span><span class="s">&quot;*&quot;</span> <span class="na">path=</span><span class="s">&quot;UrlRouting.axd&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/handlers&gt;</span>
<span class="nt">&lt;/system.webServer&gt;</span>
</pre></div>
</div>
<p>After configuring your application in IIS you will be able to access the WCF service at: <code class="docutils literal notranslate"><span class="pre">http://hostname/appname/Service1</span></code></p>
</div>
<div class="section" id="was-hosting-and-non-http-activation">
<h5><a class="toc-backref" href="#id11">WAS Hosting and Non-HTTP Activation</a><a class="headerlink" href="#was-hosting-and-non-http-activation" title="Permalink to this headline">¶</a></h5>
<p>When hosting WCF Services in WAS (Windows Activation Service), you are not given an opportunity to build your container in the <code class="docutils literal notranslate"><span class="pre">Application_Start</span></code> event defined in your <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code> because WAS doesn’t use the standard ASP.NET pipeline.</p>
<p>The alternative approach is to place a code file in your <code class="docutils literal notranslate"><span class="pre">App_Code</span></code> folder that contains a type with a <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">static</span> <span class="pre">void</span> <span class="pre">AppInitialize()</span></code> method.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nn">MyNamespace</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">AppStart</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AppInitialize</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="c1">// Put your container initialization here.</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can read more about <code class="docutils literal notranslate"><span class="pre">AppInitialize()</span></code> in “<a class="reference external" href="https://docs.microsoft.com/en-us/archive/blogs/wenlong/how-to-initialize-hosted-wcf-services">How to Initialize Hosted WCF Services</a>”.</p>
</div>
<div class="section" id="self-hosting">
<h5><a class="toc-backref" href="#id12">Self-Hosting</a><a class="headerlink" href="#self-hosting" title="Permalink to this headline">¶</a></h5>
<p>To use the integration when self-hosting your WCF Service, the key is to use the <code class="docutils literal notranslate"><span class="pre">AddDependencyInjectionBehavior()</span></code> extension on your service host. Set up your container with your registrations, but <strong>don’t set the global container</strong>. Instead, apply the container to your service host.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">ContainerBuilder</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Service1</span><span class="p">&gt;();</span>

<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Uri</span> <span class="n">address</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Uri</span><span class="p">(</span><span class="s">&quot;http://localhost:8080/Service1&quot;</span><span class="p">);</span>
    <span class="n">ServiceHost</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ServiceHost</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Service1</span><span class="p">),</span> <span class="n">address</span><span class="p">);</span>
    <span class="n">host</span><span class="p">.</span><span class="n">AddServiceEndpoint</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IEchoService</span><span class="p">),</span> <span class="k">new</span> <span class="n">BasicHttpBinding</span><span class="p">(),</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span>

    <span class="c1">// Here&#39;s the important part - attaching the DI behavior to the service host</span>
    <span class="c1">// and passing in the container.</span>
    <span class="n">host</span><span class="p">.</span><span class="n">AddDependencyInjectionBehavior</span><span class="p">&lt;</span><span class="n">IService1</span><span class="p">&gt;(</span><span class="n">container</span><span class="p">);</span>

    <span class="n">host</span><span class="p">.</span><span class="n">Description</span><span class="p">.</span><span class="n">Behaviors</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ServiceMetadataBehavior</span> <span class="p">{</span><span class="n">HttpGetEnabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">HttpGetUrl</span> <span class="p">=</span> <span class="n">address</span><span class="p">});</span>
    <span class="n">host</span><span class="p">.</span><span class="n">Open</span><span class="p">();</span>

    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;The host has been opened.&quot;</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>

    <span class="n">host</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
    <span class="n">Environment</span><span class="p">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="handling-instancecontextmode-single-services">
<h5><a class="toc-backref" href="#id13">Handling InstanceContextMode.Single Services</a><a class="headerlink" href="#handling-instancecontextmode-single-services" title="Permalink to this headline">¶</a></h5>
<p>Using <code class="docutils literal notranslate"><span class="pre">InstanceContextMode.Single</span></code> is not a good idea from a scalability point of view, and allowing multiple callers to access the single instance using <code class="docutils literal notranslate"><span class="pre">ConcurrencyMode.Multiple</span></code> means that you also need to be careful about multiple threads accessing any shared state. If possible you should create services with <code class="docutils literal notranslate"><span class="pre">InstanceContextMode.PerCall</span></code>.</p>
<div class="section" id="iis-was-hosted">
<h6><a class="toc-backref" href="#id14">IIS/WAS Hosted</a><a class="headerlink" href="#iis-was-hosted" title="Permalink to this headline">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">AutofacServiceHostFactory</span></code> identifies WCF services that are marked with <code class="docutils literal notranslate"><span class="pre">InstanceContextMode.Single</span></code> and will ensure that the <code class="docutils literal notranslate"><span class="pre">ServiceHost</span></code> can be provided with a singleton instance from the container. An exception will be thrown if the service in the container was not registered with the <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> lifetime scope. It is also invalid to register a <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> service in the container for a WCF service that is not marked as <code class="docutils literal notranslate"><span class="pre">InstanceContextMode.Single</span></code>.</p>
</div>
<div class="section" id="self-hosted">
<h6><a class="toc-backref" href="#id15">Self-Hosted</a><a class="headerlink" href="#self-hosted" title="Permalink to this headline">¶</a></h6>
<p>It is possible to manually perform constructor injection for service marked with <code class="docutils literal notranslate"><span class="pre">InstanceContextMode.Single</span></code> when self-hosting. This is achieved by resolving a <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> service from the container and then passing that into the constructor of a manually created <code class="docutils literal notranslate"><span class="pre">ServiceHost</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the SingleInstance from the container.</span>
<span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IService1</span><span class="p">&gt;();</span>
<span class="c1">// Pass it into the ServiceHost preventing it from creating an instance with the default constructor.</span>
<span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ServiceHost</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="k">new</span> <span class="n">Uri</span><span class="p">(</span><span class="s">&quot;http://localhost:8080/Service1&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="simulating-a-request-lifetime-scope">
<h5><a class="toc-backref" href="#id16">Simulating a Request Lifetime Scope</a><a class="headerlink" href="#simulating-a-request-lifetime-scope" title="Permalink to this headline">¶</a></h5>
<p>As noted earlier, <strong>due to WCF internals, there is no explicit support in WCF for per-request lifetime dependencies.</strong></p>
<p>The way Autofac hooks into WCF, it uses an <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.dispatcher.iinstanceprovider(v=vs.110).aspx">instance provider</a> to resolve your service and dependencies. The instance provider makes use of the service instance context to track the lifetime scope in which your service and its dependencies live.</p>
<p>What that boils down to: A lifetime scope is created based on the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.servicebehaviorattribute.instancecontextmode(v=vs.110).aspx">instance context mode</a> of your service.</p>
<p><a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.servicebehaviorattribute.instancecontextmode(v=vs.110).aspx">If you leave it default, that’s “per session.”</a> One instance of your service will be created when a client calls it, and subsequent calls from that client will get the same instance.</p>
<p>However, if you want to simulate a per-request lifetime scope, you can:</p>
<ul class="simple">
<li>Set your service to be instance-per-call using the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.servicebehaviorattribute.instancecontextmode(v=vs.110).aspx">WCF ServiceBehaviorAttribute</a>.</li>
<li>Register your service and dependencies to be instance-per-lifetime-scope.</li>
</ul>
<p>Doing those two things, you’ll get a new lifetime scope for every call (because the WCF instance context will want to create a new service instance per call). Your service and dependencies will then be resolved as just one time within that instance context lifetime scope - effectively a per-request lifetime.</p>
<p>Note this can backfire on you if you have dependencies that are shared between your per-call services and your per-session / single-instance services: In those, you don’t get a new instance of the service for each call, which means the shared dependencies (registered “instance per lifetime scope”) will also be a singleton for the life of the service. You may need to experiment and test with dependencies registered as “instance per call” or “instance per lifetime scope” to get the desired effect.</p>
</div>
<div class="section" id="using-decorators-with-services">
<h5><a class="toc-backref" href="#id17">Using Decorators With Services</a><a class="headerlink" href="#using-decorators-with-services" title="Permalink to this headline">¶</a></h5>
<p>The standard Autofac service hosting works well for almost every case, but if you are using <a class="reference internal" href="index.html#document-advanced/adapters-decorators"><span class="doc">decorators</span></a> on your WCF service implementation (not the dependencies, but the actual service implementation) then you need to use the <a class="reference internal" href="index.html#document-advanced/multitenant"><span class="doc">multitenant WCF service hosting mechanism</span></a> rather than the standard Autofac service host.</p>
<p>You do not need to use a multitenant container, pass a tenant ID, or use any of the other multitenant options, but you do need to use the multitenant service host.</p>
<p>The reason for this is that WCF hosting (internal to .NET) requires the host be initialized with a concrete type (not abstract/interface) and once the type is provided you can’t change it. When using decorators, we don’t actually know the final type (once you chain together all the decorators, etc.) until you resolve the first instance… but that happens after the host needs the type name. The multitenant hosting mechanism works around this by adding another dynamic proxy - an empty, target-free concrete class that implements the service interface. When the WCF host needs an implementation, one of these dynamic proxies gets fired up and the actual implementation (in this case, your decorated WCF implementation) will be the target.</p>
<p>Again, you only need to do this if you’re decorating the service implementation class itself. If you are only decorating/adapting dependencies of the service implementation, you do not need the multitenant host. Standard hosting will work.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id18">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>The Autofac example repository has a <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/WcfExample">WCF service implementation example</a> as well as <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MvcExample">an MVC application that acts as a client for that service</a>.</p>
<p>There are also examples showing a <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MultitenantExample.WcfService">multitenant WCF service</a> and <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MultitenantExample.MvcApplication">associated client</a> to illustrate how <a class="reference internal" href="index.html#document-advanced/multitenant"><span class="doc">multitenant service hosting</span></a> works.</p>
</div>
</div>
</div>
<span id="document-integration/servicefabric"></span><div class="section" id="service-fabric">
<h3>Service Fabric<a class="headerlink" href="#service-fabric" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://www.nuget.org/packages/Autofac.ServiceFabric">Autofac.ServiceFabric</a> package enables integration of Autofac with <a class="reference external" href="https://azure.microsoft.com/en-us/services/service-fabric/">Service Fabric</a> services.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#quick-start" id="id2">Quick Start</a></li>
<li><a class="reference internal" href="#per-request-scopes" id="id3">Per-Request Scopes</a></li>
<li><a class="reference internal" href="#example" id="id4">Example</a></li>
</ul>
</div>
<div class="section" id="quick-start">
<h4><a class="toc-backref" href="#id2">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h4>
<p>In your <code class="docutils literal notranslate"><span class="pre">Main</span></code> program method, build up your container and register services using the Autofac extensions. This will attach service registrations from the container and the <code class="docutils literal notranslate"><span class="pre">ServiceRuntime</span></code>. Dispose of the container at app shutdown.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Integration.ServiceFabric</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">DemoService</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Program</span>
  <span class="p">{</span>
      <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
      <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
          <span class="c1">// The ServiceManifest.xml file defines one or more service type names.</span>
          <span class="c1">// Registering a service maps a service type name to a .NET type.</span>
          <span class="c1">// When Service Fabric creates an instance of this service type,</span>
          <span class="c1">// an instance of the class is created in this host process.</span>

          <span class="c1">// Start with the trusty old container builder.</span>
          <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

          <span class="c1">// Register any regular dependencies.</span>
          <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="n">LoggerModule</span><span class="p">(</span><span class="n">ServiceEventSource</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Message</span><span class="p">));</span>

          <span class="c1">// Register the Autofac magic for Service Fabric support.</span>
          <span class="n">builder</span><span class="p">.</span><span class="n">RegisterServiceFabricSupport</span><span class="p">();</span>

          <span class="c1">// Register a stateless service...</span>
          <span class="n">builder</span><span class="p">.</span><span class="n">RegisterStatelessService</span><span class="p">&lt;</span><span class="n">DemoStatelessService</span><span class="p">&gt;(</span><span class="s">&quot;DemoStatelessServiceType&quot;</span><span class="p">);</span>

          <span class="c1">// ...and/or register a stateful service.</span>
          <span class="c1">// builder.RegisterStatefulService&lt;DemoStatefulService&gt;(&quot;DemoStatefulServiceType&quot;);</span>

          <span class="k">using</span> <span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">())</span>
          <span class="p">{</span>
            <span class="n">ServiceEventSource</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">ServiceTypeRegistered</span><span class="p">(</span>
              <span class="n">Process</span><span class="p">.</span><span class="n">GetCurrentProcess</span><span class="p">().</span><span class="n">Id</span><span class="p">,</span>
              <span class="k">typeof</span><span class="p">(</span><span class="n">DemoStatelessService</span><span class="p">).</span><span class="n">Name</span><span class="p">);</span>

            <span class="c1">// Prevents this host process from terminating so services keep running.</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">ServiceEventSource</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">ServiceHostInitializationFailed</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
        <span class="k">throw</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="per-request-scopes">
<h4><a class="toc-backref" href="#id3">Per-Request Scopes</a><a class="headerlink" href="#per-request-scopes" title="Permalink to this headline">¶</a></h4>
<p>It is possible to achieve a “per request” style scoping mechanism by making use of the <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationships</span></a> supported by Autofac.</p>
<p>For example, if you have a stateless service, its lifetime is effectively a singleton. You would want to use the <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">Func&lt;Owned&lt;T&gt;&gt;</span></code> relationships (for non-disposable vs. disposable components, respectively) to inject an auto-generated factory into your service. Your service could then resolve dependencies as needed.</p>
<p>For example, say you have a user service that is stateless and it needs to read from some backing store that shouldn’t be a singleton. Assuming the backing store is <code class="docutils literal notranslate"><span class="pre">IDisposable</span></code> you’d want to use <code class="docutils literal notranslate"><span class="pre">Func&lt;Owned&lt;T&gt;&gt;</span></code> and inject it like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">UserService</span><span class="p">:</span> <span class="n">IUserService</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">IUserStore</span><span class="p">&gt;&gt;</span> <span class="n">_userStoreFactory</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">UserService</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">IUserStore</span><span class="p">&gt;&gt;</span> <span class="n">userStoreFactory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_userStoreFactory</span> <span class="p">=</span> <span class="n">userStoreFactory</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">GetNameAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">userStore</span> <span class="p">=</span> <span class="n">_userStoreFactory</span><span class="p">().</span><span class="n">Value</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="k">await</span> <span class="n">userStore</span><span class="p">.</span><span class="n">GetNameAsync</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While there’s no “built in” semantics around per-request handling specifically, you can do a lot with the <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationships</span></a> so it’s worth becoming familiar with them.</p>
</div>
<div class="section" id="example">
<h4><a class="toc-backref" href="#id4">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>There is an example project showing Service Fabric integration <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/ServiceFabricDemo">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/mef"></span><div class="section" id="managed-extensibility-framework-mef">
<h3>Managed Extensibility Framework (MEF)<a class="headerlink" href="#managed-extensibility-framework-mef" title="Permalink to this headline">¶</a></h3>
<p>The Autofac MEF integration allows you to expose extensibility points in your applications using the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dd460648(VS.100).aspx">Managed Extensibility Framework</a>.</p>
<p>To use MEF in an Autofac application, you must reference the .NET framework <code class="docutils literal notranslate"><span class="pre">System.ComponentModel.Composition.dll</span></code> assembly and get the <a class="reference external" href="https://www.nuget.org/packages/Autofac.Mef/">Autofac.Mef</a> package from NuGet.</p>
<p><strong>Note this is a one-way operation</strong> MEF integration allows Autofac to resolve items that were registered in MEF, but it doesn’t allow MEF to resolve items that were registered in Autofac.</p>
<div class="section" id="consuming-mef-extensions-in-autofac">
<h4>Consuming MEF Extensions in Autofac<a class="headerlink" href="#consuming-mef-extensions-in-autofac" title="Permalink to this headline">¶</a></h4>
<p>The Autofac/MEF integration allows MEF catalogs to be registered with the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code>, then use the <code class="docutils literal notranslate"><span class="pre">RegisterComposablePartCatalog()</span></code> extension method.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">catalog</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DirectoryCatalog</span><span class="p">(</span><span class="s">@&quot;C:\MyExtensions&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterComposablePartCatalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">);</span>
</pre></div>
</div>
<p>All MEF catalog types are supported:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TypeCatalog</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">AssemblyCatalog</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">DirectoryCatalog</span></code></li>
</ul>
<p>Once MEF catalogs are registered, exports within them can be resolved through the Autofac container or by injection into other components. For example, say you have a class with an export type defined using MEF attributes:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Export(typeof(IService))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Component</span> <span class="p">:</span> <span class="n">IService</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>Using MEF catalogs, you can register that type. Autofac will find the exported interface and provide the service.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">catalog</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TypeCatalog</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Component</span><span class="p">));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterComposablePartCatalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// The resolved IService will be implemented</span>
<span class="c1">// by type Component.</span>
<span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="providing-autofac-components-to-mef-extensions">
<h4>Providing Autofac Components to MEF Extensions<a class="headerlink" href="#providing-autofac-components-to-mef-extensions" title="Permalink to this headline">¶</a></h4>
<p>Autofac components aren’t automatically available for MEF extensions to import. Which is to say, if you use Autofac to resolve a component that was registered using MEF, only other services registered using MEF will be allowed to satisfy its dependencies.</p>
<p>To provide an Autofac component to MEF, the <code class="docutils literal notranslate"><span class="pre">Exported()</span></code> extension method must be used:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Component</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">Exported</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;().</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;SomeData&quot;</span><span class="p">,</span> <span class="m">42</span><span class="p">));</span>
</pre></div>
</div>
<p>Again, this is a one-way operation. It allows Autofac to provide dependencies to MEF components that are registered within Autofac - it doesn’t export Autofac registrations to be resolved from a MEF catalog.</p>
</div>
<div class="section" id="using-metadata">
<h4>Using Metadata<a class="headerlink" href="#using-metadata" title="Permalink to this headline">¶</a></h4>
<p>Autofac MEF integration adds the <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> relationship support to the already existing <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T&gt;</span></code> support.</p>
<p>For example, say you have an interface defining metadata like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IAgeMetadata</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can register Autofac services and use the <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> relationship by adding the MEF metadata registration sources:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// This adds the MEF relationship registration sources.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterMetadataRegistrationSources</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Component</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithMetadata</span><span class="p">&lt;</span><span class="n">IAgeMetadata</span><span class="p">&gt;(</span><span class="n">m</span> <span class="p">=&gt;</span> <span class="n">m</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="k">value</span> <span class="p">=&gt;</span> <span class="k">value</span><span class="p">.</span><span class="n">Age</span><span class="p">,</span> <span class="m">42</span><span class="p">));</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>You can then resolve a <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> from that:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">lazy</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="n">Component</span><span class="p">,</span> <span class="n">IAgeMetadata</span><span class="p">&gt;&gt;();</span>

  <span class="c1">// lazy.Metadata.Age == 42</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>KNOWN ISSUE</strong>: If you have a MEF <code class="docutils literal notranslate"><span class="pre">[Imports]</span></code> over a <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> value, the object <code class="docutils literal notranslate"><span class="pre">T</span></code> is <strong>not lazy instantiated</strong> at this time. <a class="reference external" href="https://github.com/autofac/Autofac.Mef/issues/1">There is an issue filed for this on the Autofac.Mef repo.</a> If you’re looking to help, we’d love a PR for it!</p>
</div>
<div class="section" id="known-issues-gotchas">
<h4>Known Issues / Gotchas<a class="headerlink" href="#known-issues-gotchas" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>MEF integration with Autofac is one-way.</strong> It does not allow MEF composition containers access to things registered in Autofac. Instead, it basically takes MEF registration semantics and helps populate an Autofac container. You are expected to resolve things from Autofac after that, not from a MEF container.</li>
<li><strong>Lazy metadata imports don’t work.</strong> If you have a MEF <code class="docutils literal notranslate"><span class="pre">[Imports]</span></code> over a <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> value, the object <code class="docutils literal notranslate"><span class="pre">T</span></code> is <strong>not lazy instantiated</strong> at this time. <a class="reference external" href="https://github.com/autofac/Autofac.Mef/issues/1">There is an issue filed for this on the Autofac.Mef repo.</a></li>
<li><strong>Open generic exports are not supported.</strong> If you have an attribute like <code class="docutils literal notranslate"><span class="pre">[Export(typeof(A&lt;&gt;))</span></code> on a MEF component, Autofac will not properly handle that export and resolving objects of that type will fail. <a class="reference external" href="https://github.com/autofac/Autofac.Mef/issues/4">There is an issue `There is an issue filed for this on the Autofac.Mef repo.</a></li>
</ul>
</div>
</div>
<span id="document-integration/csl"></span><div class="section" id="common-service-locator">
<h3>Common Service Locator<a class="headerlink" href="#common-service-locator" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://www.nuget.org/packages/Autofac.Extras.CommonServiceLocator/">Autofac.Extras.CommonServiceLocator</a> package allows you to use Autofac as the backing store for services in places where you require <a class="reference external" href="https://www.nuget.org/packages/CommonServiceLocator/">Microsoft Common Service Locator</a> integration.</p>
<p>The Autofac.Extras.CommonServiceLocator package will also work in conjunction with the <a class="reference internal" href="index.html#document-integration/entlib"><span class="doc">Autofac Microsoft Enterprise Library integration package</span></a>.</p>
<p>To use the Common Service Locator integration, build your Autofac container as normal, then simply set the current service locator to an <code class="docutils literal notranslate"><span class="pre">AutofacServiceLocator</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Perform registrations and build the container.</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// Set the service locator to an AutofacServiceLocator.</span>
<span class="kt">var</span> <span class="n">csl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacServiceLocator</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">ServiceLocator</span><span class="p">.</span><span class="n">SetLocatorProvider</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">csl</span><span class="p">);</span>
</pre></div>
</div>
</div>
<span id="document-integration/entlib"></span><div class="section" id="enterprise-library-5">
<h3>Enterprise Library 5<a class="headerlink" href="#enterprise-library-5" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://www.nuget.org/packages/Autofac.Extras.EnterpriseLibraryConfigurator/">The Autofac.Extras.EnterpriseLibraryConfigurator package</a> provides a way to use Autofac as the backing store for dependency injection in <a class="reference external" href="http://entlib.codeplex.com/releases/view/43135">Microsoft Enterprise Library 5</a> instead of using Unity. It does this in conjunction with <a class="reference internal" href="index.html#document-integration/csl"><span class="doc">the Autofac Common Service Locator implementation</span></a>.</p>
<p><strong>In Enterprise Library 6, Microsoft removed the tightly-coupled dependency resolution mechanisms from the application blocks so there’s no more need for this configurator past Enterprise Library 5.</strong></p>
<div class="section" id="using-the-configurator">
<h4>Using the Configurator<a class="headerlink" href="#using-the-configurator" title="Permalink to this headline">¶</a></h4>
<p>The simplest way to use the configurator is to set up your Enterprise Library configuration in your <code class="docutils literal notranslate"><span class="pre">app.config</span></code> or <code class="docutils literal notranslate"><span class="pre">web.config</span></code> and use the <code class="docutils literal notranslate"><span class="pre">RegisterEnterpriseLibrary()</span></code> extension. This extension parses the configuration and performs the necessary registrations. You then need to set the <code class="docutils literal notranslate"><span class="pre">EnterpriseLibraryContainer.Current</span></code> to use an <code class="docutils literal notranslate"><span class="pre">AutofacServiceLocator</span></code> from <a class="reference internal" href="index.html#document-integration/csl"><span class="doc">the Autofac Common Service Locator implementation</span></a>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterEnterpriseLibrary</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">csl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacServiceLocator</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">EnterpriseLibraryContainer</span><span class="p">.</span><span class="n">Current</span> <span class="p">=</span> <span class="n">csl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-a-registration-source">
<h4>Specifying a Registration Source<a class="headerlink" href="#specifying-a-registration-source" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">RegisterEnterpriseLibrary()</span></code> extension does allow you to specify your own <code class="docutils literal notranslate"><span class="pre">IConfigurationSource</span></code> so if your configuration is not in <code class="docutils literal notranslate"><span class="pre">app.config</span></code> or <code class="docutils literal notranslate"><span class="pre">web.config</span></code> you can still use Autofac.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">GetYourConfigurationSource</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterEnterpriseLibrary</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">csl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacServiceLocator</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">EnterpriseLibraryContainer</span><span class="p">.</span><span class="n">Current</span> <span class="p">=</span> <span class="n">csl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>There is an example project showing Enterprise Library 5 configuration along with the Exception Handling Block <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/EnterpriseLibraryExample.MvcApplication">in the Autofac examples repository</a>.</p>
</div>
</div>
<span id="document-integration/nhibernate"></span><div class="section" id="nhibernate">
<h3>NHibernate<a class="headerlink" href="#nhibernate" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://chadly.net/2009/05/dependency-injection-with-nhibernate-and-autofac/">http://chadly.net/2009/05/dependency-injection-with-nhibernate-and-autofac/</a></p>
</div>
<span id="document-integration/moq"></span><div class="section" id="moq">
<h3>Moq<a class="headerlink" href="#moq" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/Moq/moq4">Moq</a> integration package allows you to automatically create mock dependencies for both concrete and mock abstract instances in unit tests using an Autofac container. You can <a class="reference external" href="https://www.nuget.org/packages/Autofac.Extras.Moq">get the Autofac.Extras.Moq package on NuGet</a>.</p>
<div class="section" id="getting-started">
<h4>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h4>
<p>Given you have a system under test and a dependency:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SystemUnderTest</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">SystemUnderTest</span><span class="p">(</span><span class="n">IDependency</span> <span class="n">dependency</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IDependency</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When writing your unit test, use the <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.Moq.AutoMock</span></code> class to instantiate the system under test. Doing this will automatically inject a mock dependency into the constructor for you. At the time you create the <code class="docutils literal notranslate"><span class="pre">AutoMock</span></code> factory, you can specify default mock behavior:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">AutoMock.GetLoose()</span></code> - creates automatic mocks using loose mocking behavior.</li>
<li><code class="docutils literal notranslate"><span class="pre">AutoMock.GetStrict()</span></code> - creates automatic mocks using strict mocking behavior.</li>
<li><code class="docutils literal notranslate"><span class="pre">AutoMock.GetFromRepository(repo)</span></code> - creates mocks based on an existing configured repository.</li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">mock</span> <span class="p">=</span> <span class="n">AutoMock</span><span class="p">.</span><span class="n">GetLoose</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// The AutoMock class will inject a mock IDependency</span>
    <span class="c1">// into the SystemUnderTest constructor</span>
    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="n">mock</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">SystemUnderTest</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-mocks">
<h4>Configuring Mocks<a class="headerlink" href="#configuring-mocks" title="Permalink to this headline">¶</a></h4>
<p>You can configure the automatic mocks and/or assert calls on them as you would normally with Moq.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">mock</span> <span class="p">=</span> <span class="n">AutoMock</span><span class="p">.</span><span class="n">GetLoose</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// Arrange - configure the mock</span>
    <span class="n">mock</span><span class="p">.</span><span class="n">Mock</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">Setup</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">GetValue</span><span class="p">()).</span><span class="n">Returns</span><span class="p">(</span><span class="s">&quot;expected value&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="n">mock</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">SystemUnderTest</span><span class="p">&gt;();</span>

    <span class="c1">// Act</span>
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">DoWork</span><span class="p">();</span>

    <span class="c1">// Assert - assert on the mock</span>
    <span class="n">mock</span><span class="p">.</span><span class="n">Mock</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">Verify</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">GetValue</span><span class="p">());</span>
    <span class="n">Assert</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span><span class="s">&quot;expected value&quot;</span><span class="p">,</span> <span class="n">actual</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SystemUnderTest</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IDependency</span> <span class="n">dependency</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SystemUnderTest</span><span class="p">(</span><span class="n">IDependency</span> <span class="n">strings</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">dependency</span> <span class="p">=</span> <span class="n">strings</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">dependency</span><span class="p">.</span><span class="n">GetValue</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IDependency</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="nf">GetValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-specific-dependencies">
<h4>Configuring Specific Dependencies<a class="headerlink" href="#configuring-specific-dependencies" title="Permalink to this headline">¶</a></h4>
<p>You can configure the <code class="docutils literal notranslate"><span class="pre">AutoMock</span></code> to provide a specific instance for a given service type (or apply any other registration behaviour),
by using the <code class="docutils literal notranslate"><span class="pre">beforeBuild</span></code> callback argument to <code class="docutils literal notranslate"><span class="pre">GetLoose</span></code>, <code class="docutils literal notranslate"><span class="pre">GetStrict</span></code> or <code class="docutils literal notranslate"><span class="pre">GetFromRepository</span></code>, in a similar manner
to configuring a new Lifetime Scope:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">dependency</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dependency</span><span class="p">();</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">mock</span> <span class="p">=</span> <span class="n">AutoMock</span><span class="p">.</span><span class="n">GetLoose</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">RegisterInstance</span><span class="p">(</span><span class="n">dependency</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;())</span>
  <span class="p">{</span>
    <span class="c1">// Returns your registered instance.</span>
    <span class="kt">var</span> <span class="n">dep</span> <span class="p">=</span> <span class="n">mock</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>

    <span class="c1">// If SystemUnderTest depends on IDependency, it will get your dependency instance.</span>
    <span class="kt">var</span> <span class="n">underTest</span> <span class="p">=</span> <span class="n">mock</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">SystemUnderTest</span><span class="p">&gt;();</span>

    <span class="c1">// ...and the rest of the test.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cfg</span></code> argument passed to your callback is a regular Autofac <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> instance, so you can
do any of the registration behaviour you’re used to in a normal set up.</p>
<p>You can also configure the <code class="docutils literal notranslate"><span class="pre">AutoMock</span></code> to use any existing mock, through the <code class="docutils literal notranslate"><span class="pre">RegisterMock</span></code> extension method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">mockA</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mock</span><span class="p">&lt;</span><span class="n">IServiceA</span><span class="p">&gt;();</span>
  <span class="n">mockA</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">RunA</span><span class="p">());</span>

  <span class="c1">// mockA is automatically registered as providing IServiceA</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">mock</span> <span class="p">=</span> <span class="n">AutoMock</span><span class="p">.</span><span class="n">GetLoose</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">RegisterMock</span><span class="p">(</span><span class="n">mockA</span><span class="p">)))</span>
  <span class="p">{</span>
    <span class="c1">// mockA will be injected into TestComponent as IServiceA</span>
    <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">mock</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">TestComponent</span><span class="p">&gt;();</span>

    <span class="c1">// ...and the rest of the test</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-integration/fakeiteasy"></span><div class="section" id="fakeiteasy">
<h3>FakeItEasy<a class="headerlink" href="#fakeiteasy" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://fakeiteasy.github.io">FakeItEasy</a> integration package allows you to automatically create fake dependencies for both concrete and fake abstract instances in unit tests using an Autofac container.</p>
<p>Array types, <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;T&gt;</span></code> types, and concrete types will be created via the underlying container, which is automatically configured with <a class="reference internal" href="index.html#document-advanced/registration-sources"><span class="doc">the AnyConcreteTypeNotAlreadyRegisteredSource</span></a>, while other interfaces and abstract classes will be created as FakeItEasy Fakes.</p>
<p>You can <a class="reference external" href="https://nuget.org/packages/Autofac.Extras.FakeItEasy">get the Autofac.Extras.FakeItEasy package on NuGet</a>.</p>
<div class="section" id="getting-started">
<h4>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h4>
<p>Given you have a system under test and a dependency:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SystemUnderTest</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">SystemUnderTest</span><span class="p">(</span><span class="n">IDependency</span> <span class="n">dependency</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IDependency</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When writing your unit test, use the <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.FakeItEasy.AutoFake</span></code> class to instantiate the system under test. Doing this will automatically inject a fake dependency into the constructor for you.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fake</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoFake</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// The AutoFake class will inject a fake IDependency</span>
    <span class="c1">// into the SystemUnderTest constructor</span>
    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="n">fake</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">SystemUnderTest</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-fakes">
<h4>Configuring Fakes<a class="headerlink" href="#configuring-fakes" title="Permalink to this headline">¶</a></h4>
<p>You can configure the automatic fakes and/or assert calls on them as you would normally with FakeItEasy.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fake</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoFake</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// Arrange - configure the fake</span>
    <span class="n">A</span><span class="p">.</span><span class="n">CallTo</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">fake</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">GetValue</span><span class="p">()).</span><span class="n">Returns</span><span class="p">(</span><span class="s">&quot;expected value&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="n">fake</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">SystemUnderTest</span><span class="p">&gt;();</span>

    <span class="c1">// Act</span>
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">DoWork</span><span class="p">();</span>

    <span class="c1">// Assert - assert on the fake</span>
    <span class="n">A</span><span class="p">.</span><span class="n">CallTo</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">fake</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">GetValue</span><span class="p">()).</span><span class="n">MustHaveHappened</span><span class="p">();</span>
    <span class="n">Assert</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span><span class="s">&quot;expected value&quot;</span><span class="p">,</span> <span class="n">actual</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SystemUnderTest</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IDependency</span> <span class="n">dependency</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SystemUnderTest</span><span class="p">(</span><span class="n">IDependency</span> <span class="n">strings</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">dependency</span> <span class="p">=</span> <span class="n">strings</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">dependency</span><span class="p">.</span><span class="n">GetValue</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IDependency</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="nf">GetValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-specific-dependencies">
<h4>Configuring Specific Dependencies<a class="headerlink" href="#configuring-specific-dependencies" title="Permalink to this headline">¶</a></h4>
<p>You can configure the <code class="docutils literal notranslate"><span class="pre">AutoFake</span></code> to provide a specific instance for a given service type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fake</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoFake</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">dependency</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dependency</span><span class="p">();</span>
    <span class="n">fake</span><span class="p">.</span><span class="n">Provide</span><span class="p">(</span><span class="n">dependency</span><span class="p">);</span>

    <span class="c1">// ...and the rest of the test.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also configure the <code class="docutils literal notranslate"><span class="pre">AutoFake</span></code> to provide a specific implementation type for a given service type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fake</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoFake</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// Configure a component type that doesn&#39;t require</span>
    <span class="c1">// constructor parameters.</span>
    <span class="n">fake</span><span class="p">.</span><span class="n">Provide</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">,</span> <span class="n">Dependency</span><span class="p">&gt;();</span>

    <span class="c1">// Configure a component type that has some</span>
    <span class="c1">// constructor parameters passed in. Use Autofac</span>
    <span class="c1">// parameters in the list.</span>
    <span class="n">fake</span><span class="p">.</span><span class="n">Provide</span><span class="p">&lt;</span><span class="n">IOtherDependency</span><span class="p">,</span> <span class="n">OtherDependency</span><span class="p">&gt;(</span>
                <span class="k">new</span> <span class="nf">NamedParameter</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;service-identifier&quot;</span><span class="p">),</span>
                <span class="k">new</span> <span class="nf">TypedParameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Guid</span><span class="p">),</span> <span class="n">Guid</span><span class="p">.</span><span class="n">NewGuid</span><span class="p">()));</span>

    <span class="c1">// ...and the rest of the test.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="options-for-fakes">
<h4>Options for Fakes<a class="headerlink" href="#options-for-fakes" title="Permalink to this headline">¶</a></h4>
<p>You can specify options for fake creation using optional constructor parameters on <code class="docutils literal notranslate"><span class="pre">AutoFake</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">fake</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoFake</span><span class="p">(</span>
    <span class="c1">// Create fakes with strict behavior (unconfigured calls throw exceptions)</span>
    <span class="n">strict</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>

    <span class="c1">// Calls to fakes of abstract types will call the base methods on the abstract types</span>
    <span class="n">callsBaseMethods</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>

    <span class="c1">// Provide an action to perform upon the creation of each fake</span>
    <span class="n">onFakeCreated</span><span class="p">:</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}))</span>
<span class="p">{</span>
  <span class="c1">// Use the fakes/run the test.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Be careful when mixing these options. It makes no sense to specify <code class="docutils literal notranslate"><span class="pre">callsBaseMethods</span></code> with any other options, as it will override them. When both <code class="docutils literal notranslate"><span class="pre">onFakeCreated</span></code> and <code class="docutils literal notranslate"><span class="pre">strict</span></code> are specified, the configuration supplied to <code class="docutils literal notranslate"><span class="pre">onFakeCreated</span></code> will override <code class="docutils literal notranslate"><span class="pre">strict</span></code>, as applicable.</p>
</div>
</div>
</div>
</div>
<span id="document-best-practices/index"></span><div class="section" id="best-practices-and-recommendations">
<h2>Best Practices and Recommendations<a class="headerlink" href="#best-practices-and-recommendations" title="Permalink to this headline">¶</a></h2>
<p>You can always ask for Autofac usage guidance <a class="reference external" href="https://stackoverflow.com/questions/tagged/autofac">on StackOverflow</a> using the <code class="docutils literal notranslate"><span class="pre">autofac</span></code> tag or in <a class="reference external" href="https://groups.google.com/forum/#forum/autofac">the discussion group</a>, but these quick tips can help get you going.</p>
<div class="section" id="always-resolve-dependencies-from-nested-lifetimes">
<h3>Always Resolve Dependencies from Nested Lifetimes<a class="headerlink" href="#always-resolve-dependencies-from-nested-lifetimes" title="Permalink to this headline">¶</a></h3>
<p>Autofac is designed to <a class="reference internal" href="index.html#document-lifetime/disposal"><span class="doc">track and dispose of resources</span></a> for you. To ensure this happens, make sure that long-running applications are partitioned into units of work (requests or transactions) and that services are resolved through unit of work level lifetime scopes. The <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">per-request lifetime scope support in ASP.NET</span></a> is an example of this technique.</p>
</div>
<div class="section" id="structure-configuration-with-modules">
<h3>Structure Configuration with Modules<a class="headerlink" href="#structure-configuration-with-modules" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> give structure to container configuration and allow deployment-time settings to be injected. Rather than using <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">XML configuration</span></a> alone, consider modules for a more flexible approach. Modules can always be combined with XML configuration for a best-of-both-worlds experience.</p>
</div>
<div class="section" id="use-as-t-in-delegate-registrations">
<h3>Use As&lt;T&gt;() in Delegate Registrations<a class="headerlink" href="#use-as-t-in-delegate-registrations" title="Permalink to this headline">¶</a></h3>
<p>Autofac infers implementation type from the expressions you use to register components:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Component</span><span class="p">()).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IComponent</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>…makes the type <code class="docutils literal notranslate"><span class="pre">Component</span></code> the <code class="docutils literal notranslate"><span class="pre">LimitType</span></code> of the component. These other type casting mechanisms are equivalent but don’t provide the correct <code class="docutils literal notranslate"><span class="pre">LimitType</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Works, but avoid this</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">IComponent</span><span class="p">)</span><span class="k">new</span> <span class="n">Component</span><span class="p">());</span>

<span class="c1">// Works, but avoid this</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IComponent</span><span class="p">&gt;(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Component</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="use-constructor-injection">
<h3>Use Constructor Injection<a class="headerlink" href="#use-constructor-injection" title="Permalink to this headline">¶</a></h3>
<p>The concept of using constructor injection for required dependencies and property injection for optional dependencies is quite well known. An alternative, however, is to use the <a class="reference external" href="http://en.wikipedia.org/wiki/Null_Object_pattern">“Null Object”</a> or <a class="reference external" href="http://martinfowler.com/eaaCatalog/specialCase.html">“Special Case”</a> pattern to provide default, do-nothing implementations for the optional service. This prevents the possibility of special-case code in the implementation of the component (e.g. <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(Logger</span> <span class="pre">!=</span> <span class="pre">null)</span> <span class="pre">Logger.Log(&quot;message&quot;);</span></code>).</p>
</div>
<div class="section" id="use-relationship-types-not-service-locators">
<h3>Use Relationship Types, Not Service Locators<a class="headerlink" href="#use-relationship-types-not-service-locators" title="Permalink to this headline">¶</a></h3>
<p>Giving components access to the container, storing it in a public static property, or making functions like <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> available on a global “IoC” class defeats the purpose of using dependency injection. Such designs have more in common with the <a class="reference external" href="http://martinfowler.com/articles/injection.html#UsingAServiceLocator">Service Locator</a> pattern.</p>
<p>If components have a dependency on the container (or on a lifetime scope), look at how they’re using the container to retrieve services, and add those services to the component’s (dependency injected) constructor arguments instead.</p>
<p>Use <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">relationship types</span></a> for components that need to instantiate other components or interact with the container in more advanced ways.</p>
</div>
<div class="section" id="register-components-from-least-to-most-specific">
<h3>Register Components from Least-to-Most Specific<a class="headerlink" href="#register-components-from-least-to-most-specific" title="Permalink to this headline">¶</a></h3>
<p>Autofac overrides component registrations by default. This means that an application can register all of its default components, then read an associated configuration file to override any that have been customized for the deployment environment.</p>
</div>
<div class="section" id="use-profilers-for-performance-checking">
<h3>Use Profilers for Performance Checking<a class="headerlink" href="#use-profilers-for-performance-checking" title="Permalink to this headline">¶</a></h3>
<p>Before doing any performance optimization or making assumptions about potential memory leaks, <strong>always run a profiler</strong> like <a class="reference external" href="http://code.google.com/p/slimtune/">SlimTune</a>, <a class="reference external" href="http://www.jetbrains.com/profiler/">dotTrace</a>, or <a class="reference external" href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/">ANTS</a> to see where time is truly being spent. It might not be where you think.</p>
</div>
<div class="section" id="register-once-resolve-many">
<h3>Register Once, Resolve Many<a class="headerlink" href="#register-once-resolve-many" title="Permalink to this headline">¶</a></h3>
<p>Don’t register components during units of work if you can avoid it; it is more expensive to register a component than resolve one. Use nested lifetime scopes and appropriate <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">instance scopes</span></a> to keep per-unit-of-work instances separate.</p>
</div>
<div class="section" id="register-frequently-used-components-with-lambdas">
<h3>Register Frequently-Used Components with Lambdas<a class="headerlink" href="#register-frequently-used-components-with-lambdas" title="Permalink to this headline">¶</a></h3>
<p>If you do need to squeeze extra performance out of Autofac, your best bet is to identify the most frequently-created components and register them using an expression rather than by type, e.g.:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Component</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Becomes:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Component</span><span class="p">());</span>
</pre></div>
</div>
<p>This can yield an improvement of up to 10x faster <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> calls, but only makes sense for components that appear in many object graphs. See <a class="reference internal" href="index.html#document-register/index"><span class="doc">the registration documentation</span></a> for more on lambda components.</p>
</div>
<div class="section" id="consider-a-container-as-immutable">
<h3>Consider a Container as Immutable<a class="headerlink" href="#consider-a-container-as-immutable" title="Permalink to this headline">¶</a></h3>
<p>Starting from Autofac 5.x the container is immutable. There are several potential risks associated with updating a container after it has been built. Some examples include:</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#document-lifetime/startup"><span class="doc">Auto-start components</span></a> will have already run and potentially used registrations you’ve overridden during update. These auto-start components will not re-run.</li>
<li>Services that have already been resolved may have references to incorrect dependencies based on the additions made.</li>
<li>Disposable components may have already been resolved and will stick around until their owning lifetime scope is disposed - even if the new registrations would imply the disposable component shouldn’t be used.</li>
<li>Component registrations that subscribe to lifetime events may be subscribed to the wrong events after the update - events don’t all get re-initialized during update.</li>
</ul>
<p>In order to prevent any of these risks to become a problem, it is no longer an option to update the container after construction.</p>
<p><strong>Instead of updating the container, consider registering updates or changes in a child lifetime scope.</strong> <a class="reference internal" href="index.html#document-lifetime/working-with-scopes"><span class="doc">There are examples of this in the lifetime scope documentation.</span></a></p>
</div>
</div>
<span id="document-advanced/index"></span><div class="section" id="advanced-topics">
<h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-advanced/registration-sources"></span><div class="section" id="registration-sources">
<h3>Registration Sources<a class="headerlink" href="#registration-sources" title="Permalink to this headline">¶</a></h3>
<p>A <em>registration source</em> is a way to dynamically feed registrations into an Autofac component context (e.g., container or lifetime scope).</p>
<p>Registration sources are created by implementing the <code class="docutils literal notranslate"><span class="pre">IRegistrationSource</span></code> interface. Many of the Autofac features are implemented this way - for example, the <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationship types</span></a> are added via registration sources. (You didn’t think we actually registered every single type of collection manually into the container, did you?) <a class="reference external" href="http://nblumhardt.com/2010/01/declarative-context-adapters-autofac2/">Nick Blumhardt has a great blog article about how this works.</a></p>
<p>Registration sources are great when you don’t have a finite set of registrations you can add to a container. Many times, <a class="reference internal" href="index.html#document-register/scanning"><span class="doc">assembly scanning</span></a> and/or <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">use of modules</span></a> can address dynamic registration concerns… but when all else fails or those means don’t accomplish what you’re looking to do, a registration source may be the way to go.</p>
<div class="section" id="any-concrete-type-not-already-registered-source">
<h4>“Any Concrete Type Not Already Registered” Source<a class="headerlink" href="#any-concrete-type-not-already-registered-source" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">AnyConcreteTypeNotAlreadyRegisteredSource</span></code>, or “ACTNARS” as we call it, is an example of a registration source that Autofac ships with that allows you to resolve any concrete type from the Autofac container regardless of whether or not you specifically registered it. People moving from other inversion-of-control containers may be used to this sort of behavior, so ACTNARS is a way to bridge that gap.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource</span></code> by adding it to your container.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterSource</span><span class="p">(</span><span class="k">new</span> <span class="n">AnyConcreteTypeNotAlreadyRegisteredSource</span><span class="p">());</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-a-registration-source">
<h4>Implementing a Registration Source<a class="headerlink" href="#implementing-a-registration-source" title="Permalink to this headline">¶</a></h4>
<p>The best way to show how to implement a registration source is through a simple example.</p>
<p>Let’s say you have a factory that is responsible for generating some sort of event handler class. You need to generate them through the factory rather than through Autofac, so you don’t have the handlers themselves registered with Autofac. At the same time, there’s not a good way to say “when a person asks for any event handler, generate it through this special factory.” This is a great example of where a registration source can come in handy.</p>
<p>For the example, let’s define a simple event handler base/abstract class and a couple of implementations.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseHandler</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">string</span> <span class="nf">Handle</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Handled: &quot;</span> <span class="p">+</span> <span class="n">message</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HandlerA</span> <span class="p">:</span> <span class="n">BaseHandler</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">Handle</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;[A] &quot;</span> <span class="p">+</span> <span class="k">base</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HandlerB</span> <span class="p">:</span> <span class="n">BaseHandler</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">Handle</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;[B] &quot;</span> <span class="p">+</span> <span class="k">base</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s create a factory interface and implementation.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IHandlerFactory</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">GetHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">BaseHandler</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HandlerFactory</span> <span class="p">:</span> <span class="n">IHandlerFactory</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">T</span> <span class="n">GetHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">BaseHandler</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">Activator</span><span class="p">.</span><span class="n">CreateInstance</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, let’s create a couple of consuming classes that use the handlers.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ConsumerA</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">HandlerA</span> <span class="n">_handler</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">ConsumerA</span><span class="p">(</span><span class="n">HandlerA</span> <span class="n">handler</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_handler</span> <span class="p">=</span> <span class="n">handler</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="s">&quot;ConsumerA&quot;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="k">public</span> <span class="k">class</span> <span class="nc">ConsumerB</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">HandlerB</span> <span class="n">_handler</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">ConsumerB</span><span class="p">(</span><span class="n">HandlerB</span> <span class="n">handler</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_handler</span> <span class="p">=</span> <span class="n">handler</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="s">&quot;ConsumerB&quot;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that we have the services and the consumers, let’s make a registration source. In the example source, we’ll…</p>
<ol class="arabic simple">
<li>Determine if the resolve operation is asking for a <code class="docutils literal notranslate"><span class="pre">BaseHandler</span></code> type or not. If it’s not, the source won’t provide any registration to satisfy the resolve request.</li>
<li>Build up the dynamic registration for the specific type of <code class="docutils literal notranslate"><span class="pre">BaseHandler</span></code> derivative being requested, which will include the lambda that invokes the provider/factory to get the instance.</li>
<li>Return the dynamic registration to the resolve operation so it can do the work.</li>
</ol>
<p>Here’s the code for the registration source.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">Autofac</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Core</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Core.Activators.Delegate</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Core.Lifetime</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Core.Registration</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HandlerRegistrationSource</span> <span class="p">:</span> <span class="n">IRegistrationSource</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IComponentRegistration</span><span class="p">&gt;</span> <span class="n">RegistrationsFor</span><span class="p">(</span>
    <span class="n">Service</span> <span class="n">service</span><span class="p">,</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="n">Service</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IComponentRegistration</span><span class="p">&gt;&gt;</span> <span class="n">registrationAccessor</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">swt</span> <span class="p">=</span> <span class="n">service</span> <span class="k">as</span> <span class="n">IServiceWithType</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">swt</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="p">!</span><span class="k">typeof</span><span class="p">(</span><span class="n">BaseHandler</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">swt</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// It&#39;s not a request for the base handler type, so skip it.</span>
      <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">IComponentRegistration</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="c1">// This is where the magic happens!</span>
    <span class="kt">var</span> <span class="n">registration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ComponentRegistration</span><span class="p">(</span>
      <span class="n">Guid</span><span class="p">.</span><span class="n">NewGuid</span><span class="p">(),</span>
      <span class="k">new</span> <span class="nf">DelegateActivator</span><span class="p">(</span><span class="n">swt</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
          <span class="c1">// In this example, the factory itself is assumed to be registered</span>
          <span class="c1">// with Autofac, so we can resolve the factory. If you want to hard</span>
          <span class="c1">// code the factory here, you can do that, too.</span>
          <span class="kt">var</span> <span class="n">provider</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IHandlerFactory</span><span class="p">&gt;();</span>

          <span class="c1">// Our factory interface is generic, so we have to use a bit of</span>
          <span class="c1">// reflection to make the call.</span>
          <span class="kt">var</span> <span class="n">method</span> <span class="p">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">GetType</span><span class="p">().</span><span class="n">GetMethod</span><span class="p">(</span><span class="s">&quot;GetHandler&quot;</span><span class="p">).</span><span class="n">MakeGenericMethod</span><span class="p">(</span><span class="n">swt</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">);</span>

          <span class="c1">// In the end, return the object from the factory.</span>
          <span class="k">return</span> <span class="n">method</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
        <span class="p">}),</span>
      <span class="k">new</span> <span class="nf">CurrentScopeLifetime</span><span class="p">(),</span>
      <span class="n">InstanceSharing</span><span class="p">.</span><span class="n">None</span><span class="p">,</span>
      <span class="n">InstanceOwnership</span><span class="p">.</span><span class="n">OwnedByLifetimeScope</span><span class="p">,</span>
      <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="n">service</span> <span class="p">},</span>
      <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;());</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">IComponentRegistration</span><span class="p">[]</span> <span class="p">{</span> <span class="n">registration</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsAdapterForIndividualComponents</span> <span class="p">{</span> <span class="k">get</span><span class="p">{</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last step is to register everything with Autofac - the registration source, the factory, and the consuming classes. Notice, though, that we don’t have to register the actual handlers themselves because the registration source takes care of that.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HandlerFactory</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IHandlerFactory</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterSource</span><span class="p">(</span><span class="k">new</span> <span class="n">HandlerRegistrationSource</span><span class="p">());</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsumerA</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsumerB</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Now when you resolve one of your handler consumers, you’ll get the correct handler.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">consumer</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ConsumerA</span><span class="p">&gt;();</span>

  <span class="c1">// Calling this will yield the following output on the console:</span>
  <span class="c1">// [A] Handled: ConsumerA</span>
  <span class="n">consumer</span><span class="p">.</span><span class="n">DoWork</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-advanced/adapters-decorators"></span><div class="section" id="adapters-and-decorators">
<h3>Adapters and Decorators<a class="headerlink" href="#adapters-and-decorators" title="Permalink to this headline">¶</a></h3>
<div class="section" id="adapters">
<h4>Adapters<a class="headerlink" href="#adapters" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a> takes one service contract and adapts it (like a wrapper) to another.</p>
<p>This <a class="reference external" href="http://nblumhardt.com/2010/04/lightweight-adaptation-coming-soon/">introductory article</a> describes a concrete example of the adapter pattern and how you can work with it in Autofac.</p>
<p>Autofac provides built-in adapter registration so you can register a set of services and have them each automatically adapted to a different interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the services to be adapted</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SaveCommand</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICommand</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">,</span> <span class="s">&quot;Save File&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OpenCommand</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICommand</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">,</span> <span class="s">&quot;Open File&quot;</span><span class="p">);</span>

<span class="c1">// Then register the adapter. In this case, the ICommand</span>
<span class="c1">// registrations are using some metadata, so we&#39;re</span>
<span class="c1">// adapting Meta&lt;ICommand&gt; instead of plain ICommand.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAdapter</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ICommand</span><span class="p">&gt;,</span> <span class="n">ToolbarButton</span><span class="p">&gt;(</span>
   <span class="n">cmd</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ToolbarButton</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="n">cmd</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;Name&quot;</span><span class="p">]));</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// The resolved set of buttons will have two buttons</span>
<span class="c1">// in it - one button adapted for each of the registered</span>
<span class="c1">// ICommand instances.</span>
<span class="kt">var</span> <span class="n">buttons</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ToolbarButton</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="decorators">
<h4>Decorators<a class="headerlink" href="#decorators" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> is somewhat similar to the adapter pattern, where one service “wraps” another. However, in contrast to adapters, decorators expose the <em>same service</em> as what they’re decorating. The point of using decorators is to add functionality to an object without changing the object’s signature.</p>
<p>Autofac provides built-in decorator registration so you can register services and have them automatically wrapped with decorator classes.</p>
<div class="section" id="simplified-syntax">
<h5>Simplified Syntax<a class="headerlink" href="#simplified-syntax" title="Permalink to this headline">¶</a></h5>
<p>Autofac 4.9.0 <a class="reference external" href="https://alexmg.com/posts/upcoming-decorator-enhancements-in-autofac-4-9">came with a simplified decorator syntax</a> that can be used as an alternative to the classic syntax (below). It is easier to use and has a bit more flexibility than the earlier mechanism.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the services to be decorated.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SaveCommandHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OpenCommandHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;();</span>

<span class="c1">// Then register the decorator. You can register multiple</span>
<span class="c1">// decorators and they&#39;ll be applied in the order that you</span>
<span class="c1">// register them. In this example, all ICommandHandlers</span>
<span class="c1">// will be decorated with logging and diagnostics decorators.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">&lt;</span><span class="n">LoggingDecorator</span><span class="p">,</span> <span class="n">ICommandHandler</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">&lt;</span><span class="n">DiagnosticDecorator</span><span class="p">,</span> <span class="n">ICommandHandler</span><span class="p">&gt;();</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// The resolved set of commands will have two items</span>
<span class="c1">// in it, both of which will be wrapped in the decorators.</span>
<span class="kt">var</span> <span class="n">handlers</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
<p>If you don’t know the type up front, you can manually specify instead of using the generic:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">LoggingDecorator</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DiagnosticDecorator</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">));</span>
</pre></div>
</div>
<p>If you want to manually instantiate your decorators or do more complex decorator creation, that’s also possible.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;(</span>
  <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ComplexDecorator</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>In the lambda, <code class="docutils literal notranslate"><span class="pre">context</span></code> is the <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> in which the resolution is happening (so you could resolve other things if needed); <code class="docutils literal notranslate"><span class="pre">parameters</span></code> is an <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;Parameter&gt;</span></code> with all the parameters passed in; and <code class="docutils literal notranslate"><span class="pre">instance</span></code> is the service instance being decorated. Keep in mind that if you have multiple decorators being chained, <code class="docutils literal notranslate"><span class="pre">instance</span></code> may be a <em>decorator instance</em> rather than the root/base thing being decorated.</p>
<p>Decoration is supported on open generics.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the open generic to be decorated.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CommandHandler</span><span class="p">&lt;&gt;)</span>
       <span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;);</span>

<span class="c1">// Then register the decorator. You can register multiple</span>
<span class="c1">// decorators and they&#39;ll be applied in the order that you</span>
<span class="c1">// register them. In this example, all ICommandHandler&lt;T&gt; instances</span>
<span class="c1">// will be decorated with logging and diagnostics decorators.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGenericDecorator</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">LoggingDecorator</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGenericDecorator</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DiagnosticDecorator</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;));</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// The resolved handler will be wrapped in both decorators.</span>
<span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">Save</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
<p>Decoration can be conditional. A context object is provided to registrations that allows you to decide whether or not to apply the decorator:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Only add the error handler decorator to the command handler if</span>
<span class="c1">// there are no other decorators applied.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">&lt;</span><span class="n">ErrorHandlerDecorator</span><span class="p">,</span> <span class="n">ICommandHandler</span><span class="p">&gt;(</span>
  <span class="n">context</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">context</span><span class="p">.</span><span class="n">AppliedDecorators</span><span class="p">.</span><span class="n">Any</span><span class="p">());</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGenericDecorator</span><span class="p">(</span>
  <span class="k">typeof</span><span class="p">(</span><span class="n">ErrorHandlerDecorator</span><span class="p">&lt;&gt;),</span>
  <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
  <span class="n">context</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">context</span><span class="p">.</span><span class="n">AppliedDecorators</span><span class="p">.</span><span class="n">Any</span><span class="p">());</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">context</span></code> in those lambdas is an <code class="docutils literal notranslate"><span class="pre">IDecoratorContext</span></code> with information about the list of applied decorators, the actual service type being resolved, and more.</p>
<p>You can use that context to make decisions in your decorators if you want. It can be injected into your decorator as a constructor parameter.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ErrorHandlerDecorator</span> <span class="p">:</span> <span class="n">ICommandHandler</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICommandHandler</span> <span class="n">_decorated</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IDecoratorContext</span> <span class="n">_context</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ErrorHandlerDecorator</span><span class="p">(</span><span class="n">ICommandHandler</span> <span class="n">decorated</span><span class="p">,</span> <span class="n">IDecoratorContext</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_decorated</span> <span class="p">=</span> <span class="n">decorated</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">decorated</span><span class="p">));</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_context</span> <span class="p">=</span> <span class="n">context</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">HandleCommand</span><span class="p">(</span><span class="n">Command</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_context</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">.</span><span class="n">GetCustomAttribute</span><span class="p">&lt;</span><span class="n">SkipHandlingAttribute</span><span class="p">&gt;()</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// run the command without handling the errors</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// add the special error handling logic</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>You cannot specify a lifetime scope on a decorator.</strong> The lifetime of a decorator is tied to the lifetime of the thing it decorates. The service and all decorators get disposed at the same time. If you decorate a singleton, all the decorators are also going to be singletons. If you decorate something that’s instance per request (e.g., in a web app) the decorators will also live for the whole request.</p>
</div>
<div class="section" id="classic-syntax">
<h5>Classic Syntax<a class="headerlink" href="#classic-syntax" title="Permalink to this headline">¶</a></h5>
<p>The “classic syntax” has been around since Autofac 2.4 and still works today. It’s more complicated than the newer syntax but if you have some existing code that uses it, that code will continue to work.</p>
<p>This <a class="reference external" href="http://nblumhardt.com/2011/01/decorator-support-in-autofac-2-4/">article</a> has some details about how decorators work in Autofac.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the services to be decorated. You have to</span>
<span class="c1">// name them rather than register them As&lt;ICommandHandler&gt;()</span>
<span class="c1">// so the *decorator* can be the As&lt;ICommandHandler&gt;() registration.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SaveCommandHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;(</span><span class="s">&quot;handler&quot;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OpenCommandHandler</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;(</span><span class="s">&quot;handler&quot;</span><span class="p">);</span>

<span class="c1">// Then register the decorator. The decorator uses the</span>
<span class="c1">// named registrations to get the items to wrap.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;(</span>
    <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CommandHandlerDecorator</span><span class="p">(</span><span class="n">inner</span><span class="p">),</span>
    <span class="n">fromKey</span><span class="p">:</span> <span class="s">&quot;handler&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// The resolved set of commands will have two items</span>
<span class="c1">// in it, both of which will be wrapped in a CommandHandlerDecorator.</span>
<span class="kt">var</span> <span class="n">handlers</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&gt;&gt;();</span>
</pre></div>
</div>
<p>You can also use open generic decorator registrations.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the open generic with a name so the</span>
<span class="c1">// decorator can use it.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CommandHandler</span><span class="p">&lt;&gt;))</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">(</span><span class="s">&quot;handler&quot;</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;));</span>

<span class="c1">// Register the generic decorator so it can wrap</span>
<span class="c1">// the resolved named generics.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterGenericDecorator</span><span class="p">(</span>
        <span class="k">typeof</span><span class="p">(</span><span class="n">CommandHandlerDecorator</span><span class="p">&lt;&gt;),</span>
        <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
        <span class="n">fromKey</span><span class="p">:</span> <span class="s">&quot;handler&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// You can then resolve closed generics and they&#39;ll be</span>
<span class="c1">// wrapped with your decorator.</span>
<span class="kt">var</span> <span class="n">mailHandlers</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">EmailCommand</span><span class="p">&gt;&gt;&gt;();</span>
</pre></div>
</div>
<p>If you are using decorators on a WCF service implementation class, <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">there is some additional information on the WCF integration page about some special considerations.</span></a></p>
</div>
</div>
</div>
<span id="document-advanced/circular-dependencies"></span><div class="section" id="circular-dependencies">
<h3>Circular Dependencies<a class="headerlink" href="#circular-dependencies" title="Permalink to this headline">¶</a></h3>
<p>Circular dependencies are mutual runtime dependencies between components.</p>
<div class="section" id="property-property-dependencies">
<h4>Property/Property Dependencies<a class="headerlink" href="#property-property-dependencies" title="Permalink to this headline">¶</a></h4>
<p>This is when you have one class (<code class="docutils literal notranslate"><span class="pre">DependsByProperty1</span></code>) that takes a property dependency of a second type (<code class="docutils literal notranslate"><span class="pre">DependsByProperty2</span></code>), and the second type (<code class="docutils literal notranslate"><span class="pre">DependsByProperty2</span></code>) has a property dependency of the first type (<code class="docutils literal notranslate"><span class="pre">DependsByProperty1</span></code>).</p>
<p>If you have this situation, there are some important things to remember:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Make the property dependencies settable.</strong> The properties must be writeable.</li>
<li><strong>Register the types using</strong> <code class="docutils literal notranslate"><span class="pre">PropertiesAutowired</span></code>. Be sure to set the behavior to allow circular dependencies.</li>
<li><strong>Neither type can be registered as</strong> <code class="docutils literal notranslate"><span class="pre">InstancePerDependency</span></code>. If either type is set to factory scope you won’t get the results you’re looking for (where the two types refer to each other). You can scope them however you like - <code class="docutils literal notranslate"><span class="pre">SingleInstance</span></code>, <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope</span></code>, or any other scope - just not factory.</li>
</ul>
</div></blockquote>
<p>Example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DependsByProp1</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">DependsByProp2</span> <span class="n">Dependency</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">DependsByProp2</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">DependsByProp1</span> <span class="n">Dependency</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">cb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DependsByProp1</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">()</span>
  <span class="p">.</span><span class="n">PropertiesAutowired</span><span class="p">(</span><span class="n">PropertyWiringOptions</span><span class="p">.</span><span class="n">AllowCircularDependencies</span><span class="p">);</span>
<span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DependsByProp2</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">()</span>
  <span class="p">.</span><span class="n">PropertiesAutowired</span><span class="p">(</span><span class="n">PropertyWiringOptions</span><span class="p">.</span><span class="n">AllowCircularDependencies</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="constructor-property-dependencies">
<h4>Constructor/Property Dependencies<a class="headerlink" href="#constructor-property-dependencies" title="Permalink to this headline">¶</a></h4>
<p>This is when you have one class (<code class="docutils literal notranslate"><span class="pre">DependsByCtor</span></code>) that takes a constructor dependency of a second type (<code class="docutils literal notranslate"><span class="pre">DependsByProperty</span></code>), and the second type (<code class="docutils literal notranslate"><span class="pre">DependsByProperty</span></code>) has a property dependency of the first type (<code class="docutils literal notranslate"><span class="pre">DependsByCtor</span></code>).</p>
<p>If you have this situation, there are some important things to remember:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Make the property dependency settable.</strong> The property on the type with the property dependency must be writeable.</li>
<li><strong>Register the type with the property dependency using</strong> <code class="docutils literal notranslate"><span class="pre">PropertiesAutowired</span></code>. Be sure to set the behavior to allow circular dependencies.</li>
<li><strong>Neither type can be registered as</strong> <code class="docutils literal notranslate"><span class="pre">InstancePerDependency</span></code>. If either type is set to factory scope you won’t get the results you’re looking for (where the two types refer to each other). You can scope them however you like - <code class="docutils literal notranslate"><span class="pre">SingleInstance</span></code>, <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope</span></code>, or any other scope - just not factory.</li>
</ul>
</div></blockquote>
<p>Example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DependsByCtor</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">DependsByCtor</span><span class="p">(</span><span class="n">DependsByProp</span> <span class="n">dependency</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">DependsByProp</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">DependsByCtor</span> <span class="n">Dependency</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">cb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DependsByCtor</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
<span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">DependsByProp</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">()</span>
  <span class="p">.</span><span class="n">PropertiesAutowired</span><span class="p">(</span><span class="n">PropertyWiringOptions</span><span class="p">.</span><span class="n">AllowCircularDependencies</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="constructor-constructor-dependencies">
<h4>Constructor/Constructor Dependencies<a class="headerlink" href="#constructor-constructor-dependencies" title="Permalink to this headline">¶</a></h4>
<p>Two types with circular constructor dependencies are <strong>not supported</strong>. You will get an exception when you try to resolve types registered in this manner.</p>
<p>You may be able to work around this using the DynamicProxy2 extension and some creative coding.</p>
</div>
</div>
<span id="document-advanced/metadata"></span><div class="section" id="component-metadata-attribute-metadata">
<h3>Component Metadata / Attribute Metadata<a class="headerlink" href="#component-metadata-attribute-metadata" title="Permalink to this headline">¶</a></h3>
<p>If you’re familiar with the Managed Extensibility Framework (MEF) you have probably seen examples using component metadata.</p>
<p>Metadata is information about a component, stored with that component, accessible without necessarily creating a component instance.</p>
<div class="section" id="adding-metadata-to-a-component-registration">
<h4>Adding Metadata to a Component Registration<a class="headerlink" href="#adding-metadata-to-a-component-registration" title="Permalink to this headline">¶</a></h4>
<p>Values describing metadata are associated with the component at registration time. Each metadata item is a name/value pair:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ScreenAppender</span><span class="p">())</span>
    <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;AppenderName&quot;</span><span class="p">,</span> <span class="s">&quot;screen&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The same thing can be represented in <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">deployment-time configuration</span></a></p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;components&quot;</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;MyApp.Components.Logging.ScreenAppender, MyApp&quot;</span><span class="p">,</span>
    <span class="nt">&quot;services&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;MyApp.Services.Logging.ILogAppender, MyApp&quot;</span>
    <span class="p">}],</span>
    <span class="nt">&quot;metadata&quot;</span><span class="p">:</span> <span class="p">[{</span>
      <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;AppenderName&quot;</span><span class="p">,</span>
      <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;screen&quot;</span><span class="p">,</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;System.String, mscorlib&quot;</span>
    <span class="p">}]</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="consuming-metadata">
<h4>Consuming Metadata<a class="headerlink" href="#consuming-metadata" title="Permalink to this headline">¶</a></h4>
<p>Unlike a regular property, a metadata item is independent of the component itself.</p>
<p>This makes it useful when selecting one of many components based on runtime criteria; or, where the metadata isn’t intrinsic to the component implementation. Metadata could represent the time that an <code class="docutils literal notranslate"><span class="pre">ITask</span></code> should run, or the button caption for an <code class="docutils literal notranslate"><span class="pre">ICommand</span></code>.</p>
<p>Other components can consume metadata using the <code class="docutils literal notranslate"><span class="pre">Meta&lt;T&gt;</span></code> type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Log</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">&gt;&gt;</span> <span class="n">_appenders</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">Log</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">&gt;&gt;</span> <span class="n">appenders</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_appenders</span> <span class="p">=</span> <span class="n">appenders</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">string</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">appender</span> <span class="p">=</span> <span class="n">_appenders</span><span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;AppenderName&quot;</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span> <span class="n">destination</span><span class="p">));</span>
    <span class="n">appender</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To consume metadata without creating the target component, use <cite>Meta&lt;Lazy&lt;T&gt;&gt;</cite> or the .NET 4 <cite>Lazy&lt;T, TMetadata&gt;</cite> types as shown below.</p>
</div>
<div class="section" id="strongly-typed-metadata">
<h4>Strongly-Typed Metadata<a class="headerlink" href="#strongly-typed-metadata" title="Permalink to this headline">¶</a></h4>
<p>To avoid the use of string-based keys for describing metadata, a metadata class can be defined with a public read/write property for every metadata item:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">AppenderMetadata</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">AppenderName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At registration time, the class is used with the overloaded <code class="docutils literal notranslate"><span class="pre">WithMetadata</span></code> method to associate values:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ScreenAppender</span><span class="p">())</span>
    <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">WithMetadata</span><span class="p">&lt;</span><span class="n">AppenderMetadata</span><span class="p">&gt;(</span><span class="n">m</span> <span class="p">=&gt;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="n">am</span> <span class="p">=&gt;</span> <span class="n">am</span><span class="p">.</span><span class="n">AppenderName</span><span class="p">,</span> <span class="s">&quot;screen&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Notice the use of the strongly-typed <code class="docutils literal notranslate"><span class="pre">AppenderName</span></code> property.</p>
<p>Registration and consumption of metadata are separate, so strongy-typed metadata can be consumed via the weakly-typed techniques and vice-versa.</p>
<p>You can also provide default values using the <code class="docutils literal notranslate"><span class="pre">DefaultValue</span></code> attribute:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">AppenderMetadata</span>
<span class="p">{</span>
<span class="na">  [DefaultValue(&quot;screen&quot;)]</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">AppenderName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you are able to reference <code class="docutils literal notranslate"><span class="pre">System.ComponentModel.Composition</span></code> you can use the <code class="docutils literal notranslate"><span class="pre">System.Lazy&lt;T,</span> <span class="pre">TMetadata&gt;</span></code> type for consuming values from the strongly-typed metadata class:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Log</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">,</span> <span class="n">LogAppenderMetadata</span><span class="p">&gt;&gt;</span> <span class="n">_appenders</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">Log</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">,</span> <span class="n">LogAppenderMetadata</span><span class="p">&gt;&gt;</span> <span class="n">appenders</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_appenders</span> <span class="p">=</span> <span class="n">appenders</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">string</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">appender</span> <span class="p">=</span> <span class="n">_appenders</span><span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">.</span><span class="n">AppenderName</span> <span class="p">==</span> <span class="n">destination</span><span class="p">);</span>
    <span class="n">appender</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another neat trick is the ability to pass the metadata dictionary into the constructor of your metadata class:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">AppenderMetadata</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">AppenderMetadata</span><span class="p">(</span><span class="n">IDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">metadata</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">AppenderName</span> <span class="p">=</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="n">metadata</span><span class="p">[</span><span class="s">&quot;AppenderName&quot;</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="n">AppenderName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="interface-based-metadata">
<h4>Interface-Based Metadata<a class="headerlink" href="#interface-based-metadata" title="Permalink to this headline">¶</a></h4>
<p>If you have access to <code class="docutils literal notranslate"><span class="pre">System.ComponentModel.Composition</span></code> and include a reference to the <a class="reference internal" href="index.html#document-integration/mef"><span class="doc">Autofac.Mef</span></a> package you can use an interface for your metadata instead of a class.</p>
<p>The interface should be defined with a readable property for every metadata item:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IAppenderMetadata</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="n">AppenderName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You must also call the <code class="docutils literal notranslate"><span class="pre">RegisterMetadataRegistrationSources</span></code> method on the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> before registering the metadata against the interface type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterMetadataRegistrationSources</span><span class="p">();</span>
</pre></div>
</div>
<p>At registration time, the interface is used with the overloaded <code class="docutils literal notranslate"><span class="pre">WithMetadata</span></code> method to associate values:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ScreenAppender</span><span class="p">())</span>
    <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogAppender</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">WithMetadata</span><span class="p">&lt;</span><span class="n">IAppenderMetadata</span><span class="p">&gt;(</span><span class="n">m</span> <span class="p">=&gt;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="n">am</span> <span class="p">=&gt;</span> <span class="n">am</span><span class="p">.</span><span class="n">AppenderName</span><span class="p">,</span> <span class="s">&quot;screen&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Resolving the value can be done in the same manner as for class based metadata.</p>
</div>
<div class="section" id="attribute-based-metadata">
<h4>Attribute-Based Metadata<a class="headerlink" href="#attribute-based-metadata" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.AttributeMetadata</span></code> package enables metadata to be specified via attributes. Core Autofac includes support to allow components to filter incoming dependencies using attributes.</p>
<p>To get attributed metadata working in your solution, you need to perform the following steps:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#create-attribute"><span class="std std-ref">Create Your Metadata Attribute</span></a></li>
<li><a class="reference internal" href="#apply-attribute"><span class="std std-ref">Apply Your Metadata Attribute</span></a></li>
<li><a class="reference internal" href="#use-filters"><span class="std std-ref">Use Metadata Filters on Consumers</span></a></li>
<li><a class="reference internal" href="#container-use-attributes"><span class="std std-ref">Ensure the Container Uses Your Attributes</span></a></li>
</ol>
<div class="section" id="create-your-metadata-attribute">
<span id="create-attribute"></span><h5>Create Your Metadata Attribute<a class="headerlink" href="#create-your-metadata-attribute" title="Permalink to this headline">¶</a></h5>
<p>A metadata attribute is a <code class="docutils literal notranslate"><span class="pre">System.Attribute</span></code> implementation that has the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.componentmodel.composition.metadataattributeattribute.aspx">System.ComponentModel.Composition.MetadataAttributeAttribute</a> applied.</p>
<p>Any publicly-readable properties on the attribute will become name/value attribute pairs - the name of the metadata will be the property name and the value will be the property value.</p>
<p>In the example below, the <code class="docutils literal notranslate"><span class="pre">AgeMetadataAttribute</span></code> will provide a name/value pair of metadata where the name will be <code class="docutils literal notranslate"><span class="pre">Age</span></code> (the property name) and the value will be whatever is specified in the attribute during construction.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[MetadataAttribute]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AgeMetadataAttribute</span> <span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="nf">AgeMetadataAttribute</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Age</span> <span class="p">=</span> <span class="n">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="apply-your-metadata-attribute">
<span id="apply-attribute"></span><h5>Apply Your Metadata Attribute<a class="headerlink" href="#apply-your-metadata-attribute" title="Permalink to this headline">¶</a></h5>
<p>Once you have a metadata attribute, you can apply it to your component types to provide metadata.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Don&#39;t apply it to the interface (service type)</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IArtwork</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Display</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Apply it to the implementation (component type)</span>
<span class="na">[AgeMetadata(100)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CenturyArtwork</span> <span class="p">:</span> <span class="n">IArtwork</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Display</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="use-metadata-filters-on-consumers">
<span id="use-filters"></span><h5>Use Metadata Filters on Consumers<a class="headerlink" href="#use-metadata-filters-on-consumers" title="Permalink to this headline">¶</a></h5>
<p>Along with providing metadata via attributes, you can also set up automatic filters for consuming components. This will help wire up parameters for your constructors based on provided metadata.</p>
<p>You can filter based on <a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">a service key</span></a> or based on registration metadata. This attribute based filtering can be performed without custom metadata attributes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">KeyFilterAttribute</span></code>, <code class="docutils literal notranslate"><span class="pre">MetadataFilterAttribute</span></code>, and <code class="docutils literal notranslate"><span class="pre">WithAttributeFiltering</span></code> extension method below can be found in the <code class="docutils literal notranslate"><span class="pre">Autofac.Features.AttributeFilters</span></code> namespace in the core Autofac package.</p>
<div class="section" id="keyfilterattribute">
<h6>KeyFilterAttribute<a class="headerlink" href="#keyfilterattribute" title="Permalink to this headline">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">KeyFilterAttribute</span></code> allows you to select a specific keyed service to consume.</p>
<p>This example shows a class that requires a component with a particular key:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ArtDisplay</span> <span class="p">:</span> <span class="n">IDisplay</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ArtDisplay</span><span class="p">([</span><span class="n">KeyFilter</span><span class="p">(</span><span class="s">&quot;Painting&quot;</span><span class="p">)]</span> <span class="n">IArtwork</span> <span class="n">art</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That component will require you to register a keyed service with the specified name. You’ll also need to register the component with the filter so the container knows to look for it.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the keyed service to consume</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">MyArtwork</span><span class="p">&gt;().</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">IArtwork</span><span class="p">&gt;(</span><span class="s">&quot;Painting&quot;</span><span class="p">);</span>

<span class="c1">// Specify WithAttributeFiltering for the consumer</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ArtDisplay</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDisplay</span><span class="p">&gt;().</span><span class="n">WithAttributeFiltering</span><span class="p">();</span>

<span class="c1">// ...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="metadatafilterattribute">
<h6>MetadataFilterAttribute<a class="headerlink" href="#metadatafilterattribute" title="Permalink to this headline">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">MetadataFilterAttribute</span></code> allows you to filter for components based on specific metadata values.</p>
<p>This example shows a class that requires a component with a particular metadata value:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ArtDisplay</span> <span class="p">:</span> <span class="n">IDisplay</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ArtDisplay</span><span class="p">([</span><span class="n">MetadataFilter</span><span class="p">(</span><span class="s">&quot;Age&quot;</span><span class="p">,</span> <span class="m">100</span><span class="p">)]</span> <span class="n">IArtwork</span> <span class="n">art</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That component will require you to register a service with the specified metadata name/value pair. You could use the attributed metadata class seen in earlier examples, or manually specify metadata during registration time. You’ll also need to register the component with the filter so the container knows to look for it.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the service to consume with metadata.</span>
<span class="c1">// Since we&#39;re using attributed metadata, we also</span>
<span class="c1">// need to register the AttributedMetadataModule</span>
<span class="c1">// so the metadata attributes get read.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AttributedMetadataModule</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CenturyArtwork</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IArtwork</span><span class="p">&gt;();</span>

<span class="c1">// Specify WithAttributeFilter for the consumer</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ArtDisplay</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDisplay</span><span class="p">&gt;().</span><span class="n">WithAttributeFiltering</span><span class="p">();</span>

<span class="c1">// ...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ensure-the-container-uses-your-attributes">
<span id="container-use-attributes"></span><h5>Ensure the Container Uses Your Attributes<a class="headerlink" href="#ensure-the-container-uses-your-attributes" title="Permalink to this headline">¶</a></h5>
<p>The metadata attributes you create aren’t just used by default. In order to tell the container that you’re making use of metadata attributes, you need to register the <code class="docutils literal notranslate"><span class="pre">AttributedMetadataModule</span></code> into your container.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Register the service to consume with metadata.</span>
<span class="c1">// Since we&#39;re using attributed metadata, we also</span>
<span class="c1">// need to register the AttributedMetadataModule</span>
<span class="c1">// so the metadata attributes get read.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AttributedMetadataModule</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CenturyArtwork</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IArtwork</span><span class="p">&gt;();</span>

<span class="c1">// ...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>If you’re using metadata filters (<code class="docutils literal notranslate"><span class="pre">KeyFilterAttribute</span></code> or <code class="docutils literal notranslate"><span class="pre">WithAttributeFiltering</span></code> in your constructors), you need to register those components using the <code class="docutils literal notranslate"><span class="pre">WithAttributeFiltering</span></code> extension. Note that if you’re <em>only</em> using filters but not attributed metadata, you don’t actually need the <code class="docutils literal notranslate"><span class="pre">AttributedMetadataModule</span></code>. Metadata filters stand on their own.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Specify WithAttributeFilter for the consumer</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ArtDisplay</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDisplay</span><span class="p">&gt;().</span><span class="n">WithAttributeFiltering</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-advanced/keyed-services"></span><div class="section" id="named-and-keyed-services">
<h3>Named and Keyed Services<a class="headerlink" href="#named-and-keyed-services" title="Permalink to this headline">¶</a></h3>
<p>Autofac provides three typical ways to identify services. The most common is to identify by type:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OnlineState</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>This example associates the <code class="docutils literal notranslate"><span class="pre">IDeviceState</span></code> typed service with the <code class="docutils literal notranslate"><span class="pre">OnlineState</span></code> component. Instances of the component can be retrieved using the service type with the <code class="docutils literal notranslate"><span class="pre">Resolve()</span></code> method:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">r</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>However, you can also identify services by a string name or by an object key.</p>
<div class="section" id="named-services">
<h4>Named Services<a class="headerlink" href="#named-services" title="Permalink to this headline">¶</a></h4>
<p>Services can be further identified using a service name. Using this technique, the <code class="docutils literal notranslate"><span class="pre">Named()</span></code> registration method replaces <code class="docutils literal notranslate"><span class="pre">As()</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OnlineState</span><span class="p">&gt;().</span><span class="n">Named</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;(</span><span class="s">&quot;online&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>To retrieve a named service, the <code class="docutils literal notranslate"><span class="pre">ResolveNamed()</span></code> method is used:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">r</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">ResolveNamed</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;(</span><span class="s">&quot;online&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Named services are simply keyed services that use a string as a key</strong>, so the techniques described in the next section apply equally to named services.</p>
</div>
<div class="section" id="keyed-services">
<h4>Keyed Services<a class="headerlink" href="#keyed-services" title="Permalink to this headline">¶</a></h4>
<p>Using strings as component names is convenient in some cases, but in others we may wish to use keys of other types. Keyed services provide this ability.</p>
<p>For example, an enum may describe the different device states in our example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">enum</span> <span class="n">DeviceState</span> <span class="p">{</span> <span class="n">Online</span><span class="p">,</span> <span class="n">Offline</span> <span class="p">}</span>
</pre></div>
</div>
<p>Each enum value corresponds to an implementation of the service:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OnlineState</span> <span class="p">:</span> <span class="n">IDeviceState</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>The enum values can then be registered as keys for the implementations as shown below.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span> <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OnlineState</span><span class="p">&gt;().</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;(</span><span class="n">DeviceState</span><span class="p">.</span><span class="n">Online</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">OfflineState</span><span class="p">&gt;().</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;(</span><span class="n">DeviceState</span><span class="p">.</span><span class="n">Offline</span><span class="p">);</span>
<span class="c1">// Register other components here</span>
</pre></div>
</div>
<div class="section" id="resolving-explicitly">
<h5>Resolving Explicitly<a class="headerlink" href="#resolving-explicitly" title="Permalink to this headline">¶</a></h5>
<p>The implementation can be resolved explicitly with <code class="docutils literal notranslate"><span class="pre">ResolveKeyed()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">r</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">ResolveKeyed</span><span class="p">&lt;</span><span class="n">IDeviceState</span><span class="p">&gt;(</span><span class="n">DeviceState</span><span class="p">.</span><span class="n">Online</span><span class="p">);</span>
</pre></div>
</div>
<p>This does however result in using the container as a Service Locator, which is discouraged. As an alternative to this pattern, the <code class="docutils literal notranslate"><span class="pre">IIndex</span></code> type is provided.</p>
</div>
<div class="section" id="resolving-with-an-index">
<h5>Resolving with an Index<a class="headerlink" href="#resolving-with-an-index" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Features.Indexed.IIndex&lt;K,V&gt;</span></code> is a <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">relationship type that Autofac implements automatically</span></a>. Components that need to choose between service implementations based on a key can do so by taking a constructor parameter of type <code class="docutils literal notranslate"><span class="pre">IIndex&lt;K,V&gt;</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Modem</span> <span class="p">:</span> <span class="n">IHardwareDevice</span>
<span class="p">{</span>
  <span class="n">IIndex</span><span class="p">&lt;</span><span class="n">DeviceState</span><span class="p">,</span> <span class="n">IDeviceState</span><span class="p">&gt;</span> <span class="n">_states</span><span class="p">;</span>
  <span class="n">IDeviceState</span> <span class="n">_currentState</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">Modem</span><span class="p">(</span><span class="n">IIndex</span><span class="p">&lt;</span><span class="n">DeviceState</span><span class="p">,</span> <span class="n">IDeviceState</span><span class="p">&gt;</span> <span class="n">states</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="n">_states</span> <span class="p">=</span> <span class="n">states</span><span class="p">;</span>
     <span class="n">SwitchOn</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">SwitchOn</span><span class="p">()</span>
  <span class="p">{</span>
     <span class="n">_currentState</span> <span class="p">=</span> <span class="n">_states</span><span class="p">[</span><span class="n">DeviceState</span><span class="p">.</span><span class="n">Online</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">SwitchOn()</span></code> method, the index is used to find the implementation of <code class="docutils literal notranslate"><span class="pre">IDeviceState</span></code> that was registered with the <code class="docutils literal notranslate"><span class="pre">DeviceState.Online</span></code> key.</p>
</div>
<div class="section" id="resolving-with-attributes">
<h5>Resolving with Attributes<a class="headerlink" href="#resolving-with-attributes" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">metadata feature of Autofac provides a KeyFilterAttribute</span></a> that allows you to mark constructor parameters with an attribute specfying which keyed service should be used. The attribute usage looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ArtDisplay</span> <span class="p">:</span> <span class="n">IDisplay</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ArtDisplay</span><span class="p">([</span><span class="n">KeyFilter</span><span class="p">(</span><span class="s">&quot;Painting&quot;</span><span class="p">)]</span> <span class="n">IArtwork</span> <span class="n">art</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">See the metadata documentation</span></a> for more info on how to get this set up.</p>
</div>
</div>
</div>
<span id="document-advanced/delegate-factories"></span><div class="section" id="delegate-factories">
<h3>Delegate Factories<a class="headerlink" href="#delegate-factories" title="Permalink to this headline">¶</a></h3>
<p>Factory adapters provide the instantiation features of the container to managed components without exposing the container itself to them.</p>
<p>If type <code class="docutils literal notranslate"><span class="pre">T</span></code> is registered with the container, Autofac will <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">automatically resolve dependencies</span></a> on <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> as factories that create <code class="docutils literal notranslate"><span class="pre">T</span></code> instances through the container.</p>
<p><strong>Lifetime scopes are respected</strong> using delegate factories as well as when using <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> or the parameterized <code class="docutils literal notranslate"><span class="pre">Func&lt;X,Y,T&gt;</span></code> relationships. If you register an object as <code class="docutils literal notranslate"><span class="pre">InstancePerDependency()</span></code> and call the delegate factory multiple times, you’ll get a new instance each time. However, if you register an object as <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> and call the delegate factory to resolve the object more than once, you will get <em>the same object instance every time regardless of the different parameters you pass in.</em> Just passing different parameters will not break the respect for the lifetime scope.</p>
<div class="section" id="creation-through-factories">
<h4>Creation through Factories<a class="headerlink" href="#creation-through-factories" title="Permalink to this headline">¶</a></h4>
<div class="section" id="shareholdings">
<h5>Shareholdings<a class="headerlink" href="#shareholdings" title="Permalink to this headline">¶</a></h5>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Shareholding</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">delegate</span> <span class="n">Shareholding</span> <span class="nf">Factory</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">holding</span><span class="p">);</span>

  <span class="k">public</span> <span class="nf">Shareholding</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">holding</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Symbol</span> <span class="p">=</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="n">Holding</span> <span class="p">=</span> <span class="n">holding</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="n">Symbol</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="kt">uint</span> <span class="n">Holding</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Shareholding</span></code> class declares a constructor, but also provides a delegate type that can be used to create <code class="docutils literal notranslate"><span class="pre">Shareholdings</span></code> indirectly.</p>
<p>Autofac can make use of this to automatically generate a factory that can be accessed through the container:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Shareholding</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">shareholdingFactory</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Shareholding</span><span class="p">.</span><span class="n">Factory</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">shareholding</span> <span class="p">=</span> <span class="n">shareholdingFactory</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span> <span class="m">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>The factory is a standard delegate that can be called with <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code>, as above, or with the function syntax <code class="docutils literal notranslate"><span class="pre">shareholdingFactory(&quot;ABC&quot;,</span> <span class="pre">1234)</span></code>.</p>
<p><strong>By default, Autofac matches the parameters of the delegate to the parameters of the constructor by name.</strong> If you use the generic Func types, Autofac will switch to matching parameters by type.</p>
</div>
<div class="section" id="portfolio">
<h5>Portfolio<a class="headerlink" href="#portfolio" title="Permalink to this headline">¶</a></h5>
<p>Other components can use the factory:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Portfolio</span>
<span class="p">{</span>
  <span class="n">Shareholding</span><span class="p">.</span><span class="n">Factory</span> <span class="n">ShareholdingFactory</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">IList</span><span class="p">&lt;</span><span class="n">Shareholding</span><span class="p">&gt;</span> <span class="n">_holdings</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Shareholding</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="nf">Portfolio</span><span class="p">(</span><span class="n">Shareholding</span><span class="p">.</span><span class="n">Factory</span> <span class="n">shareholdingFactory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ShareholdingFactory</span> <span class="p">=</span> <span class="n">shareholdingFactory</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">holding</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_holdings</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">ShareholdingFactory</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">holding</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To wire this up, the <code class="docutils literal notranslate"><span class="pre">Portfolio</span></code> class would be registered with the container before building using:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Portfolio</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-components">
<h5>Using the Components<a class="headerlink" href="#using-the-components" title="Permalink to this headline">¶</a></h5>
<p>The components can be used by requesting an instance of <code class="docutils literal notranslate"><span class="pre">Portfolio</span></code> from the container:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">portfolio</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">Portfolio</span><span class="p">&gt;();</span>
<span class="n">portfolio</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;DEF&quot;</span><span class="p">,</span> <span class="m">4324</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">Autofac supports the use</span></a> of <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> delegates in addition to hand-coded delegates. <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> parameters are matched by type rather than by name.</p>
</div>
</div>
<div class="section" id="the-payoff">
<h4>The Payoff<a class="headerlink" href="#the-payoff" title="Permalink to this headline">¶</a></h4>
<p>Imagine a remote stock quoting service:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IQuoteService</span>
<span class="p">{</span>
  <span class="kt">decimal</span> <span class="nf">GetQuote</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can add a <code class="docutils literal notranslate"><span class="pre">value</span></code> member to the <code class="docutils literal notranslate"><span class="pre">Shareholding</span></code> class that makes use of the service:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Shareholding</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">delegate</span> <span class="n">Shareholding</span> <span class="nf">Factory</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">holding</span><span class="p">);</span>

  <span class="n">IQuoteService</span> <span class="n">QuoteService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="nf">Shareholding</span><span class="p">(</span><span class="kt">string</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">holding</span><span class="p">,</span> <span class="n">IQuoteService</span> <span class="n">quoteService</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">QuoteService</span> <span class="p">=</span> <span class="n">quoteService</span><span class="p">;</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Value</span>
  <span class="p">{</span>
    <span class="k">get</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">QuoteService</span><span class="p">.</span><span class="n">GetQuote</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="p">*</span> <span class="n">Holding</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An implementor of <code class="docutils literal notranslate"><span class="pre">IQuoteService</span></code> can be registered through the container:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">WebQuoteService</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IQuoteService</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Shareholding</span></code> instances will now be wired up correctly, but note: the signature of <code class="docutils literal notranslate"><span class="pre">Shareholding.Factory</span></code> <strong>doesn’t change!</strong> Autofac will transparently add the extra parameter to the <code class="docutils literal notranslate"><span class="pre">Shareholding</span></code> constructor when a factory delegate is called.</p>
<p>This means that <code class="docutils literal notranslate"><span class="pre">Portfolio</span></code> can take advantage of the <code class="docutils literal notranslate"><span class="pre">Shareholding.Value</span></code> property <em>without knowing that a quote service is involved at all.</em></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Portfolio</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Value</span>
  <span class="p">{</span>
    <span class="k">get</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">_holdings</span><span class="p">.</span><span class="n">Aggregate</span><span class="p">(</span><span class="m">0</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">e</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="caveat">
<h4>Caveat<a class="headerlink" href="#caveat" title="Permalink to this headline">¶</a></h4>
<p>In a desktop (i.e. stateful) application, when using disposable components, make sure to create nested lifetime scopes for units of work, so that the nested scope can dispose the items created by the factories within it.</p>
</div>
</div>
<span id="document-advanced/owned-instances"></span><div class="section" id="owned-instances">
<h3>Owned Instances<a class="headerlink" href="#owned-instances" title="Permalink to this headline">¶</a></h3>
<div class="section" id="lifetime-and-scope">
<h4>Lifetime and Scope<a class="headerlink" href="#lifetime-and-scope" title="Permalink to this headline">¶</a></h4>
<p>Autofac controls lifetime using explicitly-delineated scopes. For example, the component providing the <code class="docutils literal notranslate"><span class="pre">S</span></code> service, and all of its dependencies, will be disposed/released when the <code class="docutils literal notranslate"><span class="pre">using</span></code> block ends:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IContainer</span> <span class="n">container</span> <span class="p">=</span> <span class="c1">// as per usual</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">s</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">S</span><span class="p">&gt;();</span>
  <span class="n">s</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>In an IoC container, there’s often a subtle difference between releasing and disposing a component: releasing an owned component goes further than disposing the component itself. Any of the dependencies of the component will also be disposed. Releasing a shared component is usually a no-op, as other components will continue to use its services.</em></p>
</div>
<div class="section" id="relationship-types">
<h4>Relationship Types<a class="headerlink" href="#relationship-types" title="Permalink to this headline">¶</a></h4>
<p>Autofac has a system of <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">relationship types</span></a> that can be used to provide the features of the container in a declarative way. Instead of manipulating an <code class="docutils literal notranslate"><span class="pre">IContainer</span></code> or <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code> directly, as in the above example, relationship types allow a component to specify exactly which container services are needed, in a minimal, declarative way.</p>
<p>Owned instances are consumed using the <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> relationship type.</p>
<div class="section" id="owned-of-t">
<h5>Owned of T<a class="headerlink" href="#owned-of-t" title="Permalink to this headline">¶</a></h5>
<p>An owned dependency can be released by the owner when it is no longer required. Owned dependencies usually correspond to some unit of work performed by the dependent component.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Consumer</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">Owned</span><span class="p">&lt;</span><span class="n">DisposableComponent</span><span class="p">&gt;</span> <span class="n">_service</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">Consumer</span><span class="p">(</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">DisposableComponent</span><span class="p">&gt;</span> <span class="n">service</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_service</span> <span class="p">=</span> <span class="n">service</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// _service is used for some task</span>
    <span class="n">_service</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

    <span class="c1">// Here _service is no longer needed, so</span>
    <span class="c1">// it is released</span>
    <span class="n">_service</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">Consumer</span></code> is created by the container, the <code class="docutils literal notranslate"><span class="pre">Owned&lt;DisposableComponent&gt;</span></code> that it depends upon will be created inside its own lifetime scope. When <code class="docutils literal notranslate"><span class="pre">Consumer</span></code> is finished using the <code class="docutils literal notranslate"><span class="pre">DisposableComponent</span></code>, disposing the <code class="docutils literal notranslate"><span class="pre">Owned&lt;DisposableComponent&gt;</span></code> reference will end the lifetime scope that contains <code class="docutils literal notranslate"><span class="pre">DisposableComponent</span></code>. This means that all of <code class="docutils literal notranslate"><span class="pre">DisposableComponent</span></code>’s non-shared, disposable dependencies will also be released.</p>
</div>
<div class="section" id="combining-owned-with-func">
<h5>Combining Owned with Func<a class="headerlink" href="#combining-owned-with-func" title="Permalink to this headline">¶</a></h5>
<p>Owned instances are usually used in conjunction with a <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code> relationship, so that units of work can be begun and ended on-the-fly.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span> <span class="n">IMessageHandler</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">Message</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MessagePump</span>
<span class="p">{</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;&gt;</span> <span class="n">_handlerFactory</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MessagePump</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Owned</span><span class="p">&lt;</span><span class="n">IMessageHandler</span><span class="p">&gt;&gt;</span> <span class="n">handlerFactory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_handlerFactory</span> <span class="p">=</span> <span class="n">handlerFactory</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Go</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="n">NextMessage</span><span class="p">();</span>

      <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="n">_handlerFactory</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="owned-and-tags">
<h5>Owned and Tags<a class="headerlink" href="#owned-and-tags" title="Permalink to this headline">¶</a></h5>
<p>The lifetimes created by <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> use the tagging feature present as <code class="docutils literal notranslate"><span class="pre">ILifetimeScope.Tag</span></code>. The tag applied to a lifetime of <code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> will be <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">TypedService(typeof(T))</span></code> - that is, the tag of the lifetime reflects its entry point.</p>
</div>
</div>
</div>
<span id="document-advanced/concurrency"></span><div class="section" id="handling-concurrency">
<h3>Handling Concurrency<a class="headerlink" href="#handling-concurrency" title="Permalink to this headline">¶</a></h3>
<p>Autofac is designed for use in highly-concurrent applications. The guidance below will help you be successful in these situations.</p>
<div class="section" id="component-registration">
<h4>Component Registration<a class="headerlink" href="#component-registration" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> and <code class="docutils literal notranslate"><span class="pre">ComponentRegistryBuilder</span></code> <strong>are not thread-safe</strong> and are designed to be used only on a single thread at the time the application starts up. This is the most common scenario and works for almost all applications.</p>
</div>
<div class="section" id="service-resolution">
<h4>Service Resolution<a class="headerlink" href="#service-resolution" title="Permalink to this headline">¶</a></h4>
<p><strong>All container operations are safe for use between multiple threads.</strong></p>
<p>To reduce locking overhead, each <code class="docutils literal notranslate"><span class="pre">Resolve</span></code> operation takes place in a ‘context’ that provides the dependency-resolution features of the container. This is the parameter provided to component registration delegates.</p>
<p><strong>Resolution context objects are single-threaded</strong> and should <strong>not</strong> be used except during the course of a dependency resolution operation.</p>
<p>Avoid component registrations that store the context:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// THIS IS BROKEN - DON&#39;T DO IT</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">MyComponent</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</pre></div>
</div>
<p>In the above example, the “c” <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> parameter is being provided to MyComponent (which takes <code class="docutils literal notranslate"><span class="pre">IComponent</span></code> as a dependency).  This code is incorrect because the temporary “c” parameter will be reused.</p>
<p>Instead resolve <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> from “c” to access the non-temporary context:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span>
<span class="p">{</span>
  <span class="n">IContext</span> <span class="n">threadSpecificContext</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IComponentContext</span><span class="p">&gt;();</span> <span class="c1">// access real context.</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">MyComponent</span><span class="p">(</span><span class="n">threadSpecificContext</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Take care also not to initialize components with closures over the “c” parameter, as any reuse of “c” will cause issues.</p>
<p>The container hierarchy mechanism further reduces locking, by maintaining local copies of the component registrations for any factory/container components. Once the initial registration copy has been made, a thread using an ‘inner’ container can create or access such components without blocking any other thread.</p>
</div>
<div class="section" id="lifetime-events">
<h4>Lifetime Events<a class="headerlink" href="#lifetime-events" title="Permalink to this headline">¶</a></h4>
<p>When making use of the LifetimeEvents available, don’t call back into the container in handlers for the <code class="docutils literal notranslate"><span class="pre">Preparing</span></code>, <code class="docutils literal notranslate"><span class="pre">Activating</span></code> or <code class="docutils literal notranslate"><span class="pre">Activated</span></code> events: use the supplied <code class="docutils literal notranslate"><span class="pre">IComponentContext</span></code> instead.</p>
</div>
<div class="section" id="thread-scoped-services">
<h4>Thread Scoped Services<a class="headerlink" href="#thread-scoped-services" title="Permalink to this headline">¶</a></h4>
<p>You can use Autofac to register services that are specific to a thread. The <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">instance lifetime scope</span></a> page has more information on this.</p>
</div>
<div class="section" id="internals">
<h4>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">¶</a></h4>
<p>Keeping in mind the guidelines above, here’s a little more specific information about thread safety and locking in Autofac.</p>
</div>
<div class="section" id="thread-safe-types">
<h4>Thread-Safe Types<a class="headerlink" href="#thread-safe-types" title="Permalink to this headline">¶</a></h4>
<p>The following types are safe for concurrent access by multiple threads:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Container</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Disposer</span></code> (default implementation of <code class="docutils literal notranslate"><span class="pre">IDisposer</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">LifetimeScope</span></code> (default implementation of <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code>)</li>
</ul>
</div></blockquote>
<p>These types cover practically all of the runtime/resolution scenarios.</p>
<p>The following types are designed for single-threaded access at configuration time:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ComponentRegistryBuilder</span></code> (default implementation of <code class="docutils literal notranslate"><span class="pre">IComponentRegistryBuilder</span></code>)</li>
</ul>
</div></blockquote>
<p>So, a correct Autofac application will use a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> on a single thread to create the container at startup. Subsequent use of the container can occur on any thread.</p>
</div>
<div class="section" id="deadlock-avoidance">
<h4>Deadlock Avoidance<a class="headerlink" href="#deadlock-avoidance" title="Permalink to this headline">¶</a></h4>
<p>Autofac is designed in such a way that deadlocks won’t occur in normal use. This section is a guide for maintainers or extension writers.</p>
<p>Locks may be acquired in the following order:</p>
<blockquote>
<div><ul class="simple">
<li>A thread holding a lock for any of the following may not acquire any further locks:<ul>
<li><code class="docutils literal notranslate"><span class="pre">Disposer</span></code></li>
</ul>
</li>
<li>A thread holding the lock for a <code class="docutils literal notranslate"><span class="pre">LifetimeScope</span></code> may subsequently acquire the lock for:<ul>
<li>Its parent <code class="docutils literal notranslate"><span class="pre">LifetimeScope</span></code></li>
<li>Any of the items listed above</li>
</ul>
</li>
</ul>
</div></blockquote>
</div>
</div>
<span id="document-advanced/multitenant"></span><div class="section" id="multitenant-applications">
<h3>Multitenant Applications<a class="headerlink" href="#multitenant-applications" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant</span></code> enables multitenant dependency injection support. (Prior to v4.0.0, the package was called <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.Multitenant</span></code>.)</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#what-is-multitenancy" id="id4">What Is Multitenancy?</a></li>
<li><a class="reference internal" href="#general-principles" id="id5">General Principles</a><ul>
<li><a class="reference internal" href="#reference-nuget-packages" id="id6">Reference NuGet Packages</a></li>
<li><a class="reference internal" href="#register-dependencies" id="id7">Register Dependencies</a></li>
<li><a class="reference internal" href="#tenant-identification" id="id8">Identify the Tenant</a></li>
<li><a class="reference internal" href="#resolve-tenant-specific-dependencies" id="id9">Resolve Tenant-Specific Dependencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asp-net-integration" id="id10">ASP.NET Integration</a><ul>
<li><a class="reference internal" href="#asp-net-application-startup" id="id11">ASP.NET Application Startup</a></li>
<li><a class="reference internal" href="#tenant-specific-controllers" id="id12">Tenant-Specific Controllers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asp-net-core-integration" id="id13">ASP.NET Core Integration</a></li>
<li><a class="reference internal" href="#wcf-integration" id="id14">WCF Integration</a><ul>
<li><a class="reference internal" href="#reference-packages-for-wcf-integration" id="id15">Reference Packages for WCF Integration</a></li>
<li><a class="reference internal" href="#passing-tenant-id-with-a-behavior" id="id16">Passing Tenant ID with a Behavior</a></li>
<li><a class="reference internal" href="#tenant-identification-from-operationcontext" id="id17">Tenant Identification from OperationContext</a></li>
<li><a class="reference internal" href="#hosting-multitenant-services" id="id18">Hosting Multitenant Services</a><ul>
<li><a class="reference internal" href="#managing-service-attributes" id="id19">Managing Service Attributes</a></li>
<li><a class="reference internal" href="#tenant-specific-service-implementations" id="id20">Tenant-Specific Service Implementations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wcf-application-startup" id="id21">WCF Application Startup</a><ul>
<li><a class="reference internal" href="#wcf-client-application-startup" id="id22">WCF Client Application Startup</a></li>
<li><a class="reference internal" href="#wcf-service-application-startup" id="id23">WCF Service Application Startup</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tenant-id-strategy-tips" id="id24">Tenant ID Strategy Tips</a></li>
<li><a class="reference internal" href="#example" id="id25">Example</a></li>
</ul>
</div>
<div class="section" id="what-is-multitenancy">
<h4><a class="toc-backref" href="#id4">What Is Multitenancy?</a><a class="headerlink" href="#what-is-multitenancy" title="Permalink to this headline">¶</a></h4>
<p>A <strong>multitenant application</strong> is an application that you can deploy one time yet allow separate customers, or “tenants,” to view the application as though it was their own.</p>
<p>Consider, for example, a hosted online store application - you, <em>the tenant</em>, lease the application, set some configuration values, and when an end user visits the application under your custom domain name, it looks like your company. Other tenants may also lease the application, yet the application is deployed only one time on a central, hosted server and changes its behavior based on the tenant (or tenant’s end-users) accessing it.</p>
<p>Many changes in a multitenant environment are performed via simple configuration. For example, the colors or fonts displayed in the UI are simple configuration options that can be “plugged in” without actually changing the behavior of the application.</p>
<p>In a more complex scenario, <strong>you may need to change business logic on a per-tenant basis.</strong> For example, a specific tenant leasing space on the application may want to change the way a value is calculated using some complex custom logic. <strong>How do you register a default behavior/dependency for an application and allow a specific tenant to override it?</strong></p>
<p>This is the functionality that <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant</span></code> attempts to address.</p>
</div>
<div class="section" id="general-principles">
<h4><a class="toc-backref" href="#id5">General Principles</a><a class="headerlink" href="#general-principles" title="Permalink to this headline">¶</a></h4>
<p>In general, a multitenant application has four tasks that need to be performed with respect to dependency resolution:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#reference-packages"><span class="std std-ref">Reference NuGet Packages</span></a></li>
<li><a class="reference internal" href="#register-dependencies"><span class="std std-ref">Register Dependencies</span></a></li>
<li><a class="reference internal" href="#tenant-identification"><span class="std std-ref">Identify the Tenant</span></a></li>
<li><a class="reference internal" href="#resolve-dependencies"><span class="std std-ref">Resolve Tenant-Specific Dependencies</span></a></li>
</ol>
<p>This section outlines how these four steps work. Later sections will expand on these topics to include information on how to integrate these principles with specific application types.</p>
<div class="section" id="reference-nuget-packages">
<span id="reference-packages"></span><h5><a class="toc-backref" href="#id6">Reference NuGet Packages</a><a class="headerlink" href="#reference-nuget-packages" title="Permalink to this headline">¶</a></h5>
<p>Any application that wants to use multitenancy needs to add references to the NuGet packages…</p>
<ul class="simple">
<li>Autofac</li>
<li>Autofac.Multitenant</li>
</ul>
<p>That’s the bare minimum. <strong>WCF applications</strong> also need <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf</span></code>.</p>
</div>
<div class="section" id="register-dependencies">
<span id="id1"></span><h5><a class="toc-backref" href="#id7">Register Dependencies</a><a class="headerlink" href="#register-dependencies" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant</span></code> introduces a new container type called <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.MultitenantContainer</span></code>. This container is used for managing application-level defaults and tenant-specific overrides.</p>
<p>The overall registration process is:</p>
<ol class="arabic simple">
<li><strong>Create an application-level default container.</strong> This container is where you register the default dependencies for the application. If a tenant doesn’t otherwise provide an override for a dependency type, the dependencies registered here will be used.</li>
<li><strong>Instantiate a tenant identification strategy.</strong> A tenant identification strategy is used to determine the ID for the current tenant based on execution context. You can read more on this later in this document.</li>
<li><strong>Create a multitenant container.</strong> The multitenant container is responsible for keeping track of the application defaults and the tenant-specific overrides.</li>
<li><strong>Register tenant-specific overrides.</strong> For each tenant wishing to override a dependency, register the appropriate overrides passing in the tenant ID and a configuration lambda.</li>
</ol>
<p>General usage looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// First, create your application-level defaults using a standard</span>
<span class="c1">// ContainerBuilder, just as you are used to.</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Consumer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependencyConsumer</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">appContainer</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// Once you&#39;ve built the application-level default container, you</span>
<span class="c1">// need to create a tenant identification strategy. The details of this</span>
<span class="c1">// are discussed later on.</span>
<span class="kt">var</span> <span class="n">tenantIdentifier</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTenantIdentificationStrategy</span><span class="p">();</span>

<span class="c1">// Now create the multitenant container using the application</span>
<span class="c1">// container and the tenant identification strategy.</span>
<span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdentifier</span><span class="p">,</span> <span class="n">appContainer</span><span class="p">);</span>

<span class="c1">// Configure the overrides for each tenant by passing in the tenant ID</span>
<span class="c1">// and a lambda that takes a ContainerBuilder.</span>
<span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">());</span>
<span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant2Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">());</span>

<span class="c1">// Now you can use the multitenant container to resolve instances.</span>
</pre></div>
</div>
<p><strong>If you have a component that needs one instance per tenant</strong>, you can use the <code class="docutils literal notranslate"><span class="pre">InstancePerTenant()</span></code> registration extension method at the container level.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISomeInterface</span><span class="p">&gt;().</span><span class="n">InstancePerTenant</span><span class="p">();</span>
<span class="c1">// InstancePerTenant goes in the main container; other</span>
<span class="c1">// tenant-specific dependencies get registered as shown</span>
<span class="c1">// above, in tenant-specific lifetimes.</span>
</pre></div>
</div>
<p>Note that <strong>you may only configure a tenant one time.</strong> After that, you may not change that tenant’s overrides. Also, if you resolve a dependency for a tenant, their lifetime scope may not be changed. It is good practice to configure your tenant overrides at application startup to avoid any issues. If you need to perform some business logic to “build” the tenant configuration, you can use the <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.ConfigurationActionBuilder</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="c1">// ... register things...</span>
<span class="kt">var</span> <span class="n">appContainer</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">tenantIdentifier</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTenantIdentificationStrategy</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdentifier</span><span class="p">,</span> <span class="n">appContainer</span><span class="p">);</span>

<span class="c1">// Create a configuration action builder to aggregate registration</span>
<span class="c1">// actions over the course of some business logic.</span>
<span class="kt">var</span> <span class="n">actionBuilder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConfigurationActionBuilder</span><span class="p">();</span>

<span class="c1">// Do some logic...</span>
<span class="k">if</span><span class="p">(</span><span class="n">SomethingIsTrue</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">actionBuilder</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">AnOverride</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISomething</span><span class="p">&gt;());</span>
<span class="p">}</span>
<span class="n">actionBuilder</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeClass</span><span class="p">&gt;());</span>
<span class="k">if</span><span class="p">(</span><span class="n">AnotherThingIsTrue</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">actionBuilder</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">MyModule</span><span class="p">&gt;());</span>
<span class="p">}</span>

<span class="c1">// Now configure a tenant using the built action.</span>
<span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="n">actionBuilder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="tenant-identification">
<span id="identify-the-tenant"></span><h5><a class="toc-backref" href="#id8">Identify the Tenant</a><a class="headerlink" href="#tenant-identification" title="Permalink to this headline">¶</a></h5>
<p>In order to resolve a tenant-specific dependency, Autofac needs to know which tenant is making the resolution request. That is, “for the current execution context, which tenant is resolving dependencies?”</p>
<p>Autofac.Multitenant includes an <code class="docutils literal notranslate"><span class="pre">ITenantIdentificationStrategy</span></code> interface that you can implement to provide just such a mechanism. This allows you to retrieve the tenant ID from anywhere appropriate to your application: an environment variable, a role on the current user’s principal, an incoming request value, or anywhere else.</p>
<p>The following example shows what a simple <code class="docutils literal notranslate"><span class="pre">ITenantIdentificationStrategy</span></code> that a web application might look like.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Web</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Multitenant</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">DemoNamespace</span>
<span class="p">{</span>
  <span class="c1">// SUPER IMPORTANT DISCLAIMERS:</span>
  <span class="c1">// * This is an EXAMPLE ONLY and is NOT RECOMMENDED.</span>
  <span class="c1">// * There&#39;s very little error checking here and is NOT ROBUST.</span>
  <span class="c1">// * SERIOUSLY THIS IS JUST AN ILLUSTRATIVE EXAMPLE.</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">RequestParameterStrategy</span> <span class="p">:</span> <span class="n">ITenantIdentificationStrategy</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TryIdentifyTenant</span><span class="p">(</span><span class="k">out</span> <span class="kt">object</span> <span class="n">tenantId</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">tenantId</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
      <span class="k">try</span>
      <span class="p">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">context</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">tenantId</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;tenant&quot;</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="n">HttpException</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// Happens at app startup in IIS 7.0</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">tenantId</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, a web application is using an incoming request parameter to get the tenant ID. (Note that <strong>this is just an example and is not recommended</strong> because it would allow any user on the system to very easily just switch tenants. It also doesn’t handle resolving things that occur outside of a web request.)</p>
<p>In your custom strategy implementation, you may choose to represent your tenant IDs as GUIDs, integers, or any other custom type. The strategy here is where you would parse the value from the execution context into a strongly typed object and succeed/fail based on whether the value is present and/or whether it can be parsed into the appropriate type.</p>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant</span></code> uses <code class="docutils literal notranslate"><span class="pre">System.Object</span></code> as the tenant ID type throughout the system for maximum flexibility.</p>
<p><strong>Performance is important in tenant identification.</strong> Tenant identification happens every time you resolve a component, begin a new lifetime scope, etc. As such, it is very important to make sure your tenant identification strategy is fast. For example, you wouldn’t want to do a service call or a database query during tenant identification.</p>
<p><strong>Be sure to handle errors well in tenant identification.</strong> Especially in situations like ASP.NET application startup, you may use some contextual mechanism (like <code class="docutils literal notranslate"><span class="pre">HttpContext.Current.Request</span></code>) to determine your tenant ID, but if your tenant ID strategy gets called when that contextual information isn’t available, you need to be able to handle that. You’ll see in the above example that not only does it check for the current <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code>, but also the <code class="docutils literal notranslate"><span class="pre">Request</span></code>. Check everything and handle exceptions (e.g., parsing exceptions) or you may get some odd or hard-to-troubleshoot behavior.</p>
<p><strong>There are additional tips for your tenant ID strategy</strong> in the <a class="reference internal" href="#tenant-id-strategy-tips"><span class="std std-ref">Tenant ID Strategy Tips</span></a> section.</p>
</div>
<div class="section" id="resolve-tenant-specific-dependencies">
<span id="resolve-dependencies"></span><h5><a class="toc-backref" href="#id9">Resolve Tenant-Specific Dependencies</a><a class="headerlink" href="#resolve-tenant-specific-dependencies" title="Permalink to this headline">¶</a></h5>
<p>The way the <code class="docutils literal notranslate"><span class="pre">MultitenantContainer</span></code> works, each tenant on the system gets their own <code class="docutils literal notranslate"><span class="pre">Autofac.ILifetimeScope</span></code> instance which contains the set of application defaults along with the tenant-specific overrides. Doing this…</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">appContainer</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="kt">var</span> <span class="n">tenantIdentifier</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTenantIdentificationStrategy</span><span class="p">();</span>

<span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdentifier</span><span class="p">,</span> <span class="n">appContainer</span><span class="p">);</span>
<span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">());</span>
</pre></div>
</div>
<p>Is very much like using the standard <code class="docutils literal notranslate"><span class="pre">ILifetimeScope.BeginLifetimeScope(Action&lt;ContainerBuilder&gt;)</span></code>, like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">SingleInstance</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">appContainer</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">appContainer</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span>
  <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// Do work with the created scope...</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>When you use the <code class="docutils literal notranslate"><span class="pre">MultitenantContainer</span></code> to resolve a dependency, behind the scenes it calls your <code class="docutils literal notranslate"><span class="pre">ITenantIdentificationStrategy</span></code> to identify the tenant, it locates the tenant’s lifetime scope (with their configured overrides), and resolves the dependency from that scope. It does all this transparently, so you can use the multitenant container the same as you do other containers.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">dependency</span> <span class="p">=</span> <span class="n">mtc</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>
<span class="c1">// &quot;dependency&quot; will be a tenant-specific value resolved from</span>
<span class="c1">// the multitenant container. If the current tenant has overridden</span>
<span class="c1">// the IDependency registration, that override will be resolved;</span>
<span class="c1">// otherwise it will be the application-level default.</span>
</pre></div>
</div>
<p>The important bit here is that all the work is going on transparently behind the scenes. Any call to <code class="docutils literal notranslate"><span class="pre">Resolve</span></code>, <code class="docutils literal notranslate"><span class="pre">BeginLifetimeScope</span></code>, <code class="docutils literal notranslate"><span class="pre">Tag</span></code>, <code class="docutils literal notranslate"><span class="pre">Disposer</span></code>, or the other methods/properties on the <code class="docutils literal notranslate"><span class="pre">IContainer</span></code> interface will all go through the tenant identification process and the result of the call will be tenant-specific.</p>
<p>If you need to specifically access a tenant’s lifetime scope or the application container, the <code class="docutils literal notranslate"><span class="pre">MultitenantContainer</span></code> provides:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ApplicationContainer</span></code>: Gets the application container.</li>
<li><code class="docutils literal notranslate"><span class="pre">GetCurrentTenantScope</span></code>: Identifies the current tenant and returns their specific lifetime scope.</li>
<li><code class="docutils literal notranslate"><span class="pre">GetTenantScope</span></code>: Allows you to provide a specific tenant ID for which you want the lifetime scope.</li>
</ul>
</div>
</div>
<div class="section" id="asp-net-integration">
<span id="aspnet-integration"></span><h4><a class="toc-backref" href="#id10">ASP.NET Integration</a><a class="headerlink" href="#asp-net-integration" title="Permalink to this headline">¶</a></h4>
<p>ASP.NET integration is not really any different than <a class="reference internal" href="index.html#document-integration/aspnet"><span class="doc">standard ASP.NET application integration</span></a>. Really, the only difference is that you will set up your application’s <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Web.IContainerProvider</span></code> or <code class="docutils literal notranslate"><span class="pre">System.,Web.Mvc.IDependencyResolver</span></code> or whatever with an <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.MultitenantContainer</span></code> rather than a regular container built by a <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code>. Since the <code class="docutils literal notranslate"><span class="pre">MultitenantContainer</span></code> handles multitenancy in a transparent fashion, “things just work.”</p>
<div class="section" id="asp-net-application-startup">
<h5><a class="toc-backref" href="#id11">ASP.NET Application Startup</a><a class="headerlink" href="#asp-net-application-startup" title="Permalink to this headline">¶</a></h5>
<p>Here is a sample <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">ASP.NET MVC</span></a> <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code> implementation illustrating how simple it is:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nn">MultitenantExample.MvcApplication</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">MvcApplication</span> <span class="p">:</span> <span class="n">HttpApplication</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">RegisterRoutes</span><span class="p">(</span><span class="n">RouteCollection</span> <span class="n">routes</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Register your routes - standard MVC stuff.</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="c1">// Set up the tenant ID strategy and application container.</span>
      <span class="c1">// The request parameter tenant ID strategy is used here as an example.</span>
      <span class="c1">// You should use your own strategy in production.</span>
      <span class="kt">var</span> <span class="n">tenantIdStrategy</span> <span class="p">=</span> <span class="k">new</span> <span class="n">RequestParameterTenantIdentificationStrategy</span><span class="p">(</span><span class="s">&quot;tenant&quot;</span><span class="p">);</span>
      <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>

      <span class="c1">// If you have tenant-specific controllers in the same assembly as the</span>
      <span class="c1">// application, you should register controllers individually.</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HomeController</span><span class="p">&gt;();</span>

      <span class="c1">// Create the multitenant container and the tenant overrides.</span>
      <span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdStrategy</span><span class="p">,</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
      <span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span>
        <span class="n">b</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
          <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">();</span>
          <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Controller</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">HomeController</span><span class="p">&gt;();</span>
        <span class="p">});</span>

      <span class="c1">// Here&#39;s the magic line: Set up the DependencyResolver using</span>
      <span class="c1">// a multitenant container rather than a regular container.</span>
      <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">mtc</span><span class="p">));</span>

      <span class="c1">// ...and everything else is standard MVC.</span>
      <span class="n">AreaRegistration</span><span class="p">.</span><span class="n">RegisterAllAreas</span><span class="p">();</span>
      <span class="n">RegisterRoutes</span><span class="p">(</span><span class="n">RouteTable</span><span class="p">.</span><span class="n">Routes</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, <strong>it’s almost the same as regular MVC Autofac integration</strong>. You set up the application container, the tenant ID strategy, the multitenant container, and the tenant overrides as illustrated earlier in <a class="reference internal" href="#register-dependencies"><span class="std std-ref">Register Dependencies</span></a> and <a class="reference internal" href="#tenant-identification"><span class="std std-ref">Identify the Tenant</span></a>. Then when you set up your <code class="docutils literal notranslate"><span class="pre">DependencyResolver</span></code>, give it the multitenant container. Everything else just works.</p>
<p><strong>This similarity is true for other web applications</strong> as well. When setting up your <code class="docutils literal notranslate"><span class="pre">IContainerProviderAccessor</span></code> for web forms, use the multitenant container instead of the standard container. When setting up your <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">Web API</span></a> <code class="docutils literal notranslate"><span class="pre">DependencyResolver</span></code>, use the multitenant container instead of the standard container.</p>
<p>Note in the example that controllers are getting registered individually rather than using the all-at-once <code class="docutils literal notranslate"><span class="pre">builder.RegisterControllers(Assembly.GetExecutingAssembly());</span></code> style of registration. See below for more on why this is the case.</p>
</div>
<div class="section" id="tenant-specific-controllers">
<h5><a class="toc-backref" href="#id12">Tenant-Specific Controllers</a><a class="headerlink" href="#tenant-specific-controllers" title="Permalink to this headline">¶</a></h5>
<p>You may choose, in an MVC application, to allow a tenant to override a controller. This is possible, but requires a little forethought.</p>
<p>First, <strong>tenant-specific controllers must derive from the controller they are overriding.</strong> For example, if you have a <code class="docutils literal notranslate"><span class="pre">HomeController</span></code> for your application and a tenant wants to create their own implementation of it, they need to derive from it, like…</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Tenant1HomeController</span> <span class="p">:</span> <span class="n">HomeController</span>
<span class="p">{</span>
  <span class="c1">// Tenant-specific implementation of the controller.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Second, <strong>if your tenant-specific controllers are in the same assembly as the rest of the application, you can’t register your controllers in one line.</strong> You may have seen in standard <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">ASP.NET MVC integration</span></a> a line like <code class="docutils literal notranslate"><span class="pre">builder.RegisterControllers(Assembly.GetExecutingAssembly());</span></code> to register all the controllers in the assembly at once. Unfortunately, if you have tenant-specific controllers in the same assembly, they’ll all be registered at the application level if you do this. Instead, you need to register each application controller at the application level one at a time, and then configure tenant-specific overrides the same way.</p>
<p>The example <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code> above shows this pattern of registering controllers individually.</p>
<p>Of course, if you keep your tenant-specific controllers in other assemblies, you can register all of the application controllers at once using <code class="docutils literal notranslate"><span class="pre">builder.RegisterControllers(Assembly.GetExecutingAssembly());</span></code> and it’ll work just fine. Note that if your tenant-specific controller assemblies aren’t referenced by the main application (e.g., they’re “plugins” that get dynamically registered at startup using assembly probing or some such) <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">you’ll need to register your assemblies with the ASP.NET BuildManager</span></a>.</p>
<p>Finally, when registering tenant-specific controllers, register them “as” the base controller type. In the example above, you see the default controller registered in the application container like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">HomeController</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Then when the tenant overrides the controller in their tenant configuration, it looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdStrategy</span><span class="p">,</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>
<span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Controller</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">HomeController</span><span class="p">&gt;());</span>
</pre></div>
</div>
<p><strong>Due to the relative complexity of this, it may be a better idea to isolate business logic into external dependencies that get passed into your controllers so the tenants can provide override dependencies rather than override controllers.</strong></p>
</div>
</div>
<div class="section" id="asp-net-core-integration">
<h4><a class="toc-backref" href="#id13">ASP.NET Core Integration</a><a class="headerlink" href="#asp-net-core-integration" title="Permalink to this headline">¶</a></h4>
<p>ASP.NET Core changes a lot of things. The multitenant integration is outlined <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">on our ASP.NET Core integration page.</span></a></p>
</div>
<div class="section" id="wcf-integration">
<span id="id2"></span><h4><a class="toc-backref" href="#id14">WCF Integration</a><a class="headerlink" href="#wcf-integration" title="Permalink to this headline">¶</a></h4>
<p>WCF integration is just slightly different than the <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">standard WCF integration</span></a> in that you need to use a different service host factory than the standard Autofac host factory and there’s a little additional configuration required.</p>
<p>Also, identifying a tenant is a little harder - the client needs to pass the tenant ID to the service somehow and the service needs to know how to interpret that passed tenant ID. A simple solution to this is provided in the form of a behavior that passes the relevant information in message headers.</p>
<div class="section" id="reference-packages-for-wcf-integration">
<h5><a class="toc-backref" href="#id15">Reference Packages for WCF Integration</a><a class="headerlink" href="#reference-packages-for-wcf-integration" title="Permalink to this headline">¶</a></h5>
<p>For an application <strong>consuming a multitenant service</strong> (a client application), add references to…</p>
<ul class="simple">
<li>Autofac</li>
<li>Autofac.Multitenant</li>
</ul>
<p>For an application <strong>providing a multitenant service</strong> (a service application), add references to…</p>
<ul class="simple">
<li>Autofac</li>
<li>Autofac.Integration.Wcf</li>
<li>Autofac.Multitenant</li>
<li>Autofac.Multitenant.Wcf</li>
</ul>
</div>
<div class="section" id="passing-tenant-id-with-a-behavior">
<span id="behavior-id"></span><h5><a class="toc-backref" href="#id16">Passing Tenant ID with a Behavior</a><a class="headerlink" href="#passing-tenant-id-with-a-behavior" title="Permalink to this headline">¶</a></h5>
<p>As mentioned earlier (<a class="reference internal" href="#tenant-identification"><span class="std std-ref">Identify the Tenant</span></a>), for multitenancy to work you have to identify which tenant is making a given call so you can resolve the appropriate dependencies. One of the challenges in a service environment is that the tenant is generally established on the client application end and that tenant ID needs to be propagated to the service so it can behave appropriately.</p>
<p>A common solution to this is to propagate the tenant ID in message headers. The client adds a special header to an outgoing message that contains the tenant ID. The service parses that header, reads out the tenant ID, and uses that ID to determine its functionality.</p>
<p>In WCF, the way to attach these “dynamic” headers to messages and read them back is through a behavior. You apply the behavior to both the client and the service ends so the same header information (type, URN, etc.) is used.</p>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant</span></code> provides a simple tenant ID propagation behavior in <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf.TenantPropagationBehavior</span></code>. Applied on the client side, it uses the tenant ID strategy to retrieve the contextual tenant ID and insert it into a message header on an outgoing message. Applied on the server side, it looks for this inbound header and parses the tenant ID out, putting it into an OperationContext extension.</p>
<p>The <a class="reference internal" href="#wcf-startup"><span class="std std-ref">WCF Application Startup</span></a> section below shows examples of putting this behavior in action both on the client and server sides.</p>
<p>If you use this behavior, a corresponding server-side tenant identification strategy is also provided for you. See <a class="reference internal" href="#operationcontext-id"><span class="std std-ref">Tenant Identification from OperationContext</span></a>, below.</p>
</div>
<div class="section" id="tenant-identification-from-operationcontext">
<span id="operationcontext-id"></span><h5><a class="toc-backref" href="#id17">Tenant Identification from OperationContext</a><a class="headerlink" href="#tenant-identification-from-operationcontext" title="Permalink to this headline">¶</a></h5>
<p>Whether or not you choose to use the provided <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf.TenantPropagationBehavior</span></code> to propagate behavior from client to server in a message header (see above <a class="reference internal" href="#behavior-id"><span class="std std-ref">Passing Tenant ID with a Behavior</span></a>), a good place to store the tenant ID for the life of an operation is in the <code class="docutils literal notranslate"><span class="pre">OperationContext</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf</span></code> provides the <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf.TenantIdentificationContextExtension</span></code> as an extension to the WCF <code class="docutils literal notranslate"><span class="pre">OperationContext</span></code> for just this purpose.</p>
<p>Early in the operation lifecycle (generally in a <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.dispatcher.idispatchmessageinspector.afterreceiverequest.aspx">System.ServiceModel.Dispatcher.IDispatchMessageInspector.AfterReceiveRequest()</a> implementation), you can add the <code class="docutils literal notranslate"><span class="pre">TenantIdentificationContextExtension</span></code> to the current <code class="docutils literal notranslate"><span class="pre">OperationContext</span></code> so the tenant can be easily identified. A sample <code class="docutils literal notranslate"><span class="pre">AfterReceiveRequest()</span></code> implementation below shows this in action:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="kt">object</span> <span class="nf">AfterReceiveRequest</span><span class="p">(</span><span class="k">ref</span> <span class="n">Message</span> <span class="n">request</span><span class="p">,</span> <span class="n">IClientChannel</span> <span class="n">channel</span><span class="p">,</span> <span class="n">InstanceContext</span> <span class="n">instanceContext</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// This assumes the tenant ID is coming from a message header; you can</span>
  <span class="c1">// get it from wherever you want.</span>
  <span class="kt">var</span> <span class="n">tenantId</span> <span class="p">=</span> <span class="n">request</span><span class="p">.</span><span class="n">Headers</span><span class="p">.</span><span class="n">GetHeader</span><span class="p">&lt;</span><span class="n">TTenantId</span><span class="p">&gt;(</span><span class="n">TenantHeaderName</span><span class="p">,</span> <span class="n">TenantHeaderNamespace</span><span class="p">);</span>

  <span class="c1">// Here&#39;s where you add the context extension:</span>
  <span class="n">OperationContext</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Extensions</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">TenantIdentificationContextExtension</span><span class="p">()</span> <span class="p">{</span> <span class="n">TenantId</span> <span class="p">=</span> <span class="n">tenantId</span> <span class="p">});</span>
  <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once the tenant ID is attached to the context, you can use an appropriate <code class="docutils literal notranslate"><span class="pre">ITenantIdentificationStrategy</span></code> to retrieve it as needed.</p>
<p><strong>If you use the TenantIdentificationContextExtension, then the provided Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy will automatically work to get the tenant ID from OperationContext.</strong></p>
</div>
<div class="section" id="hosting-multitenant-services">
<span id="hosting"></span><h5><a class="toc-backref" href="#id18">Hosting Multitenant Services</a><a class="headerlink" href="#hosting-multitenant-services" title="Permalink to this headline">¶</a></h5>
<p>In a WCF service application, service implementations may be tenant-specific yet share the same service contract. This allows you to provide your service contracts in a separate assembly to tenant-specific developers and allow them to implement custom logic without sharing any of the internals of your default implementation.</p>
<p>To enable this to happen, a custom strategy has been implemented for multitenant service location - <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf.MultitenantServiceImplementationDataProvider</span></code>.</p>
<p>In your service’s <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file, you must specify:</p>
<ul class="simple">
<li><strong>The full type name of the service contract interface.</strong> In regular <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">WCF integration</span></a> Autofac allows you to use either typed or named services. For multitenancy, you must use a typed service that is based on the service contract interface.</li>
<li><strong>The full type name of the Autofac host factory.</strong> This lets the hosting environment know which factory to use. (This is just like the <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">standard Autofac WCF integration</span></a>.)</li>
</ul>
<p>An example <code class="docutils literal notranslate"><span class="pre">.svc</span></code> file looks like this:</p>
<div class="highlight-aspx-cs notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;%@</span> <span class="n">ServiceHost</span>
    <span class="n">Service</span><span class="p">=</span><span class="s">&quot;MultitenantExample.WcfService.IMultitenantService, MultitenantExample.WcfService&quot;</span>
    <span class="n">Factory</span><span class="p">=</span><span class="s">&quot;Autofac.Integration.Wcf.AutofacServiceHostFactory, Autofac.Integration.Wcf&quot;</span> <span class="nt">%&gt;</span>
</pre></div>
</div>
<p>When registering service implementations with the Autofac container, you must register the implementations as the contract interface, like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseImplementation</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Tenant-specific overrides may then register using the interface type as well:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Implementation</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;());</span>
</pre></div>
</div>
<p>And don’t forget at app startup, around where you set the container, you need to tell Autofac you’re doing multitenancy:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">ServiceImplementationDataProvider</span> <span class="p">=</span>
  <span class="k">new</span> <span class="nf">MultitenantServiceImplementationDataProvider</span><span class="p">();</span>
</pre></div>
</div>
<div class="section" id="managing-service-attributes">
<h6><a class="toc-backref" href="#id19">Managing Service Attributes</a><a class="headerlink" href="#managing-service-attributes" title="Permalink to this headline">¶</a></h6>
<p>When configuring WCF services in XML configuration (e.g., web.config), WCF automatically infers the name of the service element it expects from the concrete service implementation type. For example, in a single-tenant implementation, your <code class="docutils literal notranslate"><span class="pre">MyNamespace.IMyService</span></code> service interface might have one implementation called <code class="docutils literal notranslate"><span class="pre">MyNamespace.MyService</span></code> and that’s what WCF would expect to look for in <code class="docutils literal notranslate"><span class="pre">web.config</span></code>, like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;system.serviceModel&gt;</span>
  <span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">name=</span><span class="s">&quot;MyNamespace.MyService&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/services&gt;</span>
<span class="nt">&lt;/system.serviceModel&gt;</span>
</pre></div>
</div>
<p>However, when using a multitenant service host, the concrete service type that implements the interface is a dynamically generated proxy type, so the service configuration name becomes an auto-generated type name, like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;system.serviceModel&gt;</span>
  <span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">name=</span><span class="s">&quot;Castle.Proxies.IMyService_1&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/services&gt;</span>
<span class="nt">&lt;/system.serviceModel&gt;</span>
</pre></div>
</div>
<p>To make this easier, <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf</span></code> provides the <code class="docutils literal notranslate"><span class="pre">Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute</span></code>, which you can use to create a “metadata buddy class” (similar to the <code class="docutils literal notranslate"><span class="pre">System.ComponentModel.DataAnnotations.MetadataTypeAttribute</span></code>) that you can mark with type-level attributes and modify the behavior of the dynamic proxy.</p>
<p>In this case, you need the dynamic proxy to have a <code class="docutils literal notranslate"><span class="pre">System.ServiceModel.ServiceBehaviorAttribute</span></code> so you can define the <code class="docutils literal notranslate"><span class="pre">ConfigurationName</span></code> to expect.</p>
<p>First, mark your service interface with a <code class="docutils literal notranslate"><span class="pre">ServiceMetadataTypeAttribute</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.ServiceModel</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Multitenant.Wcf</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">MyNamespace</span>
<span class="p">{</span>
<span class="na">  [ServiceContract]</span>
<span class="na">  [ServiceMetadataType(typeof(MyServiceBuddyClass))]</span>
  <span class="k">public</span> <span class="k">interface</span> <span class="n">IMyService</span>
  <span class="p">{</span>
    <span class="c1">// ...define your service operations...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next, create the buddy class you specified in the attribute and add the appropriate metadata.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.ServiceModel</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">MyNamespace</span>
<span class="p">{</span>
<span class="na">  [ServiceBehavior(ConfigurationName = &quot;MyNamespace.IMyService&quot;)]</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">MyServiceBuddyClass</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now in your XML configuration file, you can use the configuration name you specified on the buddy class:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;system.serviceModel&gt;</span>
  <span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">name=</span><span class="s">&quot;MyNamespace.IMyService&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/services&gt;</span>
<span class="nt">&lt;/system.serviceModel&gt;</span>
</pre></div>
</div>
<p><strong>Important notes about metadata</strong>:
- <strong>Only type-level attributes are copied.</strong> At this time, only attributes at the type level are copied over from the buddy class to the dynamic proxy. If you have a use case for property/method level metadata to be copied, please file an issue.
- <strong>Not all metadata will have the effect you expect.</strong> For example, if you use the <code class="docutils literal notranslate"><span class="pre">ServiceBehaviorAttribute</span></code> to define lifetime related information like <code class="docutils literal notranslate"><span class="pre">InstanceContextMode</span></code>, the service will not follow that directive because Autofac is managing the lifetime, not the standard service host. Use common sense when specifying metadata - if it doesn’t work, don’t forget you’re not using the standard service lifetime management functionality.
- <strong>Metadata is application-level, not per-tenant.</strong> The metadata buddy class info will take effect at an application level and can’t be overridden per tenant.</p>
</div>
<div class="section" id="tenant-specific-service-implementations">
<h6><a class="toc-backref" href="#id20">Tenant-Specific Service Implementations</a><a class="headerlink" href="#tenant-specific-service-implementations" title="Permalink to this headline">¶</a></h6>
<p>If you are hosting multitenant services (<a class="reference internal" href="#hosting"><span class="std std-ref">Hosting Multitenant Services</span></a>), you can provide tenant-specific service implementations. This allows you to provide a base implementation of a service and share the service contract with tenants to allow them to develop custom service implementations.</p>
<p><strong>You must implement your service contract as a separate interface</strong>. You can’t mark your service implementation with the <code class="docutils literal notranslate"><span class="pre">ServiceContractAttribute</span></code>. Your service implementations must then implement the interface. This is good practice anyway, but the multitenant service host won’t allow concrete types to directly define the contract.</p>
<p>Tenant-specific service implementations do not need to derive from the base implementation; they only need to implement the service interface.</p>
<p>You can register tenant-specific service implementations in app startup (see <a class="reference internal" href="#wcf-startup"><span class="std std-ref">WCF Application Startup</span></a>).</p>
</div>
</div>
<div class="section" id="wcf-application-startup">
<span id="wcf-startup"></span><h5><a class="toc-backref" href="#id21">WCF Application Startup</a><a class="headerlink" href="#wcf-application-startup" title="Permalink to this headline">¶</a></h5>
<p>Application startup is generally the same as any other multitenant application (<a class="reference internal" href="#register-dependencies"><span class="std std-ref">Register Dependencies</span></a>), but there are a couple of minor things to do for clients, and a little bit of hosting setup for services.</p>
<div class="section" id="wcf-client-application-startup">
<h6><a class="toc-backref" href="#id22">WCF Client Application Startup</a><a class="headerlink" href="#wcf-client-application-startup" title="Permalink to this headline">¶</a></h6>
<p><strong>In a WCF client application</strong>, when you register your service clients you’ll need to register the behavior that propagates the tenant ID to the service. If you’re following the <a class="reference internal" href="index.html#document-integration/wcf"><span class="doc">standard WCF integration guidance</span></a>, then registering a service client looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the tenant ID strategy for the client application.</span>
<span class="kt">var</span> <span class="n">tenantIdStrategy</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTenantIdentificationStrategy</span><span class="p">();</span>

<span class="c1">// Register application-level dependencies.</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>

<span class="c1">// The service client is not different per tenant because</span>
<span class="c1">// the service itself is multitenant - one client for all</span>
<span class="c1">// the tenants and ***the service implementation*** switches.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span>
  <span class="k">new</span> <span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;(</span>
    <span class="k">new</span> <span class="nf">BasicHttpBinding</span><span class="p">(),</span>
    <span class="k">new</span> <span class="nf">EndpointAddress</span><span class="p">(</span><span class="s">&quot;http://server/MultitenantService.svc&quot;</span><span class="p">))).</span><span class="n">SingleInstance</span><span class="p">();</span>

<span class="c1">// Register an endpoint behavior on the client channel factory that</span>
<span class="c1">// will propagate the tenant ID across the wire in a message header.</span>
<span class="c1">// In this example, the built-in TenantPropagationBehavior is used</span>
<span class="c1">// to send a string-based tenant ID across the wire.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;&gt;();</span>
    <span class="n">factory</span><span class="p">.</span><span class="n">Opening</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">factory</span><span class="p">.</span><span class="n">Endpoint</span><span class="p">.</span><span class="n">Behaviors</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">TenantPropagationBehavior</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">tenantIdStrategy</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">factory</span><span class="p">.</span><span class="n">CreateChannel</span><span class="p">();</span>
  <span class="p">});</span>

<span class="c1">// Create the multitenant container.</span>
<span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdStrategy</span><span class="p">,</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>

<span class="c1">// ... register tenant overrides, etc.</span>
</pre></div>
</div>
</div>
<div class="section" id="wcf-service-application-startup">
<h6><a class="toc-backref" href="#id23">WCF Service Application Startup</a><a class="headerlink" href="#wcf-service-application-startup" title="Permalink to this headline">¶</a></h6>
<p><strong>In a WCF service application</strong>, you register your defaults and tenant-specific overrides just as you normally would (<a class="reference internal" href="#register-dependencies"><span class="std std-ref">Register Dependencies</span></a>) but you have to also:</p>
<ul class="simple">
<li>Set up the behavior for service hosts to expect an incoming tenant ID header (<a class="reference internal" href="#behavior-id"><span class="std std-ref">Passing Tenant ID with a Behavior</span></a>) for tenant identification.</li>
<li>Set the service host factory container to a <code class="docutils literal notranslate"><span class="pre">MultitenantContainer</span></code>.</li>
</ul>
<p>In the example below, <strong>we are using the Autofac.Multitenant.Wcf.AutofacHostFactory</strong> rather than the standard Autofac host factory (as outlined earlier).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nn">MultitenantExample.WcfService</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">Global</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Web</span><span class="p">.</span><span class="n">HttpApplication</span>
  <span class="p">{</span>
    <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Create the tenant ID strategy.</span>
      <span class="kt">var</span> <span class="n">tenantIdStrategy</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OperationContextTenantIdentificationStrategy</span><span class="p">();</span>

      <span class="c1">// Register application-level dependencies and service implementations.</span>
      <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseImplementation</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;();</span>
      <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">BaseDependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;();</span>

      <span class="c1">// Create the multitenant container.</span>
      <span class="kt">var</span> <span class="n">mtc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MultitenantContainer</span><span class="p">(</span><span class="n">tenantIdStrategy</span><span class="p">,</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">());</span>

      <span class="c1">// Notice we configure tenant IDs as strings below because the tenant</span>
      <span class="c1">// identification strategy retrieves string values from the message</span>
      <span class="c1">// headers.</span>

      <span class="c1">// Configure overrides for tenant 1 - dependencies, service implementations, etc.</span>
      <span class="n">mtc</span><span class="p">.</span><span class="n">ConfigureTenant</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span>
        <span class="n">b</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
          <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Dependency</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IDependency</span><span class="p">&gt;().</span><span class="n">InstancePerDependency</span><span class="p">();</span>
          <span class="n">b</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Tenant1Implementation</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMultitenantService</span><span class="p">&gt;();</span>
        <span class="p">});</span>

      <span class="c1">// Add a behavior to service hosts that get created so incoming messages</span>
      <span class="c1">// get inspected and the tenant ID can be parsed from message headers.</span>
      <span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">HostConfigurationAction</span> <span class="p">=</span>
        <span class="n">host</span> <span class="p">=&gt;</span>
          <span class="n">host</span><span class="p">.</span><span class="n">Opening</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="n">host</span><span class="p">.</span><span class="n">Description</span><span class="p">.</span><span class="n">Behaviors</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">TenantPropagationBehavior</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">tenantIdStrategy</span><span class="p">));</span>

      <span class="c1">// Set the service implementation strategy to multitenant.</span>
      <span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">ServiceImplementationDataProvider</span> <span class="p">=</span>
        <span class="k">new</span> <span class="nf">MultitenantServiceImplementationDataProvider</span><span class="p">();</span>

      <span class="c1">// Finally, set the host factory application container on the multitenant</span>
      <span class="c1">// WCF host to a multitenant container.</span>
      <span class="n">AutofacHostFactory</span><span class="p">.</span><span class="n">Container</span> <span class="p">=</span> <span class="n">mtc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="tenant-id-strategy-tips">
<span id="id3"></span><h4><a class="toc-backref" href="#id24">Tenant ID Strategy Tips</a><a class="headerlink" href="#tenant-id-strategy-tips" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Performance is key.</strong> The tenant ID strategy will execute on every resolve operation and every lifetime scope creation in the multitenant container. Do everything you can to make it efficient - cache things instead of database lookups every time, reduce memory allocations, etc.</li>
<li><strong>Handle errors well.</strong> If the tenant ID strategy blows up for any reason, it’s going to be potentially difficult to troubleshoot. Make sure you check for nulls and handle exceptions. From a performance perspective, make sure you use <code class="docutils literal notranslate"><span class="pre">TryGet</span></code> or <code class="docutils literal notranslate"><span class="pre">TryParse</span></code> sorts of operations rather than <code class="docutils literal notranslate"><span class="pre">try/catch</span></code> and letting exceptions control flow.</li>
<li><strong>Make your tenant ID strategy a singleton.</strong> The multitenant container stores an instance of the tenant ID strategy. If you are registering the strategy in your base (non-multitenant) container, make sure you register it as a singleton. Further, make sure dependencies that the tenant ID strategy might consume are also singletons… or are allowed to have individual instances cached.</li>
<li><strong>If you can, create the tenant ID strategy and then register it</strong> rather than simply registering a type with Autofac and letting it resolve. It’s tempting to “over-DI” things. The tenant ID strategy is pretty foundational and you want to make sure it works; troubleshooting why something didn’t inject into the strategy can be painful. Further, it can be easy to “accidentally” make the tenant ID strategy a factory scoped or per-lifetime-scope thing and that won’t work. It can also be easy to lose sight of the fact that things going into the tenant ID strategy are cached for the lifetime of the app, not something that gets populated per request. If you actually “new-up” the strategy and register the instance with Autofac rather than registering a singleton type, it can drive home that discipline and help you avoid issues.</li>
<li><strong>Watch for threading issues!</strong> The tenant ID strategy is held by the multitenant container and used across all operations. It’s a singleton! If you cache things, make the cache operations threadsafe. If you store state, make sure it’s in a structure like a dictionary where you can store state for every tenant in the system (or cache lookups in a non-tenant-specific way). If you have an instance variable called “tenant,” you’re going to have trouble - that “tenant” isn’t the same across every thread and every resolve operation.</li>
</ul>
</div>
<div class="section" id="example">
<h4><a class="toc-backref" href="#id25">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>The Autofac example repository has a <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MultitenantExample.WcfService">multitenant WCF service</a> and <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MultitenantExample.MvcApplication">associated client MVC application</a> to illustrate how <a class="reference internal" href="index.html#document-advanced/multitenant"><span class="doc">multitenant service hosting</span></a> works.</p>
<p>There is also a <a class="reference external" href="https://github.com/autofac/Examples/tree/master/src/MultitenantExample.ConsoleApplication">very simple console application</a> example.</p>
</div>
</div>
<span id="document-advanced/aggregate-services"></span><div class="section" id="aggregate-services">
<h3>Aggregate Services<a class="headerlink" href="#aggregate-services" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>An aggregate service is useful when you need to treat a set of dependencies as one dependency. When a class depends on several constructor-injected services, or have several property-injected services, moving those services into a separate class yields a simpler API.</p>
<p>An example is super- and subclasses where the superclass have one or more constructor-injected dependencies. The subclasses must usually inherit these dependencies, even though they might only be useful to the superclass. With an aggregate service, the superclass constructor parameters can be collapsed into one parameter, reducing the repetitiveness in subclasses. Another important side effect is that subclasses are now insulated against changes in the superclass dependencies, introducing a new dependency in the superclass means only changing the aggregate service definition.</p>
<p>The pattern and this example <a class="reference external" href="http://peterspattern.com/dependency-injection-and-class-inheritance">are both further elaborated here</a>.</p>
<p>Aggregate services can be implemented by hand, e.g. by building a class with constructor-injected dependencies and exposing those as properties. Writing and maintaining aggregate service classes and accompanying tests can quickly get tedious though. The AggregateService extension to Autofac lets you generate aggregate services directly from interface definitions without having to write any implementation.</p>
</div>
<div class="section" id="required-references">
<h4>Required References<a class="headerlink" href="#required-references" title="Permalink to this headline">¶</a></h4>
<p>You can add aggregate service support to your project using <a class="reference external" href="https://nuget.org/packages/Autofac.Extras.AggregateService">the Autofac.Extras.AggregateService NuGet package</a> or by manually adding references to these assemblies:</p>
<blockquote>
<div><ul class="simple">
<li>Autofac.dll</li>
<li>Autofac.Extras.AggregateService.dll</li>
<li>Castle.Core.dll (<a class="reference external" href="http://www.castleproject.org/download/">from the Castle project</a>)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="getting-started">
<h4>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h4>
<p>Lets say we have a class with a number of constructor-injected dependencies that we store privately for later use:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SomeController</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IFirstService</span> <span class="n">_firstService</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">ISecondService</span> <span class="n">_secondService</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IThirdService</span> <span class="n">_thirdService</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IFourthService</span> <span class="n">_fourthService</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SomeController</span><span class="p">(</span>
    <span class="n">IFirstService</span> <span class="n">firstService</span><span class="p">,</span>
    <span class="n">ISecondService</span> <span class="n">secondService</span><span class="p">,</span>
    <span class="n">IThirdService</span> <span class="n">thirdService</span><span class="p">,</span>
    <span class="n">IFourthService</span> <span class="n">fourthService</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_firstService</span> <span class="p">=</span> <span class="n">firstService</span><span class="p">;</span>
    <span class="n">_secondService</span> <span class="p">=</span> <span class="n">secondService</span><span class="p">;</span>
    <span class="n">_thirdService</span> <span class="p">=</span> <span class="n">thirdService</span><span class="p">;</span>
    <span class="n">_fourthService</span> <span class="p">=</span> <span class="n">fourthService</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To aggregate the dependencies we move those into a separate interface definition and take a dependency on that interface instead.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IMyAggregateService</span>
<span class="p">{</span>
  <span class="n">IFirstService</span> <span class="n">FirstService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ISecondService</span> <span class="n">SecondService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">IThirdService</span> <span class="n">ThirdService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">IFourthService</span> <span class="n">FourthService</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeController</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IMyAggregateService</span> <span class="n">_aggregateService</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SomeController</span><span class="p">(</span><span class="n">IMyAggregateService</span> <span class="n">aggregateService</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_aggregateService</span> <span class="p">=</span> <span class="n">aggregateService</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we register the aggregate service interface.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">Autofac</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Autofac.Extras.AggregateService</span><span class="p">;</span>
<span class="c1">//...</span>

<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterAggregateService</span><span class="p">&lt;</span><span class="n">IMyAggregateService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IFirstService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISecondService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IThirdService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IFourthService</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeController</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>The interface for the aggregate service will automatically have an implementation generated for you and the dependencies will be filled in as expected.</p>
</div>
<div class="section" id="how-aggregate-services-are-resolved">
<h4>How Aggregate Services are Resolved<a class="headerlink" href="#how-aggregate-services-are-resolved" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="properties">
<h4>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h4>
<p>Read-only properties mirror the behavior of regular constructor-injected dependencies. The type of each property will be resolved and cached in the aggregate service when the aggregate service instance is constructed.</p>
<p>Here is a functionally equivalent sample:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyAggregateServiceImpl</span><span class="p">:</span> <span class="n">IMyAggregateService</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IMyService</span> <span class="n">_myService</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MyAggregateServiceImpl</span><span class="p">(</span><span class="n">IComponentContext</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_myService</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IMyService</span><span class="p">&gt;();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IMyService</span> <span class="n">MyService</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_myService</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="methods">
<h4>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h4>
<p>Methods will behave like factory delegates and will translate into a resolve call on each invocation. The method return type will be resolved, passing on any parameters to the resolve call.</p>
<p>A functionally equivalent sample of the method call:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyAggregateServiceImpl</span><span class="p">:</span> <span class="n">IMyAggregateService</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">ISomeThirdService</span> <span class="nf">GetThirdService</span><span class="p">(</span><span class="kt">string</span> <span class="n">data</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">dataParam</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TypedParameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ISomeThirdService</span><span class="p">&gt;(</span><span class="n">dataParam</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="property-setters-and-void-methods">
<h4>Property Setters and Void Methods<a class="headerlink" href="#property-setters-and-void-methods" title="Permalink to this headline">¶</a></h4>
<p>Property setters and methods without return types does not make sense in the aggregate service. Their presence in the aggregate service interface does not prevent proxy generation. Calling such methods though will throw an exception.</p>
</div>
<div class="section" id="how-it-works">
<h4>How It Works<a class="headerlink" href="#how-it-works" title="Permalink to this headline">¶</a></h4>
<p>Under the covers, the AggregateService uses DynamicProxy2 from <a class="reference external" href="http://castleproject.org">the Castle Project</a>. Given an interface (the aggregate of services into one), a proxy is generated implementing the interface. The proxy will translate calls to properties and methods into <code class="docutils literal notranslate"><span class="pre">Resolve</span></code> calls to an Autofac context.</p>
</div>
<div class="section" id="performance-considerations">
<h4>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Permalink to this headline">¶</a></h4>
<p>Due to the fact that method calls in the aggregate service pass through a dynamic proxy there is a small but non-zero amount of overhead on each method call. A performance study on Castle DynamicProxy2 vs other frameworks can be found <a class="reference external" href="http://kozmic.pl/2009/03/31/dynamic-proxy-frameworks-comparison-update/">here</a>.</p>
</div>
</div>
<span id="document-advanced/interceptors"></span><div class="section" id="type-interceptors">
<h3>Type Interceptors<a class="headerlink" href="#type-interceptors" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/castleproject/Core">Castle.Core</a>, part of <a class="reference external" href="http://castleproject.org">the Castle Project</a>, provides a method interception framework called “DynamicProxy.”</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.DynamicProxy</span></code> integration package enables method calls on Autofac components to be intercepted by other components. Common use-cases are transaction handling, logging, and declarative security. You can use <code class="docutils literal notranslate"><span class="pre">Autofac.Extras.DynamicProxy2</span></code> for Autofac versions up to 4.0.0</p>
<div class="section" id="enabling-interception">
<h4>Enabling Interception<a class="headerlink" href="#enabling-interception" title="Permalink to this headline">¶</a></h4>
<p>The basic steps to get DynamicProxy integration working are:</p>
<ul class="simple">
<li><a class="reference internal" href="#create-interceptors"><span class="std std-ref">Create Interceptors</span></a></li>
<li><a class="reference internal" href="#register-interceptors"><span class="std std-ref">Register Interceptors with Autofac</span></a></li>
<li><a class="reference internal" href="#enable-type-interception"><span class="std std-ref">Enable Interception on Types</span></a></li>
<li><a class="reference internal" href="#associate-interceptors"><span class="std std-ref">Associate Interceptors with Types to be Intercepted</span></a></li>
</ul>
<div class="section" id="create-interceptors">
<span id="id1"></span><h5>Create Interceptors<a class="headerlink" href="#create-interceptors" title="Permalink to this headline">¶</a></h5>
<p>Interceptors implement the <code class="docutils literal notranslate"><span class="pre">Castle.DynamicProxy.IInterceptor</span></code> interface. Here’s a simple interceptor example that logs method calls including inputs and outputs:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CallLogger</span> <span class="p">:</span> <span class="n">IInterceptor</span>
<span class="p">{</span>
  <span class="n">TextWriter</span> <span class="n">_output</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">CallLogger</span><span class="p">(</span><span class="n">TextWriter</span> <span class="n">output</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Intercept</span><span class="p">(</span><span class="n">IInvocation</span> <span class="n">invocation</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_output</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Calling method {0} with parameters {1}... &quot;</span><span class="p">,</span>
      <span class="n">invocation</span><span class="p">.</span><span class="n">Method</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
      <span class="kt">string</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="n">invocation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="p">??</span> <span class="s">&quot;&quot;</span><span class="p">).</span><span class="n">ToString</span><span class="p">()).</span><span class="n">ToArray</span><span class="p">()));</span>

    <span class="n">invocation</span><span class="p">.</span><span class="n">Proceed</span><span class="p">();</span>

    <span class="n">_output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Done: result was {0}.&quot;</span><span class="p">,</span> <span class="n">invocation</span><span class="p">.</span><span class="n">ReturnValue</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="register-interceptors-with-autofac">
<span id="register-interceptors"></span><h5>Register Interceptors with Autofac<a class="headerlink" href="#register-interceptors-with-autofac" title="Permalink to this headline">¶</a></h5>
<p>Interceptors must be registered with the container. You can register them either as typed services or as named services. If you register them as named services, they must be named <code class="docutils literal notranslate"><span class="pre">IInterceptor</span></code> registrations.</p>
<p>Which of these you choose depends on how you decide to associate interceptors with the types being intercepted.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Named registration</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">))</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="n">IInterceptor</span><span class="p">&gt;(</span><span class="s">&quot;log-calls&quot;</span><span class="p">);</span>

<span class="c1">// Typed registration</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="enable-interception-on-types">
<span id="enable-type-interception"></span><h5>Enable Interception on Types<a class="headerlink" href="#enable-interception-on-types" title="Permalink to this headline">¶</a></h5>
<p>When you register a type being intercepted, you have to mark the type at registration time so Autofac knows to wire up that interception. You do this using the <code class="docutils literal notranslate"><span class="pre">EnableInterfaceInterceptors()</span></code> and <code class="docutils literal notranslate"><span class="pre">EnableClassInterceptors()</span></code> registration extensions.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISomeInterface</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">EnableInterfaceInterceptors</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">));</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">willBeIntercepted</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ISomeInterface</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Under the covers, <code class="docutils literal notranslate"><span class="pre">EnableInterfaceInterceptors()</span></code> creates an interface proxy that performs the interception, while <code class="docutils literal notranslate"><span class="pre">EnableClassInterceptors()</span></code> dynamically subclasses the target component to perform interception of virtual methods.</p>
<p>Both techniques can be used in conjunction with the assembly scanning support, so you can configure batches of components using the same methods.</p>
<p><strong>Special case: WCF proxy and remoting objects</strong>
While WCF proxy objects <em>look</em> like interfaces, the <code class="docutils literal notranslate"><span class="pre">EnableInterfaceInterceptors()</span></code> mechanism won’t work because, behind the scenes, .NET is actually using a <code class="docutils literal notranslate"><span class="pre">System.Runtime.Remoting.TransparentProxy</span></code> object that behaves like the interface. If you want interception on a WCF proxy, you need to use the <code class="docutils literal notranslate"><span class="pre">InterceptTransparentProxy()</span></code> method.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">cb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">cb</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TestServiceInterceptor</span><span class="p">&gt;();</span>
<span class="n">cb</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">CreateChannelFactory</span><span class="p">()).</span><span class="n">SingleInstance</span><span class="p">();</span>
<span class="n">cb</span>
  <span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">ITestService</span><span class="p">&gt;&gt;().</span><span class="n">CreateChannel</span><span class="p">())</span>
  <span class="p">.</span><span class="n">InterceptTransparentProxy</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IClientChannel</span><span class="p">))</span>
  <span class="p">.</span><span class="n">InterceptedBy</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">TestServiceInterceptor</span><span class="p">))</span>
  <span class="p">.</span><span class="n">UseWcfSafeRelease</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="associate-interceptors-with-types-to-be-intercepted">
<span id="associate-interceptors"></span><h5>Associate Interceptors with Types to be Intercepted<a class="headerlink" href="#associate-interceptors-with-types-to-be-intercepted" title="Permalink to this headline">¶</a></h5>
<p>To pick which interceptor is associated with your type, you have two choices.</p>
<p>Your first option is to mark the type with an attribute, like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This attribute will look for a TYPED</span>
<span class="c1">// interceptor registration:</span>
<span class="na">[Intercept(typeof(CallLogger))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">First</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">GetValue</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Do some calculation and return a value</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This attribute will look for a NAMED</span>
<span class="c1">// interceptor registration:</span>
<span class="na">[Intercept(&quot;log-calls&quot;)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Second</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">GetValue</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Do some calculation and return a value</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you use attributes to associate interceptors, you don’t need to specify the interceptor at registration time. You can just enable interception and the interceptor type will automatically be discovered.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Using the TYPED attribute:</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">First</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">EnableClassInterceptors</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">));</span>

<span class="c1">// Using the NAMED attribute:</span>
<span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Second</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">EnableClassInterceptors</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">))</span>
       <span class="p">.</span><span class="n">Named</span><span class="p">&lt;</span><span class="n">IInterceptor</span><span class="p">&gt;(</span><span class="s">&quot;log-calls&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The second option is to declare the interceptor at Autofac registration time. You can do this using the <code class="docutils literal notranslate"><span class="pre">InterceptedBy()</span></code> registration extension:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">EnableClassInterceptors</span><span class="p">()</span>
       <span class="p">.</span><span class="n">InterceptedBy</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CallLogger</span><span class="p">));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tips">
<h4>Tips<a class="headerlink" href="#tips" title="Permalink to this headline">¶</a></h4>
<div class="section" id="use-public-interfaces">
<h5>Use Public Interfaces<a class="headerlink" href="#use-public-interfaces" title="Permalink to this headline">¶</a></h5>
<p>Interface interception requires the interface be public (or, at least, visible to the dynamically generated proxy assembly). Non-public interface types can’t be intercepted.</p>
<p>If you want to proxy <code class="docutils literal notranslate"><span class="pre">internal</span></code> interfaces, you must mark the assembly containing the interface with <code class="docutils literal notranslate"><span class="pre">[assembly:</span> <span class="pre">InternalsVisibleTo(&quot;DynamicProxyGenAssembly2&quot;)]</span></code>.</p>
</div>
<div class="section" id="use-virtual-methods">
<h5>Use Virtual Methods<a class="headerlink" href="#use-virtual-methods" title="Permalink to this headline">¶</a></h5>
<p>Class interception requires the methods being intercepted to be virtual since it uses subclassing as the proxy technique.</p>
</div>
<div class="section" id="usage-with-expressions">
<h5>Usage with Expressions<a class="headerlink" href="#usage-with-expressions" title="Permalink to this headline">¶</a></h5>
<p>Components created using expressions, or those registered as instances, cannot be subclassed by the DynamicProxy2 engine. In these cases, it is necessary to use interface-based proxies.</p>
</div>
<div class="section" id="interface-registrations">
<h5>Interface Registrations<a class="headerlink" href="#interface-registrations" title="Permalink to this headline">¶</a></h5>
<p>To enable proxying via interfaces, the component must provide its services through interfaces only. For best performance, all such service interfaces should be part of the registration, i.e. included in <code class="docutils literal notranslate"><span class="pre">As&lt;X&gt;()</span></code> clauses.</p>
</div>
<div class="section" id="wcf-proxies">
<h5>WCF Proxies<a class="headerlink" href="#wcf-proxies" title="Permalink to this headline">¶</a></h5>
<p>As mentioned earlier, WCF proxies and other remoting types are special cases and can’t use standard interface or class interception. You must use <code class="docutils literal notranslate"><span class="pre">InterceptTransparentProxy()</span></code> on those types.</p>
</div>
<div class="section" id="class-interceptors-and-usingconstructor">
<h5>Class Interceptors and UsingConstructor<a class="headerlink" href="#class-interceptors-and-usingconstructor" title="Permalink to this headline">¶</a></h5>
<p>If you are using class interceptors via <code class="docutils literal notranslate"><span class="pre">EnableClassInterceptors()</span></code> then avoid using the constructor selector <code class="docutils literal notranslate"><span class="pre">UsingConstructor()</span></code> with it. When class interception is enabled, the generated proxy adds some new constructors that also take the set of interceptors you want to use. When you specify <code class="docutils literal notranslate"><span class="pre">UsingConstructor()</span></code> you’ll bypass this logic and your interceptors won’t be used.</p>
</div>
</div>
<div class="section" id="known-issues">
<h4>Known Issues<a class="headerlink" href="#known-issues" title="Permalink to this headline">¶</a></h4>
<div class="section" id="asynchronous-method-interception">
<h5>Asynchronous Method Interception<a class="headerlink" href="#asynchronous-method-interception" title="Permalink to this headline">¶</a></h5>
<p>Castle interceptors only expose a synchronous mechanism to intercept methods - there’s no explicit <code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> sort of support. However, given <code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> is just syntactic sugar around returning <code class="docutils literal notranslate"><span class="pre">Task</span></code> objects, you can use <code class="docutils literal notranslate"><span class="pre">Task</span></code> and <code class="docutils literal notranslate"><span class="pre">ContinueWith()</span></code> sorts of methods in your interceptor. <a class="reference external" href="https://github.com/castleproject/Core/issues/107">This issue</a> shows an example of that. Alternatively, there are <a class="reference external" href="https://github.com/JSkimming/Castle.Core.AsyncInterceptor">helper libraries</a> that make async work easier.</p>
</div>
<div class="section" id="castle-core-versioning">
<h5>Castle.Core Versioning<a class="headerlink" href="#castle-core-versioning" title="Permalink to this headline">¶</a></h5>
<p>As of Castle.Core 4.2.0, the Castle.Core <em>NuGet package version</em> updates but the <em>assembly version</em> does not. Further, the assembly version in Castle.Core 4.1.0 matched the package (4.1.0.0) but the 4.2.0 package <em>back-versioned</em> to 4.0.0.0. In full .NET framework projects any confusion around Castle.Core versioning can be solved by adding an assembly binding redirect to force use of Castle.Core 4.0.0.0.</p>
<p>Unfortunately, .NET core doesn’t have assembly binding redirects so if you have a <em>transitive</em> dependency on Castle.Core through a library like Autofac.Extras.DynamicProxy and you <em>also</em> have a direct dependency on Castle.Core, you may see something like:</p>
<p><code class="docutils literal notranslate"><span class="pre">System.IO.FileLoadException:</span> <span class="pre">Could</span> <span class="pre">not</span> <span class="pre">load</span> <span class="pre">file</span> <span class="pre">or</span> <span class="pre">assembly</span>
<span class="pre">'Castle.Core,</span> <span class="pre">Version=4.1.0.0,</span> <span class="pre">Culture=neutral,</span> <span class="pre">PublicKeyToken=407dd0808d44fbdc'.</span>
<span class="pre">The</span> <span class="pre">located</span> <span class="pre">assembly's</span> <span class="pre">manifest</span> <span class="pre">definition</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">match</span> <span class="pre">the</span>
<span class="pre">assembly</span> <span class="pre">reference.</span> <span class="pre">(Exception</span> <span class="pre">from</span> <span class="pre">HRESULT:</span> <span class="pre">0x80131040)</span></code></p>
<p>This happens because of the back-versioned assembly.</p>
<p><strong>Be sure you have the latest Autofac.Extras.DynamicProxy.</strong> We do our best to fix as much as possible from the Autofac end. An update to that and/or Castle.Core may help.</p>
<p>If that doesn’t work, there are two solutions:</p>
<p>One, you can remove your direct Castle.Core reference. The transitive references should sort themselves out.</p>
<p>Two, if you can’t remove your direct reference or removing it doesn’t work… all of the direct dependencies you have will need to update to version 4.2.0 or higher of Castle.Core. You’ll have to file issues with those projects; it’s not something Autofac can fix for you.</p>
<p><a class="reference external" href="https://github.com/castleproject/Core/issues/288">For reference, here’s the Castle.Core issue discussing this challenge.</a></p>
</div>
</div>
</div>
<span id="document-advanced/cross-platform-apps"></span><div class="section" id="cross-platform-and-native-applications">
<h3>Cross-Platform and Native Applications<a class="headerlink" href="#cross-platform-and-native-applications" title="Permalink to this headline">¶</a></h3>
<p>Tools like Xamarin and .NET Native enable .NET code to be compiled to target specific platforms. However, given .NET reflection doesn’t necessarily “just work” on all native platforms and auto-wiring of parameters and construction of objects largely relies on reflection, you sometimes have to do some additional work to get Autofac and DI to work.</p>
<div class="section" id="xamarin">
<h4>Xamarin<a class="headerlink" href="#xamarin" title="Permalink to this headline">¶</a></h4>
<p>When using Xamarin to create an iOS or Android app and the linker is enabled, you may need to explicitly describe types requiring reflection. The <a class="reference external" href="https://developer.xamarin.com/guides/cross-platform/advanced/custom_linking/">Xamarin Custom Linker Configuration</a> documentation explains how you can notify the linker to keep certain types and not strip them from the finished product. This boils down to…</p>
<ul class="simple">
<li>Mark types you own with a <code class="docutils literal notranslate"><span class="pre">[Preserve]</span></code> attribute</li>
<li>Include a custom XML link description file in your build</li>
</ul>
<p>A simple link description file looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;linker&gt;</span>
  <span class="nt">&lt;assembly</span> <span class="na">fullname=</span><span class="s">&quot;mscorlib&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;type</span> <span class="na">fullname=</span><span class="s">&quot;System.Convert&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/assembly&gt;</span>
  <span class="nt">&lt;assembly</span> <span class="na">fullname=</span><span class="s">&quot;My.Own.Assembly&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;type</span> <span class="na">fullname=</span><span class="s">&quot;Foo&quot;</span> <span class="na">preserve=</span><span class="s">&quot;fields&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;method</span> <span class="na">name=</span><span class="s">&quot;.ctor&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/type&gt;</span>
    <span class="nt">&lt;namespace</span> <span class="na">fullname=</span><span class="s">&quot;My.Own.Namespace&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;type</span> <span class="na">fullname=</span><span class="s">&quot;My.Other*&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/assembly&gt;</span>
  <span class="nt">&lt;assembly</span> <span class="na">fullname=</span><span class="s">&quot;Autofac&quot;</span> <span class="na">preserve=</span><span class="s">&quot;all&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/linker&gt;</span>
</pre></div>
</div>
<p>Autofac makes use of the <code class="docutils literal notranslate"><span class="pre">System.Convert.ChangeType</span></code> method in lambda expressions to convert types so including it in the linker definition is needed. See <a class="reference external" href="https://github.com/autofac/Autofac/issues/842">issue #842</a> for further discussion.</p>
<p>For additional details on how to structure your Xamarin custom linker configuration file and how to include it in your build, <a class="reference external" href="https://developer.xamarin.com/guides/cross-platform/advanced/custom_linking/">check out the Xamarin documentation</a>.</p>
<p>Autofac may not be seen as “linker safe” by the Xamarin linker. If the linker gets too aggressive, you may see an exception like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="nb">type</span> <span class="s1">&#39;Autofac.Features.Indexed.KeyedServiceIndex&#39;</span><span class="mi">2</span><span class="s1">&#39; does not implement the interface &#39;</span><span class="n">Autofac</span><span class="o">.</span><span class="n">Features</span><span class="o">.</span><span class="n">Indexed</span><span class="o">.</span><span class="n">IIndex</span><span class="s1">&#39;2&#39;</span>
</pre></div>
</div>
<p>[This StackOverflow answer](<a class="reference external" href="https://stackoverflow.com/questions/58114288/autofac-build-throws-exception-on-latest-xamarin-ios-when-linker-configured-to">https://stackoverflow.com/questions/58114288/autofac-build-throws-exception-on-latest-xamarin-ios-when-linker-configured-to</a>) indicates that you can do one of the following things:</p>
<blockquote>
<div><ul class="simple">
<li>Set the linker to <code class="docutils literal notranslate"><span class="pre">Don't</span> <span class="pre">link</span></code> or <code class="docutils literal notranslate"><span class="pre">Link</span> <span class="pre">Framework</span> <span class="pre">SDKs</span> <span class="pre">Only</span></code> (which will increase your application size)</li>
<li>Add the <code class="docutils literal notranslate"><span class="pre">--linkskip=Autofac</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">Additional</span> <span class="pre">mtouch</span> <span class="pre">arguments</span> <span class="pre">in</span> <span class="pre">iOS</span> <span class="pre">Build</span></code> found in the iOS project properties.</li>
<li>Use a linker XML like the one above and make sure the <code class="docutils literal notranslate"><span class="pre">Autofac</span></code> line with <code class="docutils literal notranslate"><span class="pre">preserve=&quot;all&quot;</span></code> is included.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="net-native">
<h4>.NET Native<a class="headerlink" href="#net-native" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx">.NET Native</a> is a way to compile .NET binaries to native code. It’s used in Universal Windows Platform (UWP) and Windows Store apps, among others.</p>
<p>When using <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn600640(v=vs.110).aspx">.NET Native with reflection</a> you may run into exceptions like <code class="docutils literal notranslate"><span class="pre">MissingMetadataException</span></code> when the compiler has removed the reflection metadata for types you need.</p>
<p>You can configure .NET Native compilation using a <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn600639(v=vs.110).aspx">Runtime Directives (rd.xml) file</a>. A simple directive file looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;Directives</span> <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/netfx/2013/01/metadata&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Application&gt;</span>
    <span class="nt">&lt;Assembly</span> <span class="na">Name=</span><span class="s">&quot;*Application*&quot;</span> <span class="na">Dynamic=</span><span class="s">&quot;Required All&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/Application&gt;</span>
<span class="nt">&lt;/Directives&gt;</span>
</pre></div>
</div>
<p>That directive file tells the compiler to keep all the reflection data for everything in the entire application package. That’s sort of the “nuclear option” - if you want to make your application package smaller you can be much more specific about what to include. <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn600639(v=vs.110).aspx">Refer to the MSDN documentation for more detail.</a></p>
</div>
</div>
<span id="document-advanced/debugging"></span><div class="section" id="debugging-and-troubleshooting">
<h3>Debugging and Troubleshooting<a class="headerlink" href="#debugging-and-troubleshooting" title="Permalink to this headline">¶</a></h3>
<p>If you’re really having trouble and you haven’t been able to get <a class="reference external" href="https://stackoverflow.com/questions/tagged/autofac">an answer on StackOverflow</a> you may want to try doing a little more in-depth debugging/troubleshooting on your own. Here are some tips on doing that.</p>
<div class="section" id="exceptions">
<h4>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h4>
<p>The exceptions generated by Autofac really try to point you in the right direction with respect to what could be going wrong. Don’t panic! Stop and read what it’s actually telling you.</p>
<p>For example, say you see a message that starts like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">None</span> <span class="n">of</span> <span class="n">the</span> <span class="n">constructors</span> <span class="n">found</span> <span class="k">with</span> <span class="s1">&#39;Autofac.Core.Activators.Reflection.DefaultConstructorFinder&#39;</span>
<span class="n">on</span> <span class="nb">type</span> <span class="s1">&#39;Your.EncryptionService&#39;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">invoked</span> <span class="k">with</span> <span class="n">the</span> <span class="n">available</span>
<span class="n">services</span> <span class="ow">and</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Cannot</span> <span class="n">resolve</span> <span class="n">parameter</span> <span class="s1">&#39;Your.SecuritySettings securitySettings&#39;</span>
<span class="n">of</span> <span class="n">constructor</span> <span class="s1">&#39;Void .ctor(Your.SecuritySettings)&#39;</span>
</pre></div>
</div>
<p>In this case, Autofac is trying to create an instance of your service and it can’t resolve a constructor parameter it needs. Chances are you need to look at the things you have registered with Autofac and make sure you have something registered that can fulfill the constructor requirement. You could even verify this by manually trying to resolve the parameter yourself right from the container (in a test/debug environment). You may <em>think</em> you have it registered, but for whatever reason Autofac isn’t seeing the registration. (Autofac requires you explicitly register all services. Look at the <a class="reference internal" href="index.html#document-advanced/registration-sources"><span class="doc">Any Concrete Type Not Already Registered registration source</span></a> if you don’t want to register everything.)</p>
<p>It may be that the top-level exception message doesn’t make sense, but that there are nested inner exceptions that have more information. Check those out! Creating big object graphs can sometimes yield a deep exception tree to help you pinpoint where exactly in the large graph things went wrong. Don’t just stop at the top level.</p>
<p>Also, take a look at your exception stack traces. It may look like Autofac is the source of an exception when really it’s getting caught by something going wrong in a constructor in one of your objects.</p>
<p>And, of course, if you’re hitting that ever-challenging <code class="docutils literal notranslate"><span class="pre">No</span> <span class="pre">scope</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">Tag</span> <span class="pre">matching</span> <span class="pre">'AutofacWebRequest'</span></code> exception, <a class="reference internal" href="index.html#document-faq/per-request-scope"><span class="doc">we have a whole FAQ on that</span></a>.</p>
</div>
<div class="section" id="symbols-and-sources">
<h4>Symbols and Sources<a class="headerlink" href="#symbols-and-sources" title="Permalink to this headline">¶</a></h4>
<p>Autofac publishes symbols and sources for its various packages on SymbolSource and MyGet. (Older packages are on SymbolSource, newer stuff has moved to MyGet.)</p>
<p>You can set up Visual Studio to debug/step <em>right into Autofac source</em> using the following symbol servers:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">https://www.myget.org/F/autofac/symbols/</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">http://srv.symbolsource.org/pdb/Public/</span></code></li>
</ul>
<p><a class="reference external" href="http://docs.myget.org/docs/reference/symbolsource">There is documentation on MyGet explaining how to configure Visual Studio to make this work.</a></p>
</div>
<div class="section" id="support">
<h4>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h4>
<p>We have a <a class="reference internal" href="index.html#document-support"><span class="doc">whole page outlining how to get support</span></a>.</p>
</div>
</div>
</div>
</div>
<span id="document-examples/index"></span><div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-examples/repository"></span><div class="section" id="examples-repository">
<h3>Examples Repository<a class="headerlink" href="#examples-repository" title="Permalink to this headline">¶</a></h3>
<p>Autofac provides <a class="reference external" href="https://github.com/autofac/Examples">a GitHub repository full of examples</a> to illustrate how various integrations work. The documentation on this site links to specific relevant examples where possible.</p>
<p><a class="reference external" href="https://github.com/autofac/Examples">Check out that repo for a better understanding of Autofac in action.</a></p>
</div>
<span id="document-examples/log4net"></span><div class="section" id="log4net-integration-module">
<h3>log4net Integration Module<a class="headerlink" href="#log4net-integration-module" title="Permalink to this headline">¶</a></h3>
<p>While there is no specific assembly for log4net support, you can easily inject <code class="docutils literal notranslate"><span class="pre">log4net.ILog</span></code> values using a very small custom module.</p>
<p>This module is also a good example of how to use <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> for more than simple configuration - they’re also helpful for doing some more advanced extensions.</p>
<p>Here’s a sample module that configures Autofac to inject <code class="docutils literal notranslate"><span class="pre">ILog</span></code> parameters based on the type of the component being activated. This sample module will handle both constructor and property injection.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">LoggingModule</span> <span class="p">:</span> <span class="n">Autofac</span><span class="p">.</span><span class="n">Module</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">InjectLoggerProperties</span><span class="p">(</span><span class="kt">object</span> <span class="n">instance</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">instanceType</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">GetType</span><span class="p">();</span>

    <span class="c1">// Get all the injectable properties to set.</span>
    <span class="c1">// If you wanted to ensure the properties were only UNSET properties,</span>
    <span class="c1">// here&#39;s where you&#39;d do it.</span>
    <span class="kt">var</span> <span class="n">properties</span> <span class="p">=</span> <span class="n">instanceType</span>
      <span class="p">.</span><span class="n">GetProperties</span><span class="p">(</span><span class="n">BindingFlags</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Instance</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">PropertyType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ILog</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">CanWrite</span> <span class="p">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">GetIndexParameters</span><span class="p">().</span><span class="n">Length</span> <span class="p">==</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">// Set the properties located.</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">propToSet</span> <span class="k">in</span> <span class="n">properties</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">propToSet</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">LogManager</span><span class="p">.</span><span class="n">GetLogger</span><span class="p">(</span><span class="n">instanceType</span><span class="p">),</span> <span class="k">null</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">OnComponentPreparing</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">PreparingEventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">Parameters</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Union</span><span class="p">(</span>
      <span class="k">new</span><span class="p">[]</span>
      <span class="p">{</span>
        <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ILog</span><span class="p">),</span>
            <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">LogManager</span><span class="p">.</span><span class="n">GetLogger</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Member</span><span class="p">.</span><span class="n">DeclaringType</span><span class="p">)</span>
        <span class="p">),</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">AttachToComponentRegistration</span><span class="p">(</span><span class="n">IComponentRegistryBuilder</span> <span class="n">componentRegistryBuilder</span><span class="p">,</span> <span class="n">IComponentRegistration</span> <span class="n">registration</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Handle constructor parameters.</span>
    <span class="n">registration</span><span class="p">.</span><span class="n">Preparing</span> <span class="p">+=</span> <span class="n">OnComponentPreparing</span><span class="p">;</span>

    <span class="c1">// Handle properties.</span>
    <span class="n">registration</span><span class="p">.</span><span class="n">Activated</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">InjectLoggerProperties</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Instance</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Performance Note</strong>: At the time of this writing, calling <code class="docutils literal notranslate"><span class="pre">LogManager.GetLogger(type)</span></code> has a slight performance hit as the internal log manager locks the collection of loggers to retrieve the appropriate logger. An enhancement to the module would be to add caching around logger instances so you can reuse them without the lock hit in the <code class="docutils literal notranslate"><span class="pre">LogManager</span></code> call.</p>
<p>Thanks for the original idea/contribution by Rich Tebb/Bailey Ling where the idea was posted <a class="reference external" href="https://groups.google.com/forum/#!msg/autofac/Qb-dVPMbna0/s-jLeWeST3AJ">on the Autofac newsgroup</a>.</p>
</div>
</div>
</div>
<span id="document-faq/index"></span><div class="section" id="frequently-asked-questions">
<h2>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-faq/per-request-scope"></span><div class="section" id="how-do-i-work-with-per-request-lifetime-scope">
<h3>How do I work with per-request lifetime scope?<a class="headerlink" href="#how-do-i-work-with-per-request-lifetime-scope" title="Permalink to this headline">¶</a></h3>
<p>In applications that have a request/response semantic (e.g., <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">ASP.NET MVC</span></a> or <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">Web API</span></a>), you can register dependencies to be “instance-per-request,” meaning you will get a one instance of the given dependency for each request handled by the application and that instance will be tied to the individual request lifecycle.</p>
<p>In order to understand per-request lifetime, you should have a good understanding of <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">how dependency lifetime scopes work in general</span></a>. Once you understand how dependency lifetime scopes work, per-request lifetime scope is easy.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#note-on-asp-net-core" id="id1">Note on ASP.NET Core</a></li>
<li><a class="reference internal" href="#registering-dependencies-as-per-request" id="id2">Registering Dependencies as Per-Request</a></li>
<li><a class="reference internal" href="#how-per-request-lifetime-works" id="id3">How Per-Request Lifetime Works</a></li>
<li><a class="reference internal" href="#sharing-dependencies-across-apps-without-requests" id="id4">Sharing Dependencies Across Apps Without Requests</a></li>
<li><a class="reference internal" href="#testing-with-per-request-dependencies" id="id5">Testing with Per-Request Dependencies</a><ul>
<li><a class="reference internal" href="#faking-an-mvc-request-scope" id="id6">Faking an MVC Request Scope</a></li>
<li><a class="reference internal" href="#faking-a-web-api-request-scope" id="id7">Faking a Web API Request Scope</a></li>
</ul>
</li>
<li><a class="reference internal" href="#troubleshooting-per-request-dependencies" id="id8">Troubleshooting Per-Request Dependencies</a><ul>
<li><a class="reference internal" href="#no-scope-with-a-tag-matching-autofacwebrequest" id="id9">No Scope with a Tag Matching ‘AutofacWebRequest’</a></li>
<li><a class="reference internal" href="#no-per-request-filter-dependencies-in-web-api" id="id10">No Per-Request Filter Dependencies in Web API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-custom-per-request-semantics" id="id11">Implementing Custom Per-Request Semantics</a></li>
</ul>
</div>
<div class="section" id="note-on-asp-net-core">
<h4><a class="toc-backref" href="#id1">Note on ASP.NET Core</a><a class="headerlink" href="#note-on-asp-net-core" title="Permalink to this headline">¶</a></h4>
<p>As noted in the <a class="reference internal" href="index.html#document-integration/aspnetcore"><span class="doc">ASP.NET Core integration docs</span></a>, <strong>ASP.NET Core doesn’t have a specific per-request scope.</strong> Everything is registered <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> for ASP.NET Core.</p>
</div>
<div class="section" id="registering-dependencies-as-per-request">
<h4><a class="toc-backref" href="#id2">Registering Dependencies as Per-Request</a><a class="headerlink" href="#registering-dependencies-as-per-request" title="Permalink to this headline">¶</a></h4>
<p>When you want a dependency registered as per-request, use the <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> registration extension:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>You’ll get a new instance of the component for every inbound request for your application. The handling of the creation of the request-level lifetime scope and the cleanup of that scope are generally dealt with via the <a class="reference internal" href="index.html#document-integration/index"><span class="doc">Autofac application integration libraries</span></a> for your application type.</p>
</div>
<div class="section" id="how-per-request-lifetime-works">
<h4><a class="toc-backref" href="#id3">How Per-Request Lifetime Works</a><a class="headerlink" href="#how-per-request-lifetime-works" title="Permalink to this headline">¶</a></h4>
<p>Per-request lifetime makes use of <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">tagged lifetime scopes and the “Instance Per Matching Lifetime Scope” mechanism</span></a>.</p>
<p><a class="reference internal" href="index.html#document-integration/index"><span class="doc">Autofac application integration libraries</span></a> hook into different application types and, on an inbound request, they create a nested lifetime scope with a “tag” that identifies it as a request lifetime scope:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------------------------+</span>
<span class="o">|</span>    <span class="n">Autofac</span> <span class="n">Container</span>     <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span>
<span class="o">|</span> <span class="o">+----------------------+</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span> <span class="n">Tagged</span> <span class="n">Request</span> <span class="n">Scope</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">+----------------------+</span> <span class="o">|</span>
<span class="o">+--------------------------+</span>
</pre></div>
</div>
<p>When you register a component as <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code>, you’re telling Autofac to look for a lifetime scope that is tagged as the request scope and to resolve the component from there. That way if you have unit-of-work lifetime scopes that take place during a single request, the per-request dependency will be shared during the request:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+----------------------------------------------------+</span>
<span class="o">|</span>                 <span class="n">Autofac</span> <span class="n">Container</span>                  <span class="o">|</span>
<span class="o">|</span>                                                    <span class="o">|</span>
<span class="o">|</span> <span class="o">+------------------------------------------------+</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span>              <span class="n">Tagged</span> <span class="n">Request</span> <span class="n">Scope</span>              <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span>                                                <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">+--------------------+</span>  <span class="o">+--------------------+</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="n">Unit</span> <span class="n">of</span> <span class="n">Work</span> <span class="n">Scope</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Unit</span> <span class="n">of</span> <span class="n">Work</span> <span class="n">Scope</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">+--------------------+</span>  <span class="o">+--------------------+</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">+------------------------------------------------+</span> <span class="o">|</span>
<span class="o">+----------------------------------------------------+</span>
</pre></div>
</div>
<p>The request scope is tagged with a constant value <code class="docutils literal notranslate"><span class="pre">Autofac.Core.Lifetime.MatchingScopeLifetimeTags.RequestLifetimeScopeTag</span></code>, which equates to the string <code class="docutils literal notranslate"><span class="pre">AutofacWebRequest</span></code>. If the request lifetime scope isn’t found, you’ll get a <code class="docutils literal notranslate"><span class="pre">DependencyResolutionException</span></code> that tells you the request lifetime scope isn’t found.</p>
<p>There are tips on troubleshooting this exception below in the <a class="reference internal" href="#troubleshooting"><span class="std std-ref">Troubleshooting Per-Request Dependencies</span></a> section.</p>
</div>
<div class="section" id="sharing-dependencies-across-apps-without-requests">
<span id="sharing-dependencies"></span><h4><a class="toc-backref" href="#id4">Sharing Dependencies Across Apps Without Requests</a><a class="headerlink" href="#sharing-dependencies-across-apps-without-requests" title="Permalink to this headline">¶</a></h4>
<p>A common situation you might see is that you have a single <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac module</span></a> that performs some dependency registrations and you want to share that module between two applications - one that has a notion of per-request lifetime (like a <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">Web API</span></a> application) and one that doesn’t (like a console app or Windows Service).</p>
<p><strong>How do you register dependencies as per-request and allow registration sharing?</strong></p>
<p>There are a couple of potential solutions to this problem.</p>
<p><strong>Option 1</strong>: Change your <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> registrations to be <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code>. <em>Most</em> applications don’t create their own nested unit-of-work lifetime scopes; instead, the only real child lifetime scope that gets created <em>is the request lifetime</em>. If this is the case for your application, then <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> and <code class="docutils literal notranslate"><span class="pre">InstancePerLifetimeScope()</span></code> become effectively identical. You will get the same behavior. In the application that doesn’t support per-request semantics, you can create child lifetime scopes as needed for component sharing.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// If your application does NOT create its own child</span>
<span class="c1">// lifetime scopes anywhere, then change this...</span>
<span class="c1">//</span>
<span class="c1">// builder.RegisterType&lt;ConsoleLogger&gt;()</span>
<span class="c1">//        .As&lt;ILogger&gt;()</span>
<span class="c1">//        .InstancePerRequest();</span>
<span class="c1">//</span>
<span class="c1">// ..to this:</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Option 2</strong>: Set up your registration module to take a parameter and indicate which lifetime scope registration type to use.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">LoggerModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kt">bool</span> <span class="n">_perRequest</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">LoggerModule</span><span class="p">(</span><span class="kt">bool</span> <span class="n">supportPerRequest</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_perRequest</span> <span class="p">=</span> <span class="n">supportPerRequest</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">reg</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ConsoleLogger</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;();</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_perRequest</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">reg</span><span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">reg</span><span class="p">.</span><span class="n">InstancePerLifetimeScope</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Register the module in each application and pass</span>
<span class="c1">// an appropriate parameter indicating if the app supports</span>
<span class="c1">// per-request or not, like this:</span>
<span class="c1">// builder.RegisterModule(new LoggerModule(true));</span>
</pre></div>
</div>
<p><strong>Option 3</strong>: A third, but more complex, option is to implement custom per-request semantics in the application that doesn’t naturally have these semantics. For example, a Windows Service doesn’t necessarily have per-request semantics, but if it’s self-hosting a custom service that takes requests and provides responses, you could add per-request lifetime scopes around each request and enable support of per-request dependencies. You can read more about this in the <a class="reference internal" href="#custom-semantics"><span class="std std-ref">Implementing Custom Per-Request Semantics</span></a> section.</p>
</div>
<div class="section" id="testing-with-per-request-dependencies">
<span id="testing"></span><h4><a class="toc-backref" href="#id5">Testing with Per-Request Dependencies</a><a class="headerlink" href="#testing-with-per-request-dependencies" title="Permalink to this headline">¶</a></h4>
<p>If you have an application that registers per-request dependencies, you may want to re-use the registration logic to set up dependencies in unit tests. Of course, you’ll find that your unit tests don’t have request lifetime scopes available, so you’ll end up with a <code class="docutils literal notranslate"><span class="pre">DependencyResolutionException</span></code> that indicates the <code class="docutils literal notranslate"><span class="pre">AutofacWebRequest</span></code> scope can’t be found. How do you use the registrations in a testing environment?</p>
<p><strong>Option 1</strong>: Create some custom registrations for each specific test fixture. Particularly if you’re in a unit test environment, you probably shouldn’t be wiring up the whole real runtime environment for the test - you should have test doubles for all the external required dependencies instead. Consider mocking out the dependencies and not actually doing the full shared set of registrations in the unit test environment.</p>
<p><strong>Option 2</strong>: Look at the choices for sharing registrations in the <a class="reference internal" href="#sharing-dependencies"><span class="std std-ref">Sharing Dependencies Across Apps Without Requests</span></a> section. Your unit test could be considered “an application that doesn’t support per-request registrations” so using a mechanism that allows sharing between application types might be appropriate.</p>
<p><strong>Option 3</strong>: Implement a fake “request” in the test. The intent here would be that before the test runs, a real Autofac lifetime scope with the <code class="docutils literal notranslate"><span class="pre">AutofacWebRequest</span></code> label is created, the test is run, and then the fake “request” scope is disposed - as though a full request was actually run. This is a little more complex and the method differs based on application type.</p>
<div class="section" id="faking-an-mvc-request-scope">
<h5><a class="toc-backref" href="#id6">Faking an MVC Request Scope</a><a class="headerlink" href="#faking-an-mvc-request-scope" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="index.html#document-integration/mvc"><span class="doc">Autofac ASP.NET MVC integration</span></a> uses an <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> implementation along with the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> to dynamically create a request scope as needed. To fake out the MVC request scope, you need to provide a test <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> that doesn’t involve the actual HTTP request. A simple version might look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SimpleLifetimeScopeProvider</span> <span class="p">:</span> <span class="n">ILifetimeScopeProvider</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IContainer</span> <span class="n">_container</span><span class="p">;</span>
  <span class="k">private</span> <span class="n">ILifetimeScope</span> <span class="n">_scope</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SimpleLifetimeScopeProvider</span><span class="p">(</span><span class="n">IContainer</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_container</span> <span class="p">=</span> <span class="n">container</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">ILifetimeScope</span> <span class="n">ApplicationContainer</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">_container</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">EndLifetimeScope</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_scope</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">_scope</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
      <span class="k">this</span><span class="p">.</span><span class="n">_scope</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">ILifetimeScope</span> <span class="nf">GetLifetimeScope</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">ContainerBuilder</span><span class="p">&gt;</span> <span class="n">configurationAction</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_scope</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">_scope</span> <span class="p">=</span> <span class="p">(</span><span class="n">configurationAction</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
             <span class="p">?</span> <span class="k">this</span><span class="p">.</span><span class="n">ApplicationContainer</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="n">MatchingScopeLifetimeTags</span><span class="p">.</span><span class="n">RequestLifetimeScopeTag</span><span class="p">)</span>
             <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="n">ApplicationContainer</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">(</span><span class="n">MatchingScopeLifetimeTags</span><span class="p">.</span><span class="n">RequestLifetimeScopeTag</span><span class="p">,</span> <span class="n">configurationAction</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">_scope</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When creating your <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> from your built application container, you’d manually specify your simple lifetime scope provider. Make sure you set up the resolver before your test runs, then after the test runs you need to clean up the fake request scope. In NUnit, it’d look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="n">IDependencyResolver</span> <span class="n">_originalResolver</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">private</span> <span class="n">ILifetimeScopeProvider</span> <span class="n">_scopeProvider</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

<span class="na">[TestFixtureSetUp]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">TestFixtureSetUp</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Build the container, then...</span>
  <span class="k">this</span><span class="p">.</span><span class="n">_scopeProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SimpleLifetimeScopeProvider</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
  <span class="kt">var</span> <span class="n">resolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">provider</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="n">_originalResolver</span> <span class="p">=</span> <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
  <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="n">resolver</span><span class="p">);</span>
<span class="p">}</span>

<span class="na">[TearDown]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">TearDown</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Clean up the fake &#39;request&#39; scope.</span>
  <span class="k">this</span><span class="p">.</span><span class="n">_scopeProvider</span><span class="p">.</span><span class="n">EndLifetimeScope</span><span class="p">();</span>
<span class="p">}</span>

<span class="na">[TestFixtureTearDown]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">TestFixtureTearDown</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// If you&#39;re mucking with statics, always put things</span>
  <span class="c1">// back the way you found them!</span>
  <span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_originalResolver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="faking-a-web-api-request-scope">
<h5><a class="toc-backref" href="#id7">Faking a Web API Request Scope</a><a class="headerlink" href="#faking-a-web-api-request-scope" title="Permalink to this headline">¶</a></h5>
<p>In Web API, the request lifetime scope is actually dragged around the system along with the inbound <code class="docutils literal notranslate"><span class="pre">HttpRequestMessage</span></code> as an <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code> object. To fake out a request scope, you just have to get the <code class="docutils literal notranslate"><span class="pre">ILifetimeScope</span></code> attached to the message you’re processing as part of your test.</p>
<p>During test setup, you should build the dependency resolver as you would in the application and associate that with an <code class="docutils literal notranslate"><span class="pre">HttpConfiguration</span></code> object. In each test, you’ll create the appropriate <code class="docutils literal notranslate"><span class="pre">HttpRequestMessage</span></code> to process based on the use case being tested, then use built-in Web API extension methods to attach the configuration to the message and get the request scope from the message.</p>
<p>In NUnit it’d look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="n">HttpConfiguration</span> <span class="n">_configuration</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

<span class="na">[TestFixtureSetUp]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">TestFixtureSetUp</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Build the container, then...</span>
  <span class="k">this</span><span class="p">.</span><span class="n">_configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpConfiguration</span>
  <span class="p">{</span>
    <span class="n">DependencyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacWebApiDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="na">[TestFixtureTearDown]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">TestFixtureTearDown</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Clean up - automatically handles</span>
  <span class="c1">// cleaning up the dependency resolver.</span>
  <span class="k">this</span><span class="p">.</span><span class="n">_configuration</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
<span class="p">}</span>

<span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Dispose of the HttpRequestMessage to dispose of the</span>
  <span class="c1">// request lifetime scope.</span>
  <span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="n">CreateTestHttpRequestMessage</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">message</span><span class="p">.</span><span class="n">SetConfiguration</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_configuration</span><span class="p">);</span>

    <span class="c1">// Now do your test. Use the extension method</span>
    <span class="c1">// message.GetDependencyScope()</span>
    <span class="c1">// to get the request lifetime scope from Web API.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="troubleshooting-per-request-dependencies">
<span id="troubleshooting"></span><h4><a class="toc-backref" href="#id8">Troubleshooting Per-Request Dependencies</a><a class="headerlink" href="#troubleshooting-per-request-dependencies" title="Permalink to this headline">¶</a></h4>
<p>There are a few gotchas when you’re working with per-request dependencies. Here’s some troubleshooting help.</p>
<div class="section" id="no-scope-with-a-tag-matching-autofacwebrequest">
<h5><a class="toc-backref" href="#id9">No Scope with a Tag Matching ‘AutofacWebRequest’</a><a class="headerlink" href="#no-scope-with-a-tag-matching-autofacwebrequest" title="Permalink to this headline">¶</a></h5>
<p>A very common exception people see when they start working with per-request lifetime scope is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DependencyResolutionException</span><span class="p">:</span> <span class="n">No</span> <span class="n">scope</span> <span class="k">with</span> <span class="n">a</span> <span class="n">Tag</span> <span class="n">matching</span>
<span class="s1">&#39;AutofacWebRequest&#39;</span> <span class="ow">is</span> <span class="n">visible</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">the</span> <span class="n">instance</span>
<span class="n">was</span> <span class="n">requested</span><span class="o">.</span> <span class="n">This</span> <span class="n">generally</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">a</span> <span class="n">component</span> <span class="n">registered</span>
<span class="k">as</span> <span class="n">per</span><span class="o">-</span><span class="n">HTTP</span> <span class="n">request</span> <span class="ow">is</span> <span class="n">being</span> <span class="n">requested</span> <span class="n">by</span> <span class="n">a</span> <span class="n">SingleInstance</span><span class="p">()</span>
<span class="n">component</span> <span class="p">(</span><span class="ow">or</span> <span class="n">a</span> <span class="n">similar</span> <span class="n">scenario</span><span class="o">.</span><span class="p">)</span> <span class="n">Under</span> <span class="n">the</span> <span class="n">web</span> <span class="n">integration</span> <span class="n">always</span>
<span class="n">request</span> <span class="n">dependencies</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">DependencyResolver</span><span class="o">.</span><span class="n">Current</span> <span class="ow">or</span>
<span class="n">ILifetimeScopeProvider</span><span class="o">.</span><span class="n">RequestLifetime</span><span class="p">,</span> <span class="n">never</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">container</span>
<span class="n">itself</span><span class="o">.</span>
</pre></div>
</div>
<p>What this means is that the application tried to resolve a dependency that is registered as <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code> but there wasn’t any request lifetime in place.</p>
<p>Common causes for this include:</p>
<blockquote>
<div><ul class="simple">
<li>Application registrations are being shared across application types.</li>
<li>A unit test is running with real application registrations but isn’t simulating per-request lifetimes.</li>
<li>You have a component that <em>lives longer than one request</em> but it takes a dependency that <em>only lives for one request</em>. For example, a singleton component that takes a service registered as per-request.</li>
<li>Code is running during application startup (e.g., in an ASP.NET <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code>) that uses dependency resolution when there isn’t an active request yet.</li>
<li>Code is running in a “background thread” (where there’s no request semantics) but is trying to call the ASP.NET MVC <code class="docutils literal notranslate"><span class="pre">DependencyResolver</span></code> to do service location.</li>
</ul>
</div></blockquote>
<p>Tracking down the source of the issue can be troublesome. In many cases, you might look at what is being resolved and see that the component being resolved is <em>not registered as per-request</em> and the dependencies that component uses are also <em>not registered as per-request</em>. In cases like this, you may need to go all the way down the dependency chain. The exception could be coming from something deep in the dependency chain. Usually a close examination of the call stack can help you. In cases where you are doing <a class="reference internal" href="index.html#document-register/scanning"><span class="doc">dynamic assembly scanning</span></a> to locate <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">modules</span></a> to register, the source of the troublesome registration may not be immediately obvious.</p>
<p>As you analyze the registrations in the problem dependency chain, look at the lifetime scopes for which they’re registered. If you have a component registered as <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> but it (maybe indirectly) consumes a component registered as <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code>, that’s a problem. The <code class="docutils literal notranslate"><span class="pre">SingleInstance()</span></code> component will grab its dependencies when it’s resolved the first time and never let go. If that happens at app startup or in a background thread where there’s no current request, you’ll see this exception. You may need to adjust some component lifetime scopes. Again, it’s really good to know <a class="reference internal" href="index.html#document-lifetime/instance-scope"><span class="doc">how dependency lifetime scopes work in general</span></a>.</p>
<p>Anyway, somewhere along the line, <em>something</em> is looking for a per-request lifetime scope and it’s not being found.</p>
<p>If you are trying to share registrations across application types, check out the <a class="reference internal" href="#sharing-dependencies"><span class="std std-ref">Sharing Dependencies Across Apps Without Requests</span></a> section.</p>
<p>If you are trying to unit test with per-request dependencies, the sections <a class="reference internal" href="#testing"><span class="std std-ref">Testing with Per-Request Dependencies</span></a> and <a class="reference internal" href="#sharing-dependencies"><span class="std std-ref">Sharing Dependencies Across Apps Without Requests</span></a> can give you some tips.</p>
<p>If you have application startup code or a background thread in an ASP.NET MVC app trying to use <code class="docutils literal notranslate"><span class="pre">DependencyResolver.Current</span></code> - the <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver</span></code> requires a web context to resolve things. When you try to resolve something from the resolver, it’s going to try to spin up a per-request lifetime scope and store it along with the current <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code>. If there isn’t a current context, things will fail. Accessing <code class="docutils literal notranslate"><span class="pre">AutofacDependencyResolver.Current</span></code> will not get you around that - the way the current resolver property works, it locates itself from the current web request scope. (It does this to allow working with applications like Glimpse and other instrumentation mechanisms.)</p>
<p>For application startup code or background threads, you may need to look at a different service locator mechanism like <a class="reference internal" href="index.html#document-integration/csl"><span class="doc">Common Service Locator</span></a> to bypass the need for per-request scope. If you do that, you’ll also need to check out the <a class="reference internal" href="#sharing-dependencies"><span class="std std-ref">Sharing Dependencies Across Apps Without Requests</span></a> section to update your component registrations so they also don’t necessarily require a per-request scope.</p>
</div>
<div class="section" id="no-per-request-filter-dependencies-in-web-api">
<h5><a class="toc-backref" href="#id10">No Per-Request Filter Dependencies in Web API</a><a class="headerlink" href="#no-per-request-filter-dependencies-in-web-api" title="Permalink to this headline">¶</a></h5>
<p>If you are using the <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">Web API integration</span></a> and <code class="docutils literal notranslate"><span class="pre">AutofacWebApiFilterProvider</span></code> to do dependency injection into your action filters, you may notice that <strong>dependencies in filters are resolved one time only and not on a per-request basis</strong>.</p>
<p>This is a shortcoming in Web API. The Web API internals create filter instances and then cache them, never to be created again. This removes any “hooks” that might otherwise have existed to do anything on a per-request basis in a filter.</p>
<p>If you need to do something per-request in a filter, you will need to use service location and manually get the request lifetime scope from the context in your filter. For example, an <code class="docutils literal notranslate"><span class="pre">ActionFilterAttribute</span></code> might look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">LoggingFilterAttribute</span> <span class="p">:</span> <span class="n">ActionFilterAttribute</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnActionExecuting</span><span class="p">(</span><span class="n">HttpActionContext</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">logger</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">GetDependencyScope</span><span class="p">().</span><span class="n">GetService</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ILogger</span><span class="p">))</span> <span class="k">as</span> <span class="n">ILogger</span><span class="p">;</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&quot;Executing action.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using this service location mechanism, you wouldn’t even need the <code class="docutils literal notranslate"><span class="pre">AutofacWebApiFilterProvider</span></code> - you can do this even without using Autofac at all.</p>
</div>
</div>
<div class="section" id="implementing-custom-per-request-semantics">
<span id="custom-semantics"></span><h4><a class="toc-backref" href="#id11">Implementing Custom Per-Request Semantics</a><a class="headerlink" href="#implementing-custom-per-request-semantics" title="Permalink to this headline">¶</a></h4>
<p>You may have a custom application that handles requests - like a Windows Service application that takes requests, performs some work, and provides some output. In cases like that, you can implement a custom mechanism that provides the ability to register and resolve dependencies on a per-request basis if you structure your application properly. The steps you would take are identical to the steps seen in other application types that naturally support per-request semantics.</p>
<blockquote>
<div><ul class="simple">
<li><strong>Build the container at application start.</strong> Make your registrations, build the container, and store a reference to the global container for later use.</li>
<li><strong>When a logical request is received, create a request lifetime scope.</strong> The request lifetime scope should be tagged with the tag <code class="docutils literal notranslate"><span class="pre">Autofac.Core.Lifetime.MatchingScopeLifetimeTags.RequestLifetimeScopeTag</span></code> so you can use standard registration extension methods like <code class="docutils literal notranslate"><span class="pre">InstancePerRequest()</span></code>. This will also enable you to share registration modules across application types if you so desire.</li>
<li><strong>Associate request lifetime scope with the request.</strong> This means you need the ability to get the request scope from within the request and not have a single, static, global variable with the “request scope” - that’s a threading problem. You either need a construct like <code class="docutils literal notranslate"><span class="pre">HttpContext.Current</span></code> (as in ASP.NET) or <code class="docutils literal notranslate"><span class="pre">OperationContext.Current</span></code> (as in WCF); or you need to store the request lifetime along with the actual incoming request information (like Web API).</li>
<li><strong>Dispose of the request lifetime after the request is done.</strong> After the request has been processed and the response is sent, you need to call <code class="docutils literal notranslate"><span class="pre">IDisposable.Dispose()</span></code> on the request lifetime scope to ensure memory is cleaned up and service instances are released.</li>
<li><strong>Dispose of the container at application end.</strong> When the application is shutting down, call <code class="docutils literal notranslate"><span class="pre">IDisposable.Dispose()</span></code> on the global application container to ensure any managed resources are properly disposed and connections to databases, etc. are shut down.</li>
</ul>
</div></blockquote>
<p>How exactly you do this depends on your application, so an “example” can’t really be provided. A good way to see the pattern is to look at the source for <a class="reference internal" href="index.html#document-integration/index"><span class="doc">the integration libraries</span></a> for various app types like MVC and Web API to see how those are done. You can then adopt patterns and adapt accordingly to fit your application’s needs.</p>
<p><strong>This is a very advanced process.</strong> You can pretty easily introduce memory leaks by not properly disposing of things or create threading problems by not correctly associating request lifetimes with requests. Be careful if you go down this road and do a lot of testing and profiling to make sure things work as you expect.</p>
</div>
</div>
<span id="document-faq/select-by-context"></span><div class="section" id="how-do-i-pick-a-service-implementation-by-context">
<h3>How do I pick a service implementation by context?<a class="headerlink" href="#how-do-i-pick-a-service-implementation-by-context" title="Permalink to this headline">¶</a></h3>
<p>There are times when you may want to register multiple <a class="reference internal" href="index.html#document-glossary"><span class="doc">components</span></a> that all expose the same <a class="reference internal" href="index.html#document-glossary"><span class="doc">service</span></a> but you want to pick which component is used in different instances.</p>
<p>For this question, let’s imagine a simple order processing system. In this system, we have…</p>
<ul class="simple">
<li>A shipping processor that orchestrates the physical mailing of the order contents.</li>
<li>A notification processor that sends an alert to a user when their order status changes.</li>
</ul>
<p>In this simple system, the shipping processor might need to take different “plugins” to allow order delivery by different means - postal service, UPS, FedEx, and so on. The notification processor might also need different “plugins” to allow notifications by different means, like email or SMS text.</p>
<p>Your initial class design might look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This interface lets you send some content</span>
<span class="c1">// to a specified destination.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">ISender</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="n">Destination</span> <span class="n">dest</span><span class="p">,</span> <span class="n">Content</span> <span class="n">content</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We can implement the interface for different</span>
<span class="c1">// &quot;sending strategies&quot;:</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PostalServiceSender</span> <span class="p">:</span> <span class="n">ISender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">EmailNotifier</span> <span class="p">:</span> <span class="n">ISender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// The shipping processor sends the physical order</span>
<span class="c1">// to a customer given a shipping strategy (postal service,</span>
<span class="c1">// UPS, FedEx, etc.).</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ShippingProcessor</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ShippingProcessor</span><span class="p">(</span><span class="n">ISender</span> <span class="n">shippingStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// The customer notifier sends the customer an alert when their</span>
<span class="c1">// order status changes using the channel specified by the notification</span>
<span class="c1">// strategy (email, SMS, etc.).</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerNotifier</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">CustomerNotifier</span><span class="p">(</span><span class="n">ISender</span> <span class="n">notificationStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you register things in Autofac, you might have registrations that look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<div class="contents local topic" id="how-do-you-make-sure-the-shipping-processor-gets-the-postal-service-strategy-and-the-customer-notifier-gets-the-email-strategy">
<p class="topic-title"><strong>How do you make sure the shipping processor gets the postal service strategy and the customer notifier gets the email strategy?</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#option-1-redesign-your-interfaces" id="id1">Option 1: Redesign Your Interfaces</a></li>
<li><a class="reference internal" href="#option-2-change-the-registrations" id="id2">Option 2: Change the Registrations</a></li>
<li><a class="reference internal" href="#option-3-use-keyed-services" id="id3">Option 3: Use Keyed Services</a></li>
<li><a class="reference internal" href="#option-4-use-metadata" id="id4">Option 4: Use Metadata</a></li>
</ul>
</div>
<div class="section" id="option-1-redesign-your-interfaces">
<h4><a class="toc-backref" href="#id1">Option 1: Redesign Your Interfaces</a><a class="headerlink" href="#option-1-redesign-your-interfaces" title="Permalink to this headline">¶</a></h4>
<p>When you run into a situation where you have a bunch of components that implement identical services but <em>they can’t be treated identically</em>, <strong>this is generally an interface design problem</strong>.</p>
<p>From an object oriented development perspective, you’d want your objects to adhere to the <a class="reference external" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> and this sort of breaks that.</p>
<p>Think about it from another angle: the standard “animal” example in object orientation. Say you have some animal objects and you are creating a special class that represents a bird cage that can hold small birds:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">abstract</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">();</span>
  <span class="k">public</span> <span class="k">abstract</span> <span class="n">AnimalSize</span> <span class="n">Size</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">enum</span> <span class="n">AnimalSize</span>
<span class="p">{</span>
  <span class="n">Small</span><span class="p">,</span> <span class="n">Medium</span><span class="p">,</span> <span class="n">Large</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HouseCat</span> <span class="p">:</span> <span class="n">Animal</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Meow!&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">AnimalSize</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Small</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Bird</span> <span class="p">:</span> <span class="n">Animal</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Chirp!&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Parakeet</span> <span class="p">:</span> <span class="n">Bird</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">AnimalSize</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Small</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">BaldEagle</span> <span class="p">:</span> <span class="n">Bird</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Screech!&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">AnimalSize</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Large</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>OK, there are our animals. Obviously we can’t treat them all equally, so if we made a bird cage class, we <em>probably wouldn’t do it like this</em>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BirdCage</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">BirdCage</span><span class="p">(</span><span class="n">Animal</span> <span class="n">animal</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(!(</span><span class="n">animal</span> <span class="k">is</span> <span class="n">Bird</span><span class="p">)</span> <span class="p">||</span> <span class="n">animal</span><span class="p">.</span><span class="n">Size</span> <span class="p">!=</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Small</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// We only support small birds.</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Designing your bird cage to take just any animal doesn’t make sense.</strong> You’d at least want to make it take <em>only birds</em>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BirdCage</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">BirdCage</span><span class="p">(</span><span class="n">Bird</span> <span class="n">bird</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bird</span><span class="p">.</span><span class="n">Size</span> <span class="p">!=</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Small</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// We know it&#39;s a bird, but it needs to be a small bird.</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>But if we change the class design just a little bit</strong>, we can make it even easier and force only the right kind of birds to even be allowed to be used:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We still keep the base Bird class...</span>
<span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Bird</span> <span class="p">:</span> <span class="n">Animal</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Chirp!&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// But we also add a &quot;PetBird&quot; class - for birds that</span>
<span class="c1">// are small and kept as pets.</span>
<span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PetBird</span> <span class="p">:</span> <span class="n">Bird</span>
<span class="p">{</span>
  <span class="c1">// We &quot;seal&quot; the override to ensure all pet birds are small.</span>
  <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">AnimalSize</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Small</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A parakeet is a pet bird, so we change the base class.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Parakeet</span> <span class="p">:</span> <span class="n">PetBird</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Bald eagles aren&#39;t generally pets, so we don&#39;t change the base class.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">BaldEagle</span> <span class="p">:</span> <span class="n">Bird</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">MakeNoise</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Screech!&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">AnimalSize</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">AnimalSize</span><span class="p">.</span><span class="n">Large</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Now it’s easy to design our bird cage to only support small pet birds.</strong> We just use the correct base class in the constructor:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BirdCage</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">BirdCage</span><span class="p">(</span><span class="n">PetBird</span> <span class="n">bird</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Obviously this is a fairly contrived example with flaws if you dive too far into the analogy, but the principle holds - redesigning the interfaces helps us ensure the bird cage only gets what it expects and nothing else.</p>
<p>Bringing this back to the ordering system, <em>it might seem like every delivery mechanism is just “sending something”</em> but the truth is, they send <em>very different types of things</em>. Maybe there’s a base interface that is for general “sending of things,” but you probably need an intermediate level to differentiate between the types of things being sent:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We can keep the ISender interface if we want...</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">ISender</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="n">Destination</span> <span class="n">dest</span><span class="p">,</span> <span class="n">Content</span> <span class="n">content</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// But we&#39;ll introduce intermediate interfaces, even</span>
<span class="c1">// if they&#39;re just &quot;markers,&quot; so we can differentiate between</span>
<span class="c1">// the sort of sending the strategies can perform.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IOrderSender</span> <span class="p">:</span> <span class="n">ISender</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">INotificationSender</span> <span class="p">:</span> <span class="n">ISender</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// We change the strategies so they implement the appropriate</span>
<span class="c1">// interfaces based on what they are allowed to send.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PostalServiceSender</span> <span class="p">:</span> <span class="n">IOrderSender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">EmailNotifier</span> <span class="p">:</span> <span class="n">INotificationSender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// Finally, we update the classes consuming the sending</span>
<span class="c1">// strategies so they only allow the right kind of strategy</span>
<span class="c1">// to be used.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ShippingProcessor</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ShippingProcessor</span><span class="p">(</span><span class="n">IOrderSender</span> <span class="n">shippingStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerNotifier</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">CustomerNotifier</span><span class="p">(</span><span class="n">INotificationSender</span> <span class="n">notificationStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>By doing some interface redesign, you don’t have to “choose a dependency by context”</strong> - you use the types to differentiate and let auto-wireup magic happen during <a class="reference internal" href="index.html#document-resolve/index"><span class="doc">resolution</span></a>.</p>
<p><strong>If you have the ability to affect change on your solution, this is the recommended option.</strong></p>
</div>
<div class="section" id="option-2-change-the-registrations">
<h4><a class="toc-backref" href="#id2">Option 2: Change the Registrations</a><a class="headerlink" href="#option-2-change-the-registrations" title="Permalink to this headline">¶</a></h4>
<p>One of the things Autofac lets you do when you <a class="reference internal" href="index.html#document-register/index"><span class="doc">register components</span></a> is to register lambda expressions rather than just types. You can manually associate the appropriate type with the consuming component in that way:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ShippingProcessor</span><span class="p">(</span><span class="k">new</span> <span class="n">PostalServiceSender</span><span class="p">()));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CustomerNotifier</span><span class="p">(</span><span class="k">new</span> <span class="n">EmailNotifier</span><span class="p">()));</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>If you want to keep the senders being resolved from Autofac, you can expose them both as their interface types and as themselves, then resolve them in the lambda:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Add the &quot;AsSelf&quot; clause to expose these components</span>
<span class="c1">// both as the ISender interface and as their natural type.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">();</span>

<span class="c1">// Lambda registrations resolve based on the specific type, not the</span>
<span class="c1">// ISender interface.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ShippingProcessor</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">CustomerNotifier</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()));</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>If using the lambda mechanism feels too “manual” or if the processor objects take lots of parameters, you can <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">manually attach parameters to the registrations</span></a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// Keep the &quot;AsSelf&quot; clause.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">AsSelf</span><span class="p">();</span>

<span class="c1">// Attach resolved parameters to override Autofac&#39;s</span>
<span class="c1">// lookup just on the ISender parameters.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
         <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()));</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;();</span>
       <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
         <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
           <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()));</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>Using the parameter method, you still get the “auto-wireup” benefit when creating both the senders and the processors, but you can specify a very specific override in those cases.</p>
<p><strong>If you can’t change your interfaces and you want to keep things simple, this is the recommended option.</strong></p>
</div>
<div class="section" id="option-3-use-keyed-services">
<h4><a class="toc-backref" href="#id3">Option 3: Use Keyed Services</a><a class="headerlink" href="#option-3-use-keyed-services" title="Permalink to this headline">¶</a></h4>
<p>Perhaps you are able to change your registrations but you are also using <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">modules</span></a> to register lots of different components and can’t really tie things together by type. A simple way to get around this is to use <a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">keyed services</span></a>.</p>
<p>In this case, Autofac lets you assign a “key” or “name” to a service registration and resolve based on that key from another registration. In the module where you register your senders, you would associate the appropriate key with each sender; in the module where you register you processors, you’d apply parameters to the registrations to get the appropriate keyed service dependency.</p>
<p>In the module that registers your senders, add key names:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SenderModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;(</span><span class="s">&quot;order&quot;</span><span class="p">);</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">Keyed</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;(</span><span class="s">&quot;notification&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the module that registers the processors, add parameters that use the known keys:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ProcessorModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">ResolveKeyed</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;(</span><span class="s">&quot;order&quot;</span><span class="p">)));</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;();</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">ResolveKeyed</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;(</span><span class="s">&quot;notification&quot;</span><span class="p">)));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now when the processors are resolved, they’ll search for the keyed service registrations and you’ll get the right one injected.</p>
<p><em>You can have more than one service with the same key</em> so this will work if you have a situation where your sender takes in an <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;ISender&gt;</span></code> as well via <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicitly supported relationships</span></a>. Just set the parameter to <code class="docutils literal notranslate"><span class="pre">ctx.ResolveKeyed&lt;IEnumerable&lt;ISender&gt;&gt;(&quot;order&quot;)</span></code> with the appropriate key in the processor registration; and register each sender with the appropriate key.</p>
<p><strong>If you have the ability to change the registrations and you’re not locked into doing assembly scanning for all your registrations, this is the recommended option.</strong></p>
</div>
<div class="section" id="option-4-use-metadata">
<h4><a class="toc-backref" href="#id4">Option 4: Use Metadata</a><a class="headerlink" href="#option-4-use-metadata" title="Permalink to this headline">¶</a></h4>
<p>If you need something more flexible than <a class="reference internal" href="index.html#document-advanced/keyed-services"><span class="doc">keyed services</span></a> or if you don’t have the ability to directly affect registrations, you may want to consider using the <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">registration metadata</span></a> facility to tie the right services together.</p>
<p>You can associate metadata with registrations directly:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SenderModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">,</span> <span class="s">&quot;order&quot;</span><span class="p">);</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">,</span> <span class="s">&quot;notification&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can then make use of the metadata as parameters on consumer registrations:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ProcessorModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;&gt;&gt;()</span>
                               <span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;order&quot;</span><span class="p">))));</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;();</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;&gt;&gt;()</span>
                               <span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;notification&quot;</span><span class="p">))));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Yes, this is <em>just slightly</em> more complex than using keyed services, but you may desire the <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">flexibility the metadata facility offers</span></a>.)</p>
<p><strong>If you can’t change the registrations of the sender components, but you’re allowed to change the object definitions</strong>, you can add metadata to components using the “attribute metadata” mechanism. First you’d create your custom metadata attribute:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[System.ComponentModel.Composition.MetadataAttribute]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SendAllowedAttribute</span> <span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">SendAllowed</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">SendAllowedAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">sendAllowed</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">SendAllowed</span> <span class="p">=</span> <span class="n">sendAllowed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then you can apply your custom metadata attribute to the sender components:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[SendAllowed(&quot;order&quot;)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PostalServiceSender</span> <span class="p">:</span> <span class="n">IOrderSender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="na">[SendAllowed(&quot;notification&quot;)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">EmailNotifier</span> <span class="p">:</span> <span class="n">INotificationSender</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>When you register your senders, make sure to register the <code class="docutils literal notranslate"><span class="pre">AttributedMetadataModule</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SenderModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">PostalServiceSender</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailNotifier</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterModule</span><span class="p">&lt;</span><span class="n">AttributedMetadataModule</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The consuming components can then use the metadata just like normal - the names of the attribute properties become the names in the metadata:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ProcessorModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;&gt;&gt;()</span>
                               <span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;order&quot;</span><span class="p">))));</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;()</span>
           <span class="p">.</span><span class="n">WithParameter</span><span class="p">(</span>
             <span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ISender</span><span class="p">),</span>
               <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Meta</span><span class="p">&lt;</span><span class="n">ISender</span><span class="p">&gt;&gt;&gt;()</span>
                               <span class="p">.</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Metadata</span><span class="p">[</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;notification&quot;</span><span class="p">))));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For your consuming components, you can also use attributed metadata if you don’t mind adding a custom Autofac attribute to your parameter definition:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ShippingProcessor</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">ShippingProcessor</span><span class="p">([</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">,</span> <span class="s">&quot;order&quot;</span><span class="p">)]</span> <span class="n">ISender</span> <span class="n">shippingStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerNotifier</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">CustomerNotifier</span><span class="p">([</span><span class="n">WithMetadata</span><span class="p">(</span><span class="s">&quot;SendAllowed&quot;</span><span class="p">,</span> <span class="s">&quot;notification&quot;</span><span class="p">)]</span> <span class="n">ISender</span> <span class="n">notificationStrategy</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If your consuming components use the attribute, you need to register them <code class="docutils literal notranslate"><span class="pre">WithAttributeFilter</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ProcessorModule</span> <span class="p">:</span> <span class="n">Module</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ShippingProcessor</span><span class="p">&gt;().</span><span class="n">WithAttributeFilter</span><span class="p">();</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">CustomerNotifier</span><span class="p">&gt;().</span><span class="n">WithAttributeFilter</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Again, the metadata mechanism is very flexible. You can mix and match the way you associate metadata with components and service consumers - attributes, parameters, and so on. You can read more about <a class="reference internal" href="index.html#document-advanced/metadata"><span class="doc">registration metadata</span></a>, <a class="reference internal" href="index.html#document-register/parameters"><span class="doc">registration parameters</span></a>, <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">resolution parameters</span></a>, and <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicitly supported relationships</span></a> (like the <code class="docutils literal notranslate"><span class="pre">Meta&lt;T&gt;</span></code> relationship) on their respective pages.</p>
<p><strong>If you are already using metadata or need the flexibility metadata offers, this is the recommended option.</strong></p>
</div>
</div>
<span id="document-faq/instance-per-session"></span><div class="section" id="how-do-i-create-a-session-based-lifetime-scope-in-a-web-application">
<h3>How do I create a session-based lifetime scope in a web application?<a class="headerlink" href="#how-do-i-create-a-session-based-lifetime-scope-in-a-web-application" title="Permalink to this headline">¶</a></h3>
<p>In ASP.NET the notion of “instance per request” is inherently supported, but you may have a desire to create an “instance per session” for some objects.</p>
<p><strong>This road is frought with peril and is totally unsupported.</strong> It’s a question asked often enough that we’ve provided some information about the possible way to get it to work <a class="reference external" href="https://stackoverflow.com/questions/11721919/managing-autofac-lifetime-scopes-per-session-and-request-in-asp-net-mvc-3/11726210#11726210">based on this StackOverflow answer</a> but if it’s not working for you or you need additional support to get it to happen, <strong>you’re on your own</strong>.</p>
<p>Also, <strong>this information is for ASP.NET MVC classic, not ASP.NET Core</strong> but the same challenges will apply. Most likely this will not be updated for ASP.NET Core. It will probably also not be updated for Web API, web forms, or any other integration. You will need to take the ideas here and adapt them as needed.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#why-this-is-a-bad-idea" id="id1">Why This is a Bad Idea</a><ul>
<li><a class="reference internal" href="#memory-footprint" id="id2">Memory Footprint</a></li>
<li><a class="reference internal" href="#not-farm-friendly" id="id3">Not Farm Friendly</a></li>
<li><a class="reference internal" href="#session-not-consistently-used" id="id4">Session Not Consistently Used</a></li>
<li><a class="reference internal" href="#unreliable-disposal" id="id5">Unreliable Disposal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-do-it" id="id6">How to Do It</a></li>
</ul>
</div>
<div class="section" id="why-this-is-a-bad-idea">
<h4><a class="toc-backref" href="#id1">Why This is a Bad Idea</a><a class="headerlink" href="#why-this-is-a-bad-idea" title="Permalink to this headline">¶</a></h4>
<p>Before you even begin, here are the challenges you’ll run into with a session-scoped lifetime:</p>
<div class="section" id="memory-footprint">
<h5><a class="toc-backref" href="#id2">Memory Footprint</a><a class="headerlink" href="#memory-footprint" title="Permalink to this headline">¶</a></h5>
<p>You’re going to end up with a lifetime scope for every user on your system. While a request lifetime pops up and goes away pretty quickly, these session-level scopes will live potentially a long time. If you have a lot of session-scoped items, you’re going to have a pretty good sized memory usage for each user. If people “abandon” their sessions without properly logging out, that’s all the longer these things will live.</p>
</div>
<div class="section" id="not-farm-friendly">
<h5><a class="toc-backref" href="#id3">Not Farm Friendly</a><a class="headerlink" href="#not-farm-friendly" title="Permalink to this headline">¶</a></h5>
<p>Lifetime scopes and their contents aren’t serializable. <a class="reference external" href="https://github.com/autofac/Autofac/blob/develop/src/Autofac/Core/Lifetime/LifetimeScope.cs">Looking at the code</a> for <code class="docutils literal notranslate"><span class="pre">LifetimeScope</span></code>, it’s not marked <code class="docutils literal notranslate"><span class="pre">[Serializable]</span></code>… and even if it was, the resolved objects living in there are not necessarily all marked serializable. This is important because it means your session-level lifetime scope might work on a single box with in-memory session, but <strong>if you deploy to a farm with SQL session or a session service, things will fall apart</strong> because the session can’t serialize your stored scope.</p>
<p>If you choose not to serialize the scope, then you have a different scope for each user across machines - also a potential problem.</p>
</div>
<div class="section" id="session-not-consistently-used">
<h5><a class="toc-backref" href="#id4">Session Not Consistently Used</a><a class="headerlink" href="#session-not-consistently-used" title="Permalink to this headline">¶</a></h5>
<p>Session isn’t always rehydrated. If the handler being accessed (e.g., the web form) doesn’t implement <code class="docutils literal notranslate"><span class="pre">IRequiresSessionState</span></code>, the session won’t be rehydrated (whether it’s in-proc or not). Web forms and the <code class="docutils literal notranslate"><span class="pre">MvcHandler</span></code> implement that by default so you won’t see any issues, but if you have custom handlers that require injection you’ll hit some snags since “Session” won’t exist for those requests. You’ll also have trouble for handlers that have explicitly marked themselves as not needing session (e.g., for performance purposes).</p>
</div>
<div class="section" id="unreliable-disposal">
<h5><a class="toc-backref" href="#id5">Unreliable Disposal</a><a class="headerlink" href="#unreliable-disposal" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">Session_End</span></code> doesn’t always fire. <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.sessionstate.sessionstatemodule.end.aspx">Per the docs on SessionStateModule.End</a>, if you use out-of-proc session state you won’t actually get the <code class="docutils literal notranslate"><span class="pre">Session_End</span></code> event, so you won’t be able to clean up.</p>
</div>
</div>
<div class="section" id="how-to-do-it">
<h4><a class="toc-backref" href="#id6">How to Do It</a><a class="headerlink" href="#how-to-do-it" title="Permalink to this headline">¶</a></h4>
<p>Let’s say you’ve still read through all that and you want this.</p>
<p>At least in ASP.NET MVC classic, <strong>what you’ll do is implement your own Autofac.Integration.Mvc.ILifetimeScopeProvider</strong>. This interface is what governs how/where request lifetime scopes get generated.</p>
<p><strong>Exactly how to implement it will be up to you.</strong> This is because of all of the challenges above. For example, where will you hold the session-based lifetime scope? Is it attached to the actual session (which is a problem due to serialization)? Is it in a static dictionary somewhere? Is there some other place you want to hold those references? These aren’t questions that can be answered here - this is all largely “an exercise for the reader.”</p>
<p>The default <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> implementation, <code class="docutils literal notranslate"><span class="pre">Autofac.Integration.Mvc.RequestLifetimeScopeProvider</span></code>, handles creation, disposal, and maintenance of lifetime scopes on a per-request basis. You can browse the code for <code class="docutils literal notranslate"><span class="pre">RequestLifetimeScopeProvider</span></code> <a class="reference external" href="https://github.com/autofac/Autofac.Mvc/blob/develop/src/Autofac.Integration.Mvc/RequestLifetimeScopeProvider.cs">here</a>, which you should do if you plan on undertaking this. It’s the best sample of working code showing the responsibility of one of these providers.</p>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> will be where you…</p>
<blockquote>
<div><ul class="simple">
<li>Locate (or create) the session lifetime scope for the user</li>
<li>Create the request lifetime scope as a child of the session lifetime scope</li>
<li>Dispose of the request lifetime scope at the end of the request</li>
</ul>
</div></blockquote>
<p>This may be also where you want to dispose of the session lifetime scope from a design perspective, but it could be tricky since the provider doesn’t automatically get the session end event.</p>
<p>Once you have your <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> you’ll use it when you set up your dependency resolver.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">scopeProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyCustomLifetimeScopeProvider</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">configAction</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">resolver</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutofacDependencyResolver</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">scopeProvider</span><span class="p">);</span>
<span class="n">DependencyResolver</span><span class="p">.</span><span class="n">SetResolver</span><span class="p">(</span><span class="n">resolver</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>You will also need to hook into the Session_End event</strong> (e.g., in your <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code> or <code class="docutils literal notranslate"><span class="pre">MvcApplication</span></code> class) to dispose of the session scope. Again, how you do that exactly is up to you since the <code class="docutils literal notranslate"><span class="pre">ILifetimeScopeProvider</span></code> doesn’t receive any session-related events.</p>
</div>
</div>
<span id="document-faq/iis-restart"></span><div class="section" id="why-aren-t-my-assemblies-getting-scanned-after-iis-restart">
<h3>Why aren’t my assemblies getting scanned after IIS restart?<a class="headerlink" href="#why-aren-t-my-assemblies-getting-scanned-after-iis-restart" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to use the <a class="reference internal" href="index.html#document-register/scanning"><span class="doc">assembly scanning</span></a> mechanism to load up plugins in IIS hosted applications.</p>
<p>When hosting applications in IIS all assemblies are loaded into the <code class="docutils literal notranslate"><span class="pre">AppDomain</span></code> when the application first starts, but <strong>when the AppDomain is recycled by IIS the assemblies are then only loaded on demand.</strong></p>
<p>To avoid this issue use the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.compilation.buildmanager.getreferencedassemblies.aspx">GetReferencedAssemblies()</a> method on <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.web.compilation.buildmanager.aspx">System.Web.Compilation.BuildManager</a> to get a list of the referenced assemblies instead:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">assemblies</span> <span class="p">=</span> <span class="n">BuildManager</span><span class="p">.</span><span class="n">GetReferencedAssemblies</span><span class="p">().</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Assembly</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>That will force the referenced assemblies to be loaded into the <code class="docutils literal notranslate"><span class="pre">AppDomain</span></code> immediately making them available for module scanning.</p>
<p>Alternatively, rather than using <code class="docutils literal notranslate"><span class="pre">AppDomain.CurrentDomain.GetAssemblies()</span></code> for scanning, <strong>manually load the assemblies</strong> from the filesystem. Doing a manual load forces them into the <code class="docutils literal notranslate"><span class="pre">AppDomain</span></code> so you can start scanning.</p>
</div>
<span id="document-faq/conditional-registration"></span><div class="section" id="how-do-i-conditionally-register-components">
<h3>How do I conditionally register components?<a class="headerlink" href="#how-do-i-conditionally-register-components" title="Permalink to this headline">¶</a></h3>
<p>There are times when you want to pick what gets registered in the container at runtime, maybe based on an environment variable or application parameter. Here are some options…</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#use-configuration" id="id1">Use Configuration</a></li>
<li><a class="reference internal" href="#use-modules" id="id2">Use Modules</a></li>
<li><a class="reference internal" href="#lambda-registrations" id="id3">Lambda Registrations</a></li>
</ul>
</div>
<div class="section" id="use-configuration">
<h4><a class="toc-backref" href="#id1">Use Configuration</a><a class="headerlink" href="#use-configuration" title="Permalink to this headline">¶</a></h4>
<p>Autofac provides <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">a configuration mechanism</span></a> that allows you to specify registrations via a configuration file. You can set up different configuration files to use in different environments and/or with different parameters, then during application startup pick the appropriate configuration file to read and register.</p>
<p>If you choose to use the <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> abstractions (Autofac 4.0+) you can even represent configuration as environment variables directly. See the docs on <code class="docutils literal notranslate"><span class="pre">Microsoft.Extensions.Configuration</span></code> for how to represent configuration in environment variables.</p>
</div>
<div class="section" id="use-modules">
<h4><a class="toc-backref" href="#id2">Use Modules</a><a class="headerlink" href="#use-modules" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> are a programmatic configuration mechanism that bundles registrations together. You can add parameters (e.g., constructor parameters or properties) to your module such that it registers different things or behaves differently based on provided values - values you read from the runtime environment.</p>
<p>There is an example of this <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">in the documentation for Autofac modules</span></a>.</p>
</div>
<div class="section" id="lambda-registrations">
<h4><a class="toc-backref" href="#id3">Lambda Registrations</a><a class="headerlink" href="#lambda-registrations" title="Permalink to this headline">¶</a></h4>
<p>You can <a class="reference internal" href="index.html#document-register/registration"><span class="doc">register components using lambda expressions</span></a> and make a runtime choice right in the registration for how to handle things. Note this may have an effect on performance depending on the expense of the runtime check and how often it gets executed, but it’s an option.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">environment</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">&quot;environment_name&quot;</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">environment</span> <span class="p">==</span> <span class="s">&quot;DEV&quot;</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">DevelopmentObject</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">ProductionObject</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IMyObject</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">SingleInstance</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<span id="document-faq/share-across-app-types"></span><div class="section" id="how-do-i-share-component-registrations-across-application-types">
<h3>How do I share component registrations across application types?<a class="headerlink" href="#how-do-i-share-component-registrations-across-application-types" title="Permalink to this headline">¶</a></h3>
<p>Note for doc writing: This is that question where someone wants to use per-request lifetime scopes in a web app but some other scope in a different kind of app.</p>
</div>
<span id="document-faq/isolate-autofac"></span><div class="section" id="how-do-i-keep-autofac-references-isolated-away-from-my-app">
<h3>How do I keep Autofac references isolated away from my app?<a class="headerlink" href="#how-do-i-keep-autofac-references-isolated-away-from-my-app" title="Permalink to this headline">¶</a></h3>
<p>It can be desirable to try to keep references to the Autofac assemblies and IoC container out of your application. Depending on how your application is structured, you may have varying levels of success. Here are some tips on how to structure your application such to minimize Autofac references as well as some things to watch for if you choose to do so.</p>
<p><strong>No one idea here will solve all of your problems.</strong> You will need to mix and match based on the structure of your application and what you’re trying to accomplish.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#application-startup" id="id1">Application Startup</a></li>
<li><a class="reference internal" href="#component-registrations" id="id2">Component Registrations</a><ul>
<li><a class="reference internal" href="#assembly-scanning" id="id3">Assembly Scanning</a></li>
<li><a class="reference internal" href="#modules" id="id4">Modules</a></li>
<li><a class="reference internal" href="#configuration" id="id5">Configuration</a></li>
<li><a class="reference internal" href="#istartable" id="id6">IStartable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#service-resolution" id="id7">Service Resolution</a><ul>
<li><a class="reference internal" href="#service-location" id="id8">Service Location</a></li>
<li><a class="reference internal" href="#implicit-relationships" id="id9">Implicit Relationships</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="application-startup">
<h4><a class="toc-backref" href="#id1">Application Startup</a><a class="headerlink" href="#application-startup" title="Permalink to this headline">¶</a></h4>
<p>Application startup is where your IoC container is built up and registrations are made. This is also where the IoC container is hooked into the <a class="reference external" href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/">composition root</a> for the application. For console apps, this is the <code class="docutils literal notranslate"><span class="pre">Main</span></code> method; for ASP.NET apps this is the <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class or the <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code>; for other applications there are other entry points.</p>
<p>You shouldn’t try to separate the IoC container from this section of your application. This is the point where it specifically hooks into things. If you’re trying to get Autofac away from your <code class="docutils literal notranslate"><span class="pre">Global.asax</span></code> or out of your <code class="docutils literal notranslate"><span class="pre">Startup</span></code> class (that is, you’re trying to remove the Autofac package/assembly reference from the assembly with this code in it), <strong>save yourself some time and don’t do that</strong>. You will potentially sink a lot of time into writing abstractions and wrappers around things only to replicate a lot of Autofac-specific syntax and capabilities.</p>
</div>
<div class="section" id="component-registrations">
<h4><a class="toc-backref" href="#id2">Component Registrations</a><a class="headerlink" href="#component-registrations" title="Permalink to this headline">¶</a></h4>
<p>The majority of where Autofac connects to your application is where you make your <a class="reference internal" href="index.html#document-register/index"><span class="doc">component registrations</span></a> into the container. There are a few ways you can limit Autofac connections here.</p>
<div class="section" id="assembly-scanning">
<h5><a class="toc-backref" href="#id3">Assembly Scanning</a><a class="headerlink" href="#assembly-scanning" title="Permalink to this headline">¶</a></h5>
<p>Autofac supports <a class="reference internal" href="index.html#document-register/scanning"><span class="doc">registering things through assembly scanning</span></a>. This can be helpful if you have a known set of assemblies or plugins and you want to register all of the types that, for example, implement a specific interface or are named a certain way.</p>
<p>It is hard to configure individual components when using assembly scanning, though. For example, you can’t really say “register all of these types, but just this handful need to be singletons while the rest must be instance-per-dependency.”</p>
<p>If you find that you want to use assembly scanning but need this level of control, you may need to use .NET reflection and handle additional functionality in your own code. For example, if you want to specify lifetime scope via a custom attribute, you could create that custom attribute and a corresponding set of methods to iterate through the set of assemblies and make the registrations based on the attribute value.</p>
</div>
<div class="section" id="modules">
<h5><a class="toc-backref" href="#id4">Modules</a><a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h5>
<p>Using <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> is a great way to group related type registrations but it does tie the type implementing <code class="docutils literal notranslate"><span class="pre">Autofac.Module</span></code> to the Autofac package.</p>
<p>One solution to this is to put the Autofac modules into separate assemblies. In this way, you would have two assemblies for a given function:</p>
<blockquote>
<div><ul class="simple">
<li>Product assembly: This assembly has your actual code and has no references to Autofac.</li>
<li>Module assembly: This assembly has a reference to the product assembly as well as Autofac. This is where you’d put your Autofac module.</li>
</ul>
</div></blockquote>
<p>Your application could then use <a class="reference internal" href="index.html#document-register/scanning"><span class="doc">assembly scanning</span></a> to locate all of the “module assemblies” and register the modules inside. (A trick to making this scanning easy is to adopt a naming convention for the module assemblies, then just run the scanning over those assemblies.)</p>
</div>
<div class="section" id="configuration">
<h5><a class="toc-backref" href="#id5">Configuration</a><a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="index.html#document-configuration/xml"><span class="doc">Autofac configuration</span></a> system works entirely based on a configuration file and allows you to specify registrations that are read in by your application startup code without requiring any references elsewhere. It is not as full-featured as <a class="reference internal" href="index.html#document-configuration/modules"><span class="doc">Autofac modules</span></a> so you may not be able to do all of your registrations this way, but it can be helpful for a handful of registrations.</p>
<p>You can also use the configuration system to register Autofac modules - this can allow you to specify modules in “module assemblies” (see above) and skip the assembly scanning.</p>
</div>
<div class="section" id="istartable">
<h5><a class="toc-backref" href="#id6">IStartable</a><a class="headerlink" href="#istartable" title="Permalink to this headline">¶</a></h5>
<p>Autofac provides an <code class="docutils literal notranslate"><span class="pre">IStartable</span></code> interface you can use to <a class="reference internal" href="index.html#document-lifetime/startup"><span class="doc">automatically resolve a component and execute code</span></a>.</p>
<p>If your <code class="docutils literal notranslate"><span class="pre">IStartable</span></code> is registered as a singleton (which it generally should be), you can make use of the <code class="docutils literal notranslate"><span class="pre">AutoActivate()</span></code> method along with an <code class="docutils literal notranslate"><span class="pre">OnActivated</span></code> handler to replace it and remove the Autofac dependency:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span>
   <span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">TypeRequiringWarmStart</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">AutoActivate</span><span class="p">()</span>
   <span class="p">.</span><span class="n">OnActivating</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">Start</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="service-resolution">
<h4><a class="toc-backref" href="#id7">Service Resolution</a><a class="headerlink" href="#service-resolution" title="Permalink to this headline">¶</a></h4>
<p>In the majority case of DI/IoC usage, you shouldn’t have a reference to your IoC container - you’ll instead have constructor parameters and/or settable properties that get populated by the container.</p>
<p>However, there are a few areas where you may find yourself tied to Autofac…</p>
<div class="section" id="service-location">
<h5><a class="toc-backref" href="#id8">Service Location</a><a class="headerlink" href="#service-location" title="Permalink to this headline">¶</a></h5>
<p>Some frameworks are lacking composition root hooks to enable all dependency injection hooks at the app startup level. One example of this is classic ASP.NET <code class="docutils literal notranslate"><span class="pre">HttpModules</span></code> - there is generally no hook that allows you to inject dependencies into a module. In cases like this, you may find use of service location useful (though you should definitely minimize service location where possible <a class="reference external" href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">given it’s an anti-pattern</a>).</p>
<p>In cases where you need a service locator but don’t want to tie to Autofac, consider using an abstraction like <a class="reference external" href="https://www.nuget.org/packages/CommonServiceLocator/">CommonServiceLocator</a> or <a class="reference external" href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/">Microsoft.Extensions.DependencyInjection</a>. In ASP.NET MVC applications, you’re already provided with a <code class="docutils literal notranslate"><span class="pre">DependencyResolver</span></code> for service location; other application types may have similar abstractions already provided. By using one of these abstractions, you can remove the Autofac reference… though you’ll have to keep a reference to the abstraction.</p>
</div>
<div class="section" id="implicit-relationships">
<h5><a class="toc-backref" href="#id9">Implicit Relationships</a><a class="headerlink" href="#implicit-relationships" title="Permalink to this headline">¶</a></h5>
<p>Autofac has several <a class="reference internal" href="index.html#document-resolve/relationships"><span class="doc">implicit relationships</span></a> it supports like <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">Lazy&lt;T&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">Func&lt;T&gt;</span></code>. For the most part, the relationships are based on core .NET types. However, <strong>if you’re using the following, you’ll be tied to Autofac</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IIndex&lt;X,</span> <span class="pre">B&gt;</span></code> (indexed collection)</li>
<li><code class="docutils literal notranslate"><span class="pre">Meta&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">Meta&lt;B,</span> <span class="pre">X&gt;</span></code> (strongly typed metadata)</li>
</ul>
</div></blockquote>
<p>There are no substitutes or workarounds to access instance names/keys or metadata on an object. If you need that functionality, you’re stuck with those relationships.</p>
<p>However, you can potentially reduce usage of these through your code by…</p>
<blockquote>
<div><ul class="simple">
<li>Creating a factory: You could wrap usage of these relationships in a factory. Define the factory interface in your application code assembly and define the implementation in a separate assembly that is allowed to reference Autofac.</li>
<li>Use lambda registrations: You can register components <a class="reference internal" href="index.html#document-register/registration"><span class="doc">using a lambda</span></a> and resolve the value right in the lambda. This is sort of like putting the factory inside the lambda registration rather than defining a separate interface for it. It takes a little bit of application code and puts it in the registration (e.g., the use of the metadata and/or the service key) but that may be an acceptable compromise.</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<span id="document-faq/pcl"></span><div class="section" id="why-are-old-versions-of-the-framework-e-g-system-core-2-0-5-0-referenced">
<h3>Why are “old versions” of the framework (e.g., System.Core 2.0.5.0) referenced?<a class="headerlink" href="#why-are-old-versions-of-the-framework-e-g-system-core-2-0-5-0-referenced" title="Permalink to this headline">¶</a></h3>
<p>Autofac (3.x) is a <strong>Portable Class Library</strong> that targets multiple platforms.</p>
<p>As a Portable Class Library, if you open up Autofac in Reflector, dotPeek, or other like tools, you’ll see references to version 2.0.5.0 of various system libraries. Version 2.0.5.0 is, in fact, the Silverlight version of the .NET framework. <em>This is expected and is not a problem.</em> At runtime everything pans out. Autofac will correctly bind to the framework version you’re using - be it .NET 4.5, Silverlight, or Windows Phone. <a class="reference external" href="https://msdn.microsoft.com/en-us/library/gg597391.aspx">You can read more about Portable Class Libraries on MSDN.</a></p>
<p>You may encounter an exception that looks something like this when using Autofac as a Portable Class Library:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Test &#39;MyNamespace.MyFixture.MyTest&#39; failed: System.IO.FileLoadException : Could not load file or assembly &#39;System.Core, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e, Retargetable=Yes&#39; or one of its dependencies. The given assembly name or codebase was invalid. (Exception from HRESULT: 0x80131047)
    at Autofac.Builder.RegistrationData..ctor(Service defaultService)
    at Autofac.Builder.RegistrationBuilder`3..ctor(Service defaultService, TActivatorData activatorData, TRegistrationStyle style)
    at Autofac.RegistrationExtensions.RegisterInstance[T](ContainerBuilder builder, T instance)
    MyProject\MyFixture.cs(49,0): at MyNamespace.MyFixture.MyTest()
</pre></div>
</div>
<p><strong>Make sure your .NET framework is patched.</strong> Microsoft released patches to .NET to allow Portable Class Libraries to properly find the appropriate runtime (<a class="reference external" href="https://support.microsoft.com/kb/2468871">KB2468871</a>). If you are seeing the above exception (or something like it), it means you’re missing the latest .NET framework patches.</p>
<p><a class="reference external" href="https://www.paraesthesia.com/archive/2013/03/29/portable-class-library-answers.aspx">This blog entry has a good overview</a> of these and other things you might see when you use Portable Class Libraries.</p>
<p>Autofac 4.x moved away from Portable Class Libraries and targets .NET Standard instead. You shouldn’t see these errors with Autofac 4.x or higher.</p>
</div>
<span id="document-faq/binding-redirect"></span><div class="section" id="why-don-t-all-autofac-packages-target-the-latest-autofac-core">
<h3>Why don’t all Autofac packages target the latest Autofac core?<a class="headerlink" href="#why-don-t-all-autofac-packages-target-the-latest-autofac-core" title="Permalink to this headline">¶</a></h3>
<p>Autofac has a lot of <a class="reference internal" href="index.html#document-integration/index"><span class="doc">integration packages</span></a> and extensions. You’ll find that not all of these packages directly reference the very latest of Autofac core.</p>
<p><strong>Unless there’s a technical reason to increase the minimum version requirement for one of these packages, we’ll keep the version unchanged.</strong></p>
<p>We do this because, generally speaking, we don’t want to force anyone to update their version of Autofac core unless they absolutely must. This is a fairly good practice for any library set - if a person doesn’t <em>have</em> to take an update, you shouldn’t <em>force</em> them to do so.</p>
<p><strong>The simple solution is to just add a direct reference in your app/project to your desired Auotfac core version.</strong></p>
<p><strong>In .NET Core this “just works.”</strong> The project system figures out the latest version of Autofac in the project (i.e., your direct reference) and redirects all bindings to that. No extra cruft, no work. Like magic.</p>
<p><strong>In .NET full framework projects this results in is the need to use assembly binding redirects.</strong> <a class="reference external" href="https://msdn.microsoft.com/en-us/library/vstudio/2fc472t2.aspx">This is the official supported way</a> to tell the .NET runtime that you need to redirect requests for one version of a strong-named assembly to a later version of that assembly. This is common enough that both NuGet and Visual Studio will, in many cases, automatically add these to your configuration files.</p>
<p>Here’s an example of what assembly binding redirects look like:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;runtime&gt;</span>
        <span class="nt">&lt;assemblyBinding</span> <span class="na">xmlns=</span><span class="s">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;dependentAssembly&gt;</span>
                <span class="nt">&lt;assemblyIdentity</span> <span class="na">name=</span><span class="s">&quot;Autofac&quot;</span>
                                  <span class="na">publicKeyToken=</span><span class="s">&quot;17863af14b0044da&quot;</span>
                                  <span class="na">culture=</span><span class="s">&quot;neutral&quot;</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;bindingRedirect</span> <span class="na">oldVersion=</span><span class="s">&quot;0.0.0.0-3.5.0.0&quot;</span>
                                 <span class="na">newVersion=</span><span class="s">&quot;3.5.0.0&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/dependentAssembly&gt;</span>
            <span class="nt">&lt;dependentAssembly&gt;</span>
                <span class="nt">&lt;assemblyIdentity</span> <span class="na">name=</span><span class="s">&quot;Autofac.Extras.CommonServiceLocator&quot;</span>
                                  <span class="na">publicKeyToken=</span><span class="s">&quot;17863af14b0044da&quot;</span>
                                  <span class="na">culture=</span><span class="s">&quot;neutral&quot;</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;bindingRedirect</span> <span class="na">oldVersion=</span><span class="s">&quot;0.0.0.0-3.1.0.0&quot;</span>
                                 <span class="na">newVersion=</span><span class="s">&quot;3.1.0.0&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/dependentAssembly&gt;</span>
            <span class="nt">&lt;dependentAssembly&gt;</span>
                <span class="nt">&lt;assemblyIdentity</span> <span class="na">name=</span><span class="s">&quot;Autofac.Extras.Multitenant&quot;</span>
                                  <span class="na">publicKeyToken=</span><span class="s">&quot;17863af14b0044da&quot;</span>
                                  <span class="na">culture=</span><span class="s">&quot;neutral&quot;</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;bindingRedirect</span> <span class="na">oldVersion=</span><span class="s">&quot;0.0.0.0-3.1.0.0&quot;</span>
                                 <span class="na">newVersion=</span><span class="s">&quot;3.1.0.0&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/dependentAssembly&gt;</span>
            <span class="nt">&lt;dependentAssembly&gt;</span>
                <span class="nt">&lt;assemblyIdentity</span> <span class="na">name=</span><span class="s">&quot;Autofac.Integration.Mvc&quot;</span>
                                  <span class="na">publicKeyToken=</span><span class="s">&quot;17863af14b0044da&quot;</span>
                                  <span class="na">culture=</span><span class="s">&quot;neutral&quot;</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;bindingRedirect</span> <span class="na">oldVersion=</span><span class="s">&quot;0.0.0.0-3.3.0.0&quot;</span>
                                 <span class="na">newVersion=</span><span class="s">&quot;3.3.0.0&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/dependentAssembly&gt;</span>
    <span class="nt">&lt;/runtime&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</pre></div>
</div>
<p>Assembly binding redirects are an unfortunate side-effect of <a class="reference external" href="https://msdn.microsoft.com/en-us/library/wd40t7ad.aspx">assembly strong-naming</a>. You don’t need binding redirects if assemblies aren’t strong-named; but there are some environments that require assemblies to be strong-named, so Autofac continues to strong-name assemblies.</p>
<p><strong>Even if Autofac always kept every reference up to date, you would still not escape assembly binding redirects.</strong> Autofac integration packages, like <a class="reference internal" href="index.html#document-integration/webapi"><span class="doc">the Web API integration</span></a>, rely on other strong-named packages that then have their own dependencies. For example, the <a class="reference external" href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/">Microsoft Web API packages</a> rely on <a class="reference external" href="https://www.nuget.org/packages/Newtonsoft.Json/">Newtonsoft.Json</a> and they don’t always keep up with the latest version. They instead specify a minimum compatible version. <em>If you update your local version of Newtonsoft.Json… you get a binding redirect.</em></p>
<p><strong>Rather than try to fight against binding redirects, it may be better to just accept them as a “cost of doing business” in the .NET world.</strong> They do add a bit of “clutter” to the application configuration file, but until we can remove strong-naming from the equation, it’s an inescapable necessity.</p>
</div>
<span id="document-faq/injecting-configured-parameters"></span><div class="section" id="how-do-i-inject-configuration-environment-or-context-parameters">
<h3>How do I inject configuration, environment, or context parameters?<a class="headerlink" href="#how-do-i-inject-configuration-environment-or-context-parameters" title="Permalink to this headline">¶</a></h3>
<p>There are times when you need to resolve a <a class="reference internal" href="index.html#document-glossary"><span class="doc">service</span></a> that consumes a <a class="reference internal" href="index.html#document-glossary"><span class="doc">component</span></a> somewhere down its dependency chain and that component needs <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">a parameter passed to it</span></a> from configuration, the environment, or some other runtime context location.</p>
<p>For this question, let’s imagine a simple email notification system like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This interface lets you send an email notification to someone.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">INotifier</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="kt">string</span> <span class="n">address</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This implementation of the notifier uses a backing email</span>
<span class="c1">// repository for doing the heavy lifting.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Notifier</span> <span class="p">:</span> <span class="n">INotifier</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IEmailServer</span> <span class="n">_server</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">Notifier</span><span class="p">(</span><span class="n">IEmailServer</span> <span class="n">server</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_server</span> <span class="p">=</span> <span class="n">server</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="kt">string</span> <span class="n">address</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_server</span><span class="p">.</span><span class="n">SendMessage</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s">&quot;from@domain.com&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This email server interface is what the notifier will use</span>
<span class="c1">// to send the email.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IEmailServer</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">toAddress</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fromAddress</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Notice this implementaton takes a string parameter for the server address -</span>
<span class="c1">// something we won&#39;t know until runtime so we can&#39;t explicitly register the</span>
<span class="c1">// parameter value.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">EmailServer</span> <span class="p">:</span> <span class="n">IEmailServer</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kt">string</span> <span class="n">_serverAddress</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">EmailServer</span><span class="p">(</span><span class="kt">string</span> <span class="n">serverAddress</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_serverAddress</span> <span class="p">=</span> <span class="n">serverAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">toAddress</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fromAddress</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...send the message through the specified server address.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you register things in Autofac, you might have registrations that look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Notifer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">INotifer</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailServer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailServer</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>The only time you know the email server address is at runtime - maybe through a context or environment parameter, maybe through configuration.</p>
<div class="contents local topic" id="how-do-you-get-the-configured-environment-context-parameter-to-the-email-server-when-you-resolve-the-notifier">
<p class="topic-title"><strong>How do you get the configured/environment/context parameter to the email server when you resolve the notifier?</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#option-1-register-using-a-lambda" id="id1">Option 1: Register Using a Lambda</a></li>
<li><a class="reference internal" href="#option-2-use-a-provider" id="id2">Option 2: Use a Provider</a></li>
</ul>
</div>
<div class="section" id="option-1-register-using-a-lambda">
<h4><a class="toc-backref" href="#id1">Option 1: Register Using a Lambda</a><a class="headerlink" href="#option-1-register-using-a-lambda" title="Permalink to this headline">¶</a></h4>
<p>In this option, rather than registering the email server type directly, <a class="reference internal" href="index.html#document-register/registration"><span class="doc">register using a lambda expression</span></a>. This allows you to resolve things from the container or use the environment to get the value.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">address</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">&quot;SERVER_ADDRESS&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">EmailServer</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailServer</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>As part of this, you may want to create some sort of abstraction around how you get the server address. For example, it may be something that you got as part of a web request and you’ve stored it in the <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code>. You could create an address provider like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IServerAddressProvider</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="nf">GetServerAddress</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ContextServerAddressProvider</span> <span class="p">:</span> <span class="n">IServerAddressProvider</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">HttpContextBase</span> <span class="n">_context</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">ContextServerAddressProvider</span><span class="p">(</span><span class="n">HttpContextBase</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_context</span> <span class="p">=</span> <span class="n">context</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="nf">GetServerAddress</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="n">_context</span><span class="p">.</span><span class="n">Items</span><span class="p">[</span><span class="s">&quot;EMAIL_SERVER_ADDRESS&quot;</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once you have a provider, you could register that with the container and use it in conjunction with the lambda.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ContextServerAddressProvider</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IServerAddressProvider</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">address</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IServerAddressProvider</span><span class="p">&gt;().</span><span class="n">GetServerAddress</span><span class="p">();</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">EmailServer</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailServer</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p><strong>If you need to pass a string parameter or can’t modify the code, this is the recommended option.</strong></p>
</div>
<div class="section" id="option-2-use-a-provider">
<h4><a class="toc-backref" href="#id2">Option 2: Use a Provider</a><a class="headerlink" href="#option-2-use-a-provider" title="Permalink to this headline">¶</a></h4>
<p>Expanding on the provider mechanism described in option 1: Usually the biggest problem is that the parameter you need to pass is a base type like an integer or a string. If you can switch this to use a provider a strongly-typed interface parameter, you can make registration a little easier.</p>
<p>For example, you may be able to get the parameter from a web request context like this.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IServerAddressProvider</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="nf">GetServerAddress</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ContextServerAddressProvider</span> <span class="p">:</span> <span class="n">IServerAddressProvider</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">HttpContextBase</span> <span class="n">_context</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">ContextServerAddressProvider</span><span class="p">(</span><span class="n">HttpContextBase</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_context</span> <span class="p">=</span> <span class="n">context</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">string</span> <span class="nf">GetServerAddress</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="n">_context</span><span class="p">.</span><span class="n">Items</span><span class="p">[</span><span class="s">&quot;EMAIL_SERVER_ADDRESS&quot;</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You could then refactor the email server code to take the provider rather than an address string:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">EmailServer</span> <span class="p">:</span> <span class="n">IEmailServer</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IServerAddressProvider</span> <span class="n">_serverAddressProvider</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">EmailServer</span><span class="p">(</span><span class="n">IServerAddressProvider</span> <span class="n">serverAddressProvider</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_serverAddressProvider</span> <span class="p">=</span> <span class="n">serverAddressProvider</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">toAddress</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fromAddress</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">address</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_serverAddressProvider</span><span class="p">.</span><span class="n">GetServerAddress</span><span class="p">();</span>
    <span class="c1">// ...send the message through the specified server address.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now you can just register types:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ContextServerAddressProvider</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IServerAddressProvider</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">InstancePerRequest</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailServer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailServer</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p><strong>If you can modify the code, this is the recommended option.</strong></p>
</div>
</div>
<span id="document-faq/injecting-global-parameters"></span><div class="section" id="how-do-i-pass-a-parameter-to-a-component-in-the-middle-of-a-resolve-chain">
<h3>How do I pass a parameter to a component in the middle of a resolve chain?<a class="headerlink" href="#how-do-i-pass-a-parameter-to-a-component-in-the-middle-of-a-resolve-chain" title="Permalink to this headline">¶</a></h3>
<p>There are times when you need to resolve a <a class="reference internal" href="index.html#document-glossary"><span class="doc">service</span></a> that consumes a <a class="reference internal" href="index.html#document-glossary"><span class="doc">component</span></a> somewhere down its dependency chain and that component needs <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">a parameter passed to it</span></a>.</p>
<p>For this question, let’s imagine a simple email notification system like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This interface lets you send an email notification to someone.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">INotifier</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="kt">string</span> <span class="n">address</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This implementation of the notifier uses a backing email</span>
<span class="c1">// repository for doing the heavy lifting.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Notifier</span> <span class="p">:</span> <span class="n">INotifier</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IEmailServer</span> <span class="n">_server</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">Notifier</span><span class="p">(</span><span class="n">IEmailServer</span> <span class="n">server</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_server</span> <span class="p">=</span> <span class="n">server</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="kt">string</span> <span class="n">address</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_server</span><span class="p">.</span><span class="n">SendMessage</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s">&quot;from@domain.com&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This email server interface is what the notifier will use</span>
<span class="c1">// to send the email.</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IEmailServer</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">toAddress</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fromAddress</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Notice this implementaton takes a string parameter for the server address -</span>
<span class="c1">// something we won&#39;t know until runtime so we can&#39;t explicitly register the</span>
<span class="c1">// parameter value.</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">EmailServer</span> <span class="p">:</span> <span class="n">IEmailServer</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kt">string</span> <span class="n">_serverAddress</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">EmailServer</span><span class="p">(</span><span class="kt">string</span> <span class="n">serverAddress</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">_serverAddress</span> <span class="p">=</span> <span class="n">serverAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">toAddress</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fromAddress</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...send the message through the specified server address.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you register things in Autofac, you might have registrations that look like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">Notifer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">INotifer</span><span class="p">&gt;();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">EmailServer</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IEmailServer</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
<p>The only time you know the email server address is at runtime - maybe through a context or environment parameter, maybe through configuration.</p>
<p><strong>How do you pass a parameter to the email server when you resolve the notifier?</strong></p>
<div class="section" id="why-this-is-a-design-problem">
<h4>Why This is a Design Problem<a class="headerlink" href="#why-this-is-a-design-problem" title="Permalink to this headline">¶</a></h4>
<p>Before answering the question, consider that in many respects that <strong>asking this question indicates a sort of design problem</strong>.</p>
<p>Technically speaking, you’re resolving an <code class="docutils literal notranslate"><span class="pre">INotifier</span></code> - a component that doesn’t need to know about the runtime parameter with the email server address. The implementation of that <code class="docutils literal notranslate"><span class="pre">INotifier</span></code> could change. You could register a stub for testing, or switch up how emails get sent so they no longer need to know about the address.</p>
<p>Passing the server address as a parameter to the <code class="docutils literal notranslate"><span class="pre">INotifier</span></code> breaks the decoupling that interface-based development and inversion of control gives you by assuming that you “know” how the entire dependency chain is being resolved.</p>
<p><strong>The key to solving the problem is to break that “knowledge” so you’re not passing a parameter.</strong></p>
</div>
<div class="section" id="solutions">
<h4>Solutions<a class="headerlink" href="#solutions" title="Permalink to this headline">¶</a></h4>
<p>Instead of trying to pass a parameter, flip the problem around - <strong>figure out how you determine the parameter at runtime and wrap that in a provider or a lamda expression registration.</strong></p>
<p>This changes the question to a different FAQ where we walk through answers step by step: <a class="reference internal" href="index.html#document-faq/injecting-configured-parameters"><span class="doc">How do I inject configuration, environment, or context parameters?</span></a></p>
</div>
</div>
<span id="document-faq/container-analysis"></span><div class="section" id="why-isn-t-container-registration-analysis-built-in">
<h3>Why isn’t container registration analysis built in?<a class="headerlink" href="#why-isn-t-container-registration-analysis-built-in" title="Permalink to this headline">¶</a></h3>
<p>It is pretty frustrating to get runtime exceptions when resolving things due to an incomplete or incorrect set of registrations in your Autofac container. Why isn’t there any sort of analysis built in so you can assert container validity after the container is built?</p>
<p>While this feature does appear in some containers, the flexibility available in Autofac to handle dependency resolution based on runtime parameters and dynamic functionality makes it difficult to offer a useful container validity check.</p>
<p>Consider the following example code:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ContainerBuilder</span><span class="p">();</span>

<span class="c1">// ProdConfiguration requires a connectionString parameter</span>
<span class="c1">// because it reads from a database.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ProdConfiguration</span><span class="p">&gt;().</span><span class="n">AsSelf</span><span class="p">();</span>

<span class="c1">// Lambda reads the environment and returns the correct</span>
<span class="c1">// configuration based on that.</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">ctx</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">env</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">&quot;ENVIRONMENT&quot;</span><span class="p">);</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="s">&quot;Development&quot;</span><span class="p">:</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">TestConfiguration</span><span class="p">();</span>
    <span class="k">case</span> <span class="s">&quot;Production&quot;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ProdConfiguration</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">NamedParameter</span><span class="p">(</span><span class="s">&quot;connStr&quot;</span><span class="p">,</span> <span class="n">connectionString</span><span class="p">));</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">(</span><span class="s">&quot;Unknown environment name.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}).</span><span class="n">As</span><span class="p">&lt;</span><span class="n">IConfiguration</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Container configuration like this is perfectly valid but it raises questions:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">ProdConfiguration</span></code> requires a connection string parameter that isn’t registered in the container, is your container valid? What if you use service location and pass in the string as <a class="reference internal" href="index.html#document-resolve/parameters"><span class="doc">a parameter during resolution</span></a>? How would the container know that?</li>
<li>If <code class="docutils literal notranslate"><span class="pre">IConfiguration</span></code> relies on a particular environment parameter being present and it’s there during deployment but not during unit tests, is your container valid?</li>
</ul>
<p>These are somewhat simple cases. Consider the additional cases of things like…</p>
<ul class="simple">
<li>Modules that can dynamically attach things to all registrations like <a class="reference internal" href="index.html#document-examples/log4net"><span class="doc">the logging module</span></a></li>
<li><a class="reference internal" href="index.html#document-advanced/registration-sources"><span class="doc">Registration sources</span></a></li>
<li><a class="reference internal" href="index.html#document-register/parameters"><span class="doc">Registration parameters</span></a></li>
<li><a class="reference internal" href="index.html#document-advanced/interceptors"><span class="doc">Interceptors</span></a>, <a class="reference internal" href="index.html#document-advanced/adapters-decorators"><span class="doc">adapters</span></a>, and <a class="reference internal" href="index.html#document-advanced/adapters-decorators"><span class="doc">decorators</span></a></li>
<li><a class="reference internal" href="index.html#document-register/scanning"><span class="doc">Dynamic assembly scanning</span></a></li>
</ul>
<p>These are not uncommon scenarios and that’s not even a complete list of dynamic capabilities supported.</p>
<p>It is possible that at some point a very simplistic analysis mechanism could be added to try catching a minority of issues, but it is likely a more valuable endeavor to enhance Autofac to support better diagnostic and tracing functionality to more quickly target and resolve runtime challenges that are encountered. (If you’re interested in helping with that effort, <a class="reference external" href="https://github.com/autofac/Autofac/issues">let us know!</a>)</p>
</div>
<span id="document-faq/xamarin-issues"></span><div class="section" id="why-are-things-in-my-xamarin-app-misbehaving">
<h3>Why are things in my Xamarin app misbehaving?<a class="headerlink" href="#why-are-things-in-my-xamarin-app-misbehaving" title="Permalink to this headline">¶</a></h3>
<p><strong>Autofac targets .NET Framework and .NET Standard.</strong> <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">This makes the code fairly portable across platforms.</a> It can be used in, among other things, Mono, Xamarin, and Universal Windows Platform apps.</p>
<p><a class="reference external" href="https://docs.microsoft.com/en-us/xamarin/cross-platform/get-started/introduction-to-mobile-development">Xamarin provides a cross-platform compiler</a> that can take C# and .NET code and compile that into native applications. From <a class="reference external" href="https://docs.microsoft.com/en-us/xamarin/cross-platform/get-started/introduction-to-mobile-development">the docs</a>:</p>
<blockquote>
<div>On iOS, Xamarin’s Ahead-of-Time (AOT) Compiler compiles Xamarin.iOS applications directly to native ARM assembly code. On Android, Xamarin’s compiler compiles down to Intermediate Language (IL), which is then Just-in-Time (JIT) compiled to native assembly when the application launches.</div></blockquote>
<p>One of the challenges is that not all the end platforms (e.g., iOS or Android) have support for all .NET features. For example, the linker may optimize out types that it thinks aren’t used but really are as part of reflection and dependency injection. It does this as a way to speed up the app and reduce the overall size - remove types and/or methods that it doesn’t think are used. This sort of conversion and optimization can cause apps that run as expected in .NET to behave slightly differently in a native compiled app from Xamarin.</p>
<p><strong>Autofac is not specifically built or tested for Xamarin or .NET Native apps.</strong> In targeting .NET Standard, it becomes the job of the cross-platform compiler and linker to ensure compatibility with other .NET Standard code.</p>
<p><a class="reference internal" href="index.html#document-advanced/cross-platform-apps"><span class="doc">We have some tips that we’ve gathered from the community on getting Xamarin and .NET Native apps working.</span></a> Hopefully these will help. If you have additional tips or articles to contribute that might help others, let us know and we’ll be happy to include them. It can sometimes be a challenge to get the right compiler and linker directives correct to get things working in Xamarin with reflection.</p>
<p><strong>If you are still having trouble after looking at the tips and doing research, ask your question on StackOverflow.</strong> Tag it <code class="docutils literal notranslate"><span class="pre">xamarin</span></code> to <a class="reference external" href="https://stackoverflow.com/questions/tagged/xamarin">make sure people familiar with Xamarin get notified and can help answer it</a>.</p>
</div>
</div>
</div>
<span id="document-glossary"></span><div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<p>The goal of this page is to help keep documentation, discussions, and APIs consistent.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Term</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Activator</em></td>
<td>Part of a <em>Registration</em> that, given a <em>Context</em> and a set of <em>Parameters</em>, can create a <em>Component Instance</em> bound to that <em>Context</em></td>
</tr>
<tr class="row-odd"><td><em>Argument</em></td>
<td>A formal argument to a constructor on a .NET type</td>
</tr>
<tr class="row-even"><td><em>Component</em></td>
<td>A body of code that declares the <em>Services</em> it provides and the <em>Dependencies</em> it consumes</td>
</tr>
<tr class="row-odd"><td><em>Instance</em></td>
<td>A .NET object obtained by <em>Activating</em> a <em>Component</em> that provides <em>Services</em> within a <em>Container</em> (also <em>Component Instance</em>)</td>
</tr>
<tr class="row-even"><td><em>Container</em></td>
<td>A construct that manages the <em>Components</em> that make up an application</td>
</tr>
<tr class="row-odd"><td><em>Context</em></td>
<td>A bounded region in which a specific set of <em>Services</em> is available</td>
</tr>
<tr class="row-even"><td><em>Dependency</em></td>
<td>A <em>Service</em> required by a <em>Component</em></td>
</tr>
<tr class="row-odd"><td><em>Lifetime</em></td>
<td>A duration bounded by the <em>Activation</em> of an <em>Instance</em> and its disposal</td>
</tr>
<tr class="row-even"><td><em>Parameter</em></td>
<td>Non-<em>Service</em> objects used to configure a <em>Component</em></td>
</tr>
<tr class="row-odd"><td><em>Registration</em></td>
<td>The act of adding and configuring a <em>Component</em> for use in a <em>Container</em>, and the information associated with this process</td>
</tr>
<tr class="row-even"><td><em>Scope</em></td>
<td>The specific <em>Context</em> in which <em>Instances</em> of a <em>Component</em> will be shared by other <em>Components</em> that depend on their <em>Services</em></td>
</tr>
<tr class="row-odd"><td><em>Service</em></td>
<td>A well-defined behavioural contract shared between a providing and a consuming <em>Component</em></td>
</tr>
</tbody>
</table>
<p>Admittedly this seems a bit low-level to fit with the typical idea of a ‘universal language’, but within the domain of IoC containers and specifically Autofac these can be viewed as concepts rather than implementation details.</p>
<p>Wild deviations from these terms in the API or code should be fixed or raised as issues to fix in a future version.</p>
<p>The terms <em>Application</em>, <em>Type</em>, <em>Delegate</em>, <em>Object</em>, <em>Property</em> etc. have their usual meaning in the context of .NET software development.</p>
</div>
<span id="document-contributors"></span><div class="section" id="contributor-guide">
<h2>Contributor Guide<a class="headerlink" href="#contributor-guide" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/autofac/Autofac/blob/develop/CONTRIBUTING.md">The Autofac contributor’s guide is located in GitHub.</a> If you are interested in contributing or building the project from source, check it out.</p>
<p>Contributors must follow the <a class="reference external" href="https://github.com/autofac/Autofac/blob/develop/CODE_OF_CONDUCT.md">Code of Conduct</a>.</p>
</div>
<span id="document-support"></span><div class="section" id="getting-support">
<h2>Getting Support<a class="headerlink" href="#getting-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="community-support">
<h3>Community Support<a class="headerlink" href="#community-support" title="Permalink to this headline">¶</a></h3>
<p>Autofac has a large community that can help you out if you have questions. If you can’t find your answer in the documentation, you can…</p>
<ul class="simple">
<li><a class="reference external" href="https://stackoverflow.com/questions/tagged/autofac">Ask your question on StackOverflow</a>. Be sure to use the <code class="docutils literal notranslate"><span class="pre">autofac</span></code> tag in your question.</li>
<li><a class="reference external" href="https://groups.google.com/forum/#forum/autofac">Start a discussion on the forum</a>. This is a good idea if you have multiple questions or a question that might have a more subjective answer (e.g., “recommendations” sorts of things).</li>
</ul>
</div>
<div class="section" id="commercial-support">
<h3>Commercial Support<a class="headerlink" href="#commercial-support" title="Permalink to this headline">¶</a></h3>
<p>Several companies offer commercial support for Autofac questions/design issues:</p>
<ul class="simple">
<li><a class="reference external" href="http://readify.net">Readify</a> - training and consulting services</li>
<li><a class="reference external" href="http://ciclo.pt/">CICLO</a> - commercial support and training</li>
<li><a class="reference external" href="http://continuousit.com">Continuous IT</a> - training, troubleshooting and implementation help</li>
</ul>
<p>Note: while the above listed companies offer help, they are not officially affiliated with the Autofac project.</p>
<p><em>If you would like your company listed here, please send an email to the discussion group.</em></p>
</div>
<div class="section" id="filing-an-issue">
<h3>Filing an Issue<a class="headerlink" href="#filing-an-issue" title="Permalink to this headline">¶</a></h3>
<p>If you’re having trouble figuring something out, please do try at least the community support road before filing a question-based issue. We do have a really great set of folks <a class="reference external" href="https://stackoverflow.com/questions/tagged/autofac">on StackOverflow</a>, and while we definitely want to help you succeed, there is a <em>far, far, far smaller audience answering issues</em>.</p>
<p>If you do find a bug or just can’t get an answer elsewhere, please file issues <strong>in the repository corresponding to the library you’re having trouble with</strong>. For example, if you’re having trouble with Web API integration, file the issue <a class="reference external" href="https://github.com/autofac/Autofac.WebApi/issues">with the Web API Autofac integration library</a> rather than in the core Autofac project.</p>
<p><strong>Please include a detailed description of what’s going wrong, full exception messages and stack traces, and (ideally) a small reproduction so we can see the problem in action like a failing unit test or a link to a small project.</strong> Including as much information as you can will help us address the issue in a more timely fashion.</p>
</div>
</div>
<span id="document-owners"></span><div class="section" id="owner-s-guide">
<h2>Owner’s Guide<a class="headerlink" href="#owner-s-guide" title="Permalink to this headline">¶</a></h2>
<p>Becoming an Autofac owner is going a step beyond <a class="reference internal" href="index.html#document-contributors"><span class="doc">being a contributor</span></a>. Ownership is a longer-term commitment and, honestly, may not be for everyone. That’s OK. If you don’t think you’re up for it, we would still love to get your help <a class="reference internal" href="index.html#document-contributors"><span class="doc">in the form of pull requests</span></a> or answering questions on StackOverflow!</p>
<p>We haven’t seen a great onboarding guide for getting owners up and productive or explaining the responsibilities so… this is our attempt at that.</p>
<div class="section" id="ownership-is-about-trust">
<h3>Ownership is About Trust<a class="headerlink" href="#ownership-is-about-trust" title="Permalink to this headline">¶</a></h3>
<p><strong>This is the number one difference between ownership and contribution.</strong></p>
<p>If you’re an Autofac owner, you’re providing product and support for people and products around the world, whether you know it or not. From the smallest hobby project to enterprise-level solutions, Autofac and its integration packages are used everywhere.</p>
<p>There is an implicit trust between all of these projects and you. They trust that every change you make is doing something for the better. They trust that things have been well tested. They trust that if something has gone wrong in the latest release that there’s going to be someone - <strong>you</strong> - there to answer questions, help debug things, and correct issues.</p>
<p>They trust that <a class="reference external" href="https://snyk.io/blog/malicious-code-found-in-npm-package-event-stream/">you’re not doing anything malicious</a>.</p>
<p>Being an owner is accepting that trust and always trying your best to do the right thing for the project and the community.</p>
</div>
<div class="section" id="code-of-conduct">
<h3>Code of Conduct<a class="headerlink" href="#code-of-conduct" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/autofac/Autofac/blob/develop/CODE_OF_CONDUCT.md">Our code of conduct is posted on GitHub</a>. All owners must follow the code of conduct. Owners are responsible for enforcing the code of conduct on each other and on contributors.</p>
</div>
<div class="section" id="responsibilities">
<h3>Responsibilities<a class="headerlink" href="#responsibilities" title="Permalink to this headline">¶</a></h3>
<p>As an owner, you have a few additional responsibilities that a standard contributor doesn’t have.</p>
<div class="section" id="api-design">
<h4>API Design<a class="headerlink" href="#api-design" title="Permalink to this headline">¶</a></h4>
<p>Owners have the final say about the shape of the public API. Do we need a new class here or a new interface there? Is that new method overload really helpful? As noted <a class="reference internal" href="index.html#document-contributors"><span class="doc">in contributors guide</span></a>, there are a lot of things that may constitute breaking changes in the API. We can add things pretty easily… but removing them once the package has been taken is a major version increment and a breaking change for downstream consumers.</p>
<p>As contributions come in, or as you work on new features and functionality, you need to keep a conscious eye toward the public API footprint.</p>
<p>Autofac and its extension packages make use of internal classes for things that shouldn’t be consumed by the public. This allows freedom to refactor without incurring breaking changes.</p>
</div>
<div class="section" id="bug-fixes-and-enhancements">
<h4>Bug Fixes and Enhancements<a class="headerlink" href="#bug-fixes-and-enhancements" title="Permalink to this headline">¶</a></h4>
<p>Issues are filed all the time to let us know about problems folks are having or new features they’d like. The vast majority of the time, these issues do not come with any associated pull request. It’s up to you to fix things or add features based on the needs noted in the issue.</p>
<p>Implementing fixes and features is a lot more than just coding. You need to be able to imagine what other use cases out there are occurring and whether the thing you’re changing is going to break that use case. You need to consider the API design and whether the thing you’re implementing will be supportable long-term.</p>
<p><strong>There is no feature roadmap unless you make it.</strong></p>
<p>Most of the enhancements and new features implemented in Autofac start with issues someone files mentioning how something is currently hard and should be easier. In some cases, people may find a new way they’d like to use an existing feature but it’s just not working right.</p>
<p>As an owner, you get to implement the fixes and features that other contributions aren’t covering.</p>
</div>
<div class="section" id="performance-and-testing">
<h4>Performance and Testing<a class="headerlink" href="#performance-and-testing" title="Permalink to this headline">¶</a></h4>
<p>Performance is your responsibility. You may think of a great fix, but if it slows everything down, it’s probably not the way to go. This additional feature someone asked for may sound awesome, but if it means an additional 10ms per resolve operation, it may need to be reconsidered. That cache idea to speed things up may be great, but if it takes an additional 100MB of RAM to support, the speed trade-off may not be worth it.</p>
<p>Whatever you’re adding, whether from your own code or by virtue of accepting a contribution, needs to be considered from a performance and testing perspective. This isn’t something most contributors check.</p>
<p><strong>If it isn’t tested, don’t release it.</strong></p>
</div>
<div class="section" id="issue-review">
<h4>Issue Review<a class="headerlink" href="#issue-review" title="Permalink to this headline">¶</a></h4>
<p>Issues come in for a lot of reasons - from questions to bug reports to enhancement requests.</p>
<p>If the issue is a question, we generally try to get them to post to <a class="reference external" href="https://stackoverflow.com">StackOverflow</a> and tag the question <code class="docutils literal notranslate"><span class="pre">autofac</span></code>. We do that because then the question can be searched by other people. People trying to figure out how something works largely won’t come looking through the closed issues list in GitHub, so answering the question in GitHub only helps <em>that one person</em> while answering on StackOverflow can help many people. We also discourage folks from double-posting questions - if it’s on StackOverflow <em>and</em> it’s been filed on GitHub, put a link to the StackOverflow question in the issue and close the issue. (This information should also be in the issue template in every Autofac repo, so folks double-posting aren’t actually reading the issue template.)</p>
<p>If the issue is a bug report, we need some ability to reproduce the issue so we can verify it. Ideally this is in the form of a simple, self-contained failing unit test. If there is no reproduction, encourage the person to add one so you can more adequately help.</p>
<p>As an owner, it’s up to you to verify whether it’s a bug or whether it’s functioning as designed. If it’s a bug, tag the issue as <code class="docutils literal notranslate"><span class="pre">bug</span></code>. Now you can fix it or someone can submit a pull request to fix it. In any case, there really needs to be a unit test for any bug fixes so we don’t regress the issue. Consider adding a comment in the unit test to indicate which issue is associated with the test.</p>
<p>For things that are functioning as designed, this is an opportunity for support. Explain why the reproduction the user submitted is invalid and show them how to fix it. Usually you can refer them to documentation or examples showing working versions of what they’re trying to do.</p>
<p>For enhancement issues, there are a lot of things to consider.</p>
<ul class="simple">
<li>Is this something that can already be done with the existing API?</li>
<li>Is this something that the <em>library</em> should own or is it something that would be better owned by the person’s <em>application code</em>?</li>
<li>How many other people would find this enhancement useful?</li>
<li>How does this affect the public API?</li>
<li>The change may be a good one, but will it break existing features?</li>
<li>How will this affect performance?</li>
<li>If it’s a change to the way integration works with a third-party framework, is this something the third-party framework will be obsoleting soon?</li>
</ul>
<p>Being an owner means you get to determine if an enhancement or bug someone has reported is actually something that should be addressed. In some cases, you’re going to have to say no. <strong>It’s OK to say no.</strong> Don’t say no to everything, but… not everything is a good idea, either. If you do say no, explain to the user why that’s the case so they can understand.</p>
<p>For example, say someone files a defect saying they didn’t register any <code class="docutils literal notranslate"><span class="pre">ICar</span></code> implementations but somehow they can resolve <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;ICar&gt;</span></code> and it’s empty. They think they should be getting <code class="docutils literal notranslate"><span class="pre">null</span></code> instead. Unfortunately, Autofac currently <em>intentionally</em> returns an empty collection. Changing that behavior would be very breaking, so that’s not a fix we could provide. We’d say no to this.</p>
</div>
<div class="section" id="pull-request-review">
<h4>Pull Request Review<a class="headerlink" href="#pull-request-review" title="Permalink to this headline">¶</a></h4>
<p>When a pull request comes in, it’s up to you as an owner to determine whether it’s something that should be accepted, whether it needs work before we can accept it, or whether it shouldn’t be accepted at all.</p>
<p><strong>The ultimate responsibility for accepting a pull request and maintaining the contents of that PR is with the Autofac owners.</strong></p>
<p>If accepting and releasing the contents of a pull request breaks something, it’ll be up to you as the owner to fix it. The original submitter will likely not be available in the required time frame to issue a fix if something breaks. By accepting the pull request code, you’re accepting responsibility and ownership for that code on behalf of all the Autofac owners.</p>
<p>Things to consider as you look at a PR…</p>
<ul class="simple">
<li>Is it against the correct branch? PRs should be against <code class="docutils literal notranslate"><span class="pre">develop</span></code> since we follow Gitflow.</li>
<li>Can we maintain it? There are some great optimizations that folks might submit, but if no one who owns Autofac understands how it works, it’ll be hard to maintain long term if something goes wrong. The original PR submitter isn’t the person who will own it, you are.</li>
<li>Is it really big? We get a lot of really big pull requests that drastically change things. Some of these are fantastic. Some include breaking API changes we can’t take. If it’s super big, it takes a long time to review. You’ll likely have to check out the PR branch, build it locally, and test it yourself. Is there a way to break it into smaller PRs? If it’s this big, was there an issue filed first that explains the intent? (Usually a large PR should have an issue first.)</li>
<li>Does it need tests? A PR for a spelling or doc fix is easy to take. For code… does the PR come with tests that verify the behavior? If not, it’s your call as an owner - you can ask the submitter to write tests (which may result in the submitter abandoning the PR because they think it’s too much effort) or you can accept the PR and add tests yourself after the fact.</li>
<li>Does it break anything? Some PRs come with inadvertent breaking changes to the API, a refactor of something that didn’t need to be refactored, for example.</li>
<li>Did NuGet package references change? Lots of PRs include updates to NuGet packages that aren’t technically required. Unless there’s a technical reason to take the update, we need to keep on the lowest possible versions for widest compatibility. (Sometimes we’ll get issues or PRs <em>just</em> to force that update. That’s not the answer. If an individual app needs an update, they need to do that at the app level.)</li>
<li>Does it adhere to our standards? The <a class="reference internal" href="index.html#document-contributors"><span class="doc">Contributor’s Guide</span></a> outlines not only our general coding standards but the fact that everything should build and test with no errors, no warnings. Does the PR introduce any Roslyn analyzer warnings?</li>
</ul>
<p>This isn’t a complete list, but it gives you some ideas of things to look for. Not every pull request that comes in is something we can just accept straight up.</p>
<p>If you need clarification on things, ask the person who submitted the PR to explain stuff. A pull request isn’t a thing where someone throws code over the wall to you, it’s a community endeavor.</p>
<p><strong>If you want help looking at something, tag one of the other Autofac owners to give it a look. You’re not alone.</strong></p>
</div>
<div class="section" id="support">
<h4>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h4>
<p>Support is one of those “hidden costs” of being an owner of an open source project. A lot more time goes to support than you might think. Sometimes you may spend more time on support than you do on coding things.</p>
<p>We accept support requests through a variety of channels.</p>
<ul class="simple">
<li><a class="reference external" href="https://stackoverflow.com">StackOverflow</a> with questions that are tagged <code class="docutils literal notranslate"><span class="pre">autofac</span></code>.</li>
<li><a class="reference external" href="https://groups.google.com/forum/#!forum/autofac">Google Groups</a></li>
<li><a class="reference external" href="https://twitter.com/autofacioc">Twitter</a></li>
<li><a class="reference external" href="https://gitter.im/autofac/Autofac">Gitter</a></li>
<li>GitHub issues (though, ideally, “How do I…?” sorts of questions go on StackOverflow)</li>
</ul>
<p>At a minimum, as an owner you should subscribe to the <code class="docutils literal notranslate"><span class="pre">autofac</span></code> questions on SO and the Google Group.</p>
<p><strong>You are not required to write other peoples’ code for them.</strong></p>
<p><strong>You are not a free consultant service.</strong></p>
<p>Treat people cordially and with respect, however, there are an unfortunate number of questions that amount to, “I’m trying to write a super complex system and I’m using Autofac. Show me the code that implements this system.” Don’t feel obligated to implement other peoples’ systems for them.</p>
<p>If you don’t know the answer, that’s OK. Try your best. It may require you learn something new in the Autofac space, which is helpful as an owner. That said, you’re not required to memorize every framework Autofac integrates with, so there will be times you don’t know and that’s OK.</p>
</div>
<div class="section" id="documentation-and-examples">
<h4>Documentation and Examples<a class="headerlink" href="#documentation-and-examples" title="Permalink to this headline">¶</a></h4>
<p>Documentation is how many people understand how Autofac and its integration works.</p>
<p>Documentation takes many forms:</p>
<ul class="simple">
<li>Long-form prose, like the site you’re reading now. Something that explains in detail how to use something with examples.</li>
<li>XML API documentation. These are the <code class="docutils literal notranslate"><span class="pre">&lt;summary&gt;</span></code> sorts of comments on members in the code. IntelliSense is generated from this content, as is the HTML API documentation.</li>
<li>Inline code comments. If there’s a particularly difficult to understand section of code or something in the code that might be confusing (“Why did this variable have to get proactively disposed right here?”), adding a small comment to explain <em>why</em> something is happening can help other contributors to not regress defects or inadvertently create performance issues.</li>
</ul>
<p>As an owner, you’re responsible for <em>all of these types of documentation.</em> People around the world learn in different ways. Not all of them are ready to dive into GitHub repos and “read the code.” It’s our job to try to accommodate all the different levels of learners with the docs they require.</p>
<p>Examples may be:</p>
<ul class="simple">
<li>Small projects that demonstrate an end-to-end feature. We have a whole <a class="reference external" href="https://github.com/autofac/Examples">Examples repository</a> with this sort of thing. These are helpful to show (and test) real working integration features.</li>
<li>Unit tests. These are harder to interpret for some users, but are good for being “executable specifications” of how something should work.</li>
<li>Inline examples. In the documentation, you can pull from small projects or unit tests to create code snippets that illustrate how to use a feature.</li>
</ul>
<p>Again, as an owner, it’s up to you to help support the project with proper docs and examples so people know how to consume the libraries.</p>
</div>
<div class="section" id="compatibility">
<h4>Compatibility<a class="headerlink" href="#compatibility" title="Permalink to this headline">¶</a></h4>
<p><strong>It is an explicit goal to be as compatible with as much as possible at any given time.</strong></p>
<p><a class="reference internal" href="index.html#document-contributors"><span class="doc">The contributors guide</span></a> talks about different considerations in compatibility. Briefly:</p>
<ul class="simple">
<li>Framework compatibility: Changing from <code class="docutils literal notranslate"><span class="pre">netstandard1.0</span></code> to <code class="docutils literal notranslate"><span class="pre">netstandard2.0</span></code> as a minium requirement for a library means all the consumers using the library can no longer take an upgrade.</li>
<li>API compatibility: Adding a new member on an interface, moving an extension method to a different static class, or even adding an optional parameter on an existing method is a breaking public API change. Doing that will break someone consuming that API if they take the upgrade.</li>
<li>Dependency compatibility: If an Autofac component takes an upgrade to a dependency, it effectively forces all of the consumers of that Autofac component to also take the upgrade. In general, we should leave that choice up to the application developer where possible. There may be a technical reason to take an upgrade, like an integration that needs to take advantage of a new feature. Those choices need to be weighed individually.</li>
</ul>
<p>As you maintain Autofac, it’s up to you as an owner to determine when it’s a good time to make a change that will potentially break the thousands of projects consuming the library you’re working on. These are hard decisions. It’s OK to ask for help.</p>
<p>From a general policy perspective, we should always be <em>compatible</em> with the latest release of a third party framework with which we integrate. That doesn’t always mean we <em>require</em> the latest version, but that we’re <em>compatbile</em> with it. If there is a choice where the two are mutually exclusive - we can <em>either</em> be compatible with the older stuff <em>or</em> we have to move forward… we’ll choose to move forward.</p>
</div>
</div>
<div class="section" id="release-process">
<h3>Release Process<a class="headerlink" href="#release-process" title="Permalink to this headline">¶</a></h3>
<p>We follow the <a class="reference external" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow/">Gitflow workflow process</a>. Ongoing development should happen in the <code class="docutils literal notranslate"><span class="pre">develop</span></code> branch. Continuous integration builds get published to MyGet and can be consumed for testing purposes.</p>
<p>When it’s time to cut a release, we’ll:</p>
<ul class="simple">
<li>Ensure the semantic version is correct based on the changes since the last release. Update if needed, do a final CI build on the <code class="docutils literal notranslate"><span class="pre">develop</span></code> branch.</li>
<li>Merge <code class="docutils literal notranslate"><span class="pre">develop</span></code> into <code class="docutils literal notranslate"><span class="pre">master</span></code> and tag the repo with <code class="docutils literal notranslate"><span class="pre">vX.Y.Z</span></code> using the semantic version of the release.</li>
<li>After the CI build is complete and pushed to MyGet, push the package from MyGet to NuGet as the final release.</li>
<li>When NuGet has the new release, download the published package manually from NuGet.</li>
<li>Create a release page on the GitHub repository for the thing that just released. In that release page, add the release notes explaining the changes that have taken place. Upload the .nupkg you downloaded from NuGet so folks can get it if needed.</li>
</ul>
<p>We maintain the manual .nupkg download because there are some areas around the world that may have NuGet blocked or strongly filtered. This allows those areas to manually get the library if they need it and host their own repository.</p>
</div>
<div class="section" id="you-are-not-alone">
<h3>You Are Not Alone<a class="headerlink" href="#you-are-not-alone" title="Permalink to this headline">¶</a></h3>
<p>As an Autofac owner, you’re part of a small community of folks who have all committed to providing ongoing support for a popular package consumed by people all over the world. It’s a lot of responsibility and it can be overwhelming.</p>
<p>Just remember, you’re not alone. You’re part of the team. If you need help from one of the other owners, say so. At some point, someone else may need help from you. That’s great! Let’s work together to make this the best inversion-of-control container out there.</p>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Autofac Project. All rights reserved.
      
        <span class="commit">
          Revision <code>1a94e4a6</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: v5.2.0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
          <dd><a href="/en/stable/">stable</a></dd>
        
          <dd><a href="/en/v5.2.0/">v5.2.0</a></dd>
        
          <dd><a href="/en/v4.9.4/">v4.9.4</a></dd>
        
          <dd><a href="/en/v4.0.0/">v4.0.0</a></dd>
        
          <dd><a href="/en/v3.5.2/">v3.5.2</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/autofac/?fromdocs=autofac">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/autofac/?fromdocs=autofac">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>