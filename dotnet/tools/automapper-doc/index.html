

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>AutoMapper documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html#document-index">
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Getting-started">Getting Started Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#what-is-automapper">What is AutoMapper?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#why-use-automapper">Why use AutoMapper?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#how-do-i-use-automapper">How do I use AutoMapper?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#where-do-i-configure-automapper">Where do I configure AutoMapper?</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#how-do-i-test-my-mappings">How do I test my mappings?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Understanding-your-mapping">Understanding Your Mappings</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-The-MyGet-build">The MyGet Build</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#installing-the-package">Installing the Package</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Configuration">Configuration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#profile-instances">Profile Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#naming-conventions">Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#replacing-characters">Replacing characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#recognizing-pre-postfixes">Recognizing pre/postfixes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#global-property-field-filtering">Global property/field filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#configuring-visibility">Configuring visibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#configuration-compilation">Configuration compilation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Configuration-validation">Configuration Validation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#overriding-configuration-errors">Overriding configuration errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#selecting-members-to-validate">Selecting members to validate</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-validations">Custom validations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Dependency-injection">Dependency Injection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-api-s">Low level API-s</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#queryable-extensions">Queryable Extensions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Projection">Projection</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Nested-mappings">Nested Mappings</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Lists-and-arrays">Lists and Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#handling-null-collections">Handling null collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#polymorphic-element-types-in-collections">Polymorphic element types in collections</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Construction">Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Flattening">Flattening</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#includemembers">IncludeMembers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Reverse-Mapping-and-Unflattening">Reverse Mapping and Unflattening</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#customizing-reverse-mapping">Customizing reverse mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#includemembers">IncludeMembers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Mapping-inheritance">Mapping Inheritance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#runtime-polymorphism">Runtime polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#specifying-inheritance-in-derived-classes">Specifying inheritance in derived classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#as">As</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inheritance-mapping-priorities">Inheritance Mapping Priorities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Attribute-mapping">Attribute Mapping</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#type-map-configuration">Type Map configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#member-configuration">Member configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Dynamic-and-ExpandoObject-Mapping">Dynamic and ExpandoObject Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Open-Generics">Open Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Queryable-Extensions">Queryable Extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-instance-api">The instance API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#preventing-lazy-loading-select-n-1-problems">Preventing lazy loading/SELECT N+1 problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-projection">Custom projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-type-conversion">Custom Type Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-destination-type-constructors">Custom destination type constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#string-conversion">String conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#explicit-expansion">Explicit expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#aggregations">Aggregations</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parameterization">Parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#supported-mapping-options">Supported mapping options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Expression-Translation-(UseAsDataSource)">Expression Translation (UseAsDataSource)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#mapping-flattened-properties-to-navigation-properties">Mapping Flattened Properties to Navigation Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#supported-mapping-options">Supported Mapping options</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useasdatasource">UseAsDataSource</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Enum-Mapping">AutoMapper.Extensions.EnumMapping</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#default-convention">Default Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#reversemap-convention">ReverseMap Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#testing">Testing</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Extensibility</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Custom-type-converters">Custom Type Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Custom-value-resolvers">Custom Value Resolvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-constructor-methods">Custom constructor methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-resolved-value-is-mapped-to-the-destination-property">The resolved value is mapped to the destination property</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#customizing-the-source-value-supplied-to-the-resolver">Customizing the source value supplied to the resolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#passing-in-key-value-to-mapper">Passing in key-value to Mapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forpath">ForPath</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#resolvers-and-conditions">Resolvers and conditions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Conditional-mapping">Conditional Mapping</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#preconditions">Preconditions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Null-substitution">Null Substitution</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Value-converters">Value Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Value-transformers">Value Transformers</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-Before-and-after-map-actions">Before and After Map Action</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#using-imappingaction">Using <code class="docutils literal notranslate"><span class="pre">IMappingAction</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Upgrading</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-API-Changes">API Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-11.0-Upgrade-Guide">11.0 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#automapper-now-targets-net-standard-2-1-and-doesn-t-work-on-net-framework">AutoMapper now targets .Net Standard 2.1 and doesn’t work on .Net Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forallmaps-forallpropertymaps-advanced-and-other-missing-apis"><code class="docutils literal notranslate"><span class="pre">ForAllMaps</span></code>, <code class="docutils literal notranslate"><span class="pre">ForAllPropertyMaps</span></code>, <code class="docutils literal notranslate"><span class="pre">Advanced</span></code> and other “missing” APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mapping-into-existing-collections">Mapping <em>into</em> existing collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#createprojection"><code class="docutils literal notranslate"><span class="pre">CreateProjection</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#system-componentmodel-typeconverter-is-no-longer-supported"><code class="docutils literal notranslate"><span class="pre">System.ComponentModel.TypeConverter</span></code> is no longer supported</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generating-interface-proxies-is-disabled-by-default">Generating interface proxies is disabled by default</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#maptoattribute-and-ignoremapattribute-were-removed"><code class="docutils literal notranslate"><span class="pre">MapToAttribute</span></code> and <code class="docutils literal notranslate"><span class="pre">IgnoreMapAttribute</span></code> were removed</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#global-pre-and-postfixes-are-now-applied-in-all-maps">Global pre and postfixes are now applied in all maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forallothermembers-was-removed"><code class="docutils literal notranslate"><span class="pre">ForAllOtherMembers</span></code> was removed</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#c-indexers-item-property">C# Indexers (<code class="docutils literal notranslate"><span class="pre">Item</span></code> property)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#configuration-performance">Configuration performance</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-10.0-Upgrade-Guide">10.0 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#all-collections-are-mapped-by-default-even-if-they-have-no-setter">All collections are mapped by default, even if they have no setter</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#matching-constructor-parameters-will-be-mapped-from-the-source-even-if-they-are-optional">Matching constructor parameters will be mapped from the source, even if they are optional</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#context-mapper-map-overloads-that-receive-a-context-were-removed"><code class="docutils literal notranslate"><span class="pre">Context.Mapper.Map</span></code> overloads that receive a context were removed</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#usedestinationvalue-is-now-inherited-by-default"><code class="docutils literal notranslate"><span class="pre">UseDestinationValue</span></code> is now inherited by default</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#allownull-allows-you-to-override-per-member-allownulldestinationvalues-and-allownullcollections"><code class="docutils literal notranslate"><span class="pre">AllowNull</span></code> allows you to override per member <code class="docutils literal notranslate"><span class="pre">AllowNullDestinationValues</span></code> and <code class="docutils literal notranslate"><span class="pre">AllowNullCollections</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-resolutioncontext-no-longer-has-a-public-constructor">The <code class="docutils literal notranslate"><span class="pre">ResolutionContext</span></code> no longer has a public constructor</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#mapping-from-dynamic-in-net-4-6-1">Mapping from <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> in .NET 4.6.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#source-validation">Source validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#maxdepth"><code class="docutils literal notranslate"><span class="pre">MaxDepth</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#string-based-mapfrom-s-are-reversed-now-also-applies-to-attribute-mapping">String based <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>-s are reversed now, also applies to attribute mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#reversemap-will-also-reverse-the-naming-conventions"><code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> will also reverse the naming conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-9.0-Upgrade-Guide">9.0 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-static-api-was-removed">The static API was removed</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#automapper-no-longer-creates-maps-automatically-createmissingtypemaps-and-conventions">AutoMapper no longer creates maps automatically (CreateMissingTypeMaps and conventions)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-8.1.1-Upgrade-Guide">8.1.1 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#automapper-no-longer-creates-maps-automatically-by-default">AutoMapper no longer creates maps automatically by default</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-8.0-Upgrade-Guide">8.0 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#projectusing">ProjectUsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#constructprojectionusing">ConstructProjectionUsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#resolveusing">ResolveUsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#usevalue">UseValue</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forsourcemember-ignore">ForSourceMember Ignore</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#generic-maps-validation">Generic maps validation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-5.0-Upgrade-Guide">5.0 Upgrade Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#initialization">Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#profiles">Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ignoreallnonexisting-extension">IgnoreAllNonExisting extension</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#resolution-context-things">Resolution Context things</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#value-resolvers">Value resolvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#type-converters">Type converters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#circular-references">Circular references</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#usedestinationvalue">UseDestinationValue</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">AutoMapper</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>AutoMapper  documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/AutoMapper/AutoMapper/blob/master/docs/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="automapper">
<h1>AutoMapper<a class="headerlink" href="#automapper" title="Permalink to this headline">¶</a></h1>
<p>A convention-based object-object mapper.</p>
<p>AutoMapper uses a fluent configuration API to define an object-object
mapping strategy. AutoMapper uses a convention-based matching algorithm
to match up source to destination values. AutoMapper is geared towards
model projection scenarios to flatten complex object models to DTOs and
other simple objects, whose design is better suited for serialization,
communication, messaging, or simply an anti-corruption layer between the
domain and application layer.</p>
<p>AutoMapper supports the following platforms:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">.NET Standard 2.1+</a></li>
</ul>
<p>New to AutoMapper? Check out the <a class="reference internal" href="index.html#document-Getting-started"><span class="doc">Getting Started Guide</span></a> page first.</p>
<div class="toctree-wrapper compound">
<span id="document-Getting-started"></span><div class="section" id="getting-started-guide">
<h2>Getting Started Guide<a class="headerlink" href="#getting-started-guide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-automapper">
<h3>What is AutoMapper?<a class="headerlink" href="#what-is-automapper" title="Permalink to this headline">¶</a></h3>
<p>AutoMapper is an object-object mapper.  Object-object mapping works by transforming an input object of one type into an output object of a different type.  What makes AutoMapper interesting is that it provides some interesting conventions to take the dirty work out of figuring out how to map type A to type B.  As long as type B follows AutoMapper’s established convention, almost zero configuration is needed to map two types.</p>
</div>
<div class="section" id="why-use-automapper">
<h3>Why use AutoMapper?<a class="headerlink" href="#why-use-automapper" title="Permalink to this headline">¶</a></h3>
<p>Mapping code is boring.  Testing mapping code is even more boring.  AutoMapper provides simple configuration of types, as well as simple testing of mappings.  The real question may be “why use object-object mapping?”  Mapping can occur in many places in an application, but mostly in the boundaries between layers, such as between the UI/Domain layers, or Service/Domain layers.  Concerns of one layer often conflict with concerns in another, so object-object mapping leads to segregated models, where concerns for each layer can affect only types in that layer.</p>
</div>
<div class="section" id="how-do-i-use-automapper">
<h3>How do I use AutoMapper?<a class="headerlink" href="#how-do-i-use-automapper" title="Permalink to this headline">¶</a></h3>
<p>First, you need both a source and destination type to work with.  The destination type’s design can be influenced by the layer in which it lives, but AutoMapper works best as long as the names of the members match up to the source type’s members.  If you have a source member called “FirstName”, this will automatically be mapped to a destination member with the name “FirstName”.  AutoMapper also supports <a class="reference external" href="Flattening.html">Flattening</a>.</p>
<p>AutoMapper will ignore null reference exceptions when mapping your source to your target. This is by design. If you don’t like this approach, you can combine AutoMapper’s approach with <a class="reference external" href="Custom-value-resolvers.html">custom value resolvers</a> if needed.</p>
<p>Once you have your types you can create a map for the two types using a <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> and CreateMap. You only need one <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> instance typically per AppDomain and should be instantiated during startup. More examples of initial setup can be seen in <a class="reference external" href="Setup.html">Setup</a>.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;());</span>
</pre></div>
</div>
<p>The type on the left is the source type, and the type on the right is the destination type.  To perform a mapping, call one of the <code class="docutils literal notranslate"><span class="pre">Map</span></code> overloads:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="n">config</span><span class="p">.</span><span class="n">CreateMapper</span><span class="p">();</span>
<span class="c1">// or</span>
<span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mapper</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="n">OrderDto</span> <span class="n">dto</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">order</span><span class="p">);</span>
</pre></div>
</div>
<p>Most applications can use dependency injection to inject the created <code class="docutils literal notranslate"><span class="pre">IMapper</span></code> instance.</p>
<p>AutoMapper also has non-generic versions of these methods, for those cases where you might not know the type at compile time.</p>
</div>
<div class="section" id="where-do-i-configure-automapper">
<h3>Where do I configure AutoMapper?<a class="headerlink" href="#where-do-i-configure-automapper" title="Permalink to this headline">¶</a></h3>
<p>Configuration should only happen once per AppDomain.  That means the best place to put the configuration code is in application startup, such as the Global.asax file for ASP.NET applications.  Typically, the configuration bootstrapper class is in its own class, and this bootstrapper class is called from the startup method. The bootstrapper class should construct a <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> object to configure the type maps.</p>
<p>For ASP.NET Core the <a class="reference external" href="Dependency-injection.html#asp-net-core">Dependency Injection</a> article shows how to configure AutoMapper in your application.</p>
</div>
<div class="section" id="how-do-i-test-my-mappings">
<h3>How do I test my mappings?<a class="headerlink" href="#how-do-i-test-my-mappings" title="Permalink to this headline">¶</a></h3>
<p>To test your mappings, you need to create a test that does two things:</p>
<ul class="simple">
<li>Call your bootstrapper class to create all the mappings</li>
<li>Call MapperConfiguration.AssertConfigurationIsValid</li>
</ul>
<p>Here’s an example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">AutoMapperConfiguration</span><span class="p">.</span><span class="n">Configure</span><span class="p">();</span>

<span class="n">config</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<span id="document-Understanding-your-mapping"></span><div class="section" id="understanding-your-mappings">
<h2>Understanding Your Mappings<a class="headerlink" href="#understanding-your-mappings" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper creates an execution plan for your mapping. That execution plan can be viewed as <a class="reference external" href="https://msdn.microsoft.com/en-us/library/mt654263.aspx?f=255&amp;MSPPError=-2147217396">an expression tree</a> during debugging. You can get a better view of the resulting code by installing <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-1232914.ReadableExpressionsVisualizers">the ReadableExpressions VS extension</a>. If you need to see the code outside VS, you can use <a class="reference external" href="https://www.nuget.org/packages/AgileObjects.ReadableExpressions">the ReadableExpressions package directly</a>. <a class="reference external" href="https://dotnetfiddle.net/aJYTGZ">This DotNetFiddle</a> has a live demo  using the NuGet package, and <a class="reference external" href="https://agileobjects.co.uk/view-automapper-execution-plan-readableexpressions">this article</a> describes using the VS extension.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">&gt;());</span>
<span class="kt">var</span> <span class="n">executionPlan</span> <span class="p">=</span> <span class="n">configuration</span><span class="p">.</span><span class="n">BuildExecutionPlan</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Bar</span><span class="p">));</span>
</pre></div>
</div>
<p>Be sure to remove all such code before release.</p>
<p>For ProjectTo, you need to inspect <code class="docutils literal notranslate"><span class="pre">IQueryable.Expression</span></code>.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">expression</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Entities</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">Dto</span><span class="p">&gt;().</span><span class="n">Expression</span><span class="p">;</span>
</pre></div>
</div>
</div>
<span id="document-The-MyGet-build"></span><div class="section" id="the-myget-build">
<h2>The MyGet Build<a class="headerlink" href="#the-myget-build" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper uses MyGet to publish development builds based on the master branch. This means that the MyGet build sometimes contains fixes that are not available in the current NuGet package. Please try the latest MyGet build before reporting issues, in case your issue has already been fixed but not released.</p>
<p>The AutoMapper MyGet gallery is available <a class="reference external" href="https://myget.org/feed/automapperdev/package/nuget/AutoMapper">here</a>. Be sure to include prereleases.</p>
<div class="section" id="installing-the-package">
<h3>Installing the Package<a class="headerlink" href="#installing-the-package" title="Permalink to this headline">¶</a></h3>
<p>If you want to install the latest MyGet package into a project, you can use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Install</span><span class="o">-</span><span class="n">Package</span> <span class="n">AutoMapper</span> <span class="o">-</span><span class="n">Source</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">myget</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">F</span><span class="o">/</span><span class="n">automapperdev</span><span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">v3</span><span class="o">/</span><span class="n">index</span><span class="o">.</span><span class="n">json</span> <span class="o">-</span><span class="n">IncludePrerelease</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound" id="feature-docs">
<span id="document-Configuration"></span><div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Create a <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> instance and initialize configuration via the constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AddProfile</span><span class="p">&lt;</span><span class="n">FooProfile</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> instance can be stored statically, in a static field or in a dependency injection container. Once created it cannot be changed/modified.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AddProfile</span><span class="p">&lt;</span><span class="n">FooProfile</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Starting with 9.0, the static API is no longer available.</p>
<div class="section" id="profile-instances">
<h3>Profile Instances<a class="headerlink" href="#profile-instances" title="Permalink to this headline">¶</a></h3>
<p>A good way to organize your mapping configurations is with profiles.
Create classes that inherit from <code class="docutils literal notranslate"><span class="pre">Profile</span></code> and put the configuration in the constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is the approach starting with version 5</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrganizationProfile</span> <span class="p">:</span> <span class="n">Profile</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">OrganizationProfile</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">FooDto</span><span class="p">&gt;();</span>
		<span class="c1">// Use CreateMap... Etc.. here (Profile methods are the same as configuration methods)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// How it was done in 4.x - as of 5.0 this is obsolete:</span>
<span class="c1">// public class OrganizationProfile : Profile</span>
<span class="c1">// {</span>
<span class="c1">//     protected override void Configure()</span>
<span class="c1">//     {</span>
<span class="c1">//         CreateMap&lt;Foo, FooDto&gt;();</span>
<span class="c1">//     }</span>
<span class="c1">// }</span>
</pre></div>
</div>
<p>In earlier versions the <code class="docutils literal notranslate"><span class="pre">Configure</span></code> method was used instead of a constructor.
As of version 5, <code class="docutils literal notranslate"><span class="pre">Configure()</span></code> is obsolete. It will be removed in 6.0.</p>
<p>Configuration inside a profile only applies to maps inside the profile. Configuration applied to the root configuration applies to <em>all</em> maps created.</p>
<div class="section" id="assembly-scanning-for-auto-configuration">
<h4>Assembly Scanning for auto configuration<a class="headerlink" href="#assembly-scanning-for-auto-configuration" title="Permalink to this headline">¶</a></h4>
<p>Profiles can be added to the main mapper configuration in a number of ways, either directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="o">.</span><span class="n">AddProfile</span><span class="o">&lt;</span><span class="n">OrganizationProfile</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">cfg</span><span class="o">.</span><span class="n">AddProfile</span><span class="p">(</span><span class="n">new</span> <span class="n">OrganizationProfile</span><span class="p">());</span>
</pre></div>
</div>
<p>or by automatically scanning for profiles:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Scan for all profiles in an assembly</span>
<span class="c1">// ... using instance approach:</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="n">myAssembly</span><span class="p">);</span>
<span class="p">});</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="n">myAssembly</span><span class="p">));</span>

<span class="c1">// Can also use assembly names:</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="k">new</span> <span class="p">[]</span> <span class="p">{</span>
        <span class="s">&quot;Foo.UI&quot;</span><span class="p">,</span>
        <span class="s">&quot;Foo.Core&quot;</span>
    <span class="p">});</span>
<span class="p">);</span>

<span class="c1">// Or marker types for assemblies:</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="k">new</span> <span class="p">[]</span> <span class="p">{</span>
        <span class="k">typeof</span><span class="p">(</span><span class="n">HomeController</span><span class="p">),</span>
        <span class="k">typeof</span><span class="p">(</span><span class="n">Entity</span><span class="p">)</span>
    <span class="p">});</span>
<span class="p">);</span>
</pre></div>
</div>
<p>AutoMapper will scan the designated assemblies for classes inheriting from Profile and add them to the configuration.</p>
</div>
</div>
<div class="section" id="naming-conventions">
<h3>Naming Conventions<a class="headerlink" href="#naming-conventions" title="Permalink to this headline">¶</a></h3>
<p>You can set the source and destination naming conventions</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">SourceMemberNamingConvention</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LowerUnderscoreNamingConvention</span><span class="p">();</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">DestinationMemberNamingConvention</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PascalCaseNamingConvention</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>This will map the following properties to each other:
<code class="docutils literal notranslate"><span class="pre">property_name</span> <span class="pre">-&gt;</span> <span class="pre">PropertyName</span></code></p>
<p>You can also set this at a per profile level</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrganizationProfile</span> <span class="p">:</span> <span class="n">Profile</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">OrganizationProfile</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">SourceMemberNamingConvention</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LowerUnderscoreNamingConvention</span><span class="p">();</span>
    <span class="n">DestinationMemberNamingConvention</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PascalCaseNamingConvention</span><span class="p">();</span>
    <span class="c1">//Put your CreateMap... Etc.. here</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you don’t need a naming convention, you can use the <code class="docutils literal notranslate"><span class="pre">ExactMatchNamingConvention</span></code>.</p>
</div>
<div class="section" id="replacing-characters">
<h3>Replacing characters<a class="headerlink" href="#replacing-characters" title="Permalink to this headline">¶</a></h3>
<p>You can also replace individual characters or entire words in source members during member name matching:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Ävíator</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">SubAirlinaFlight</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Aviator</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">SubAirlineFlight</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We want to replace the individual characters, and perhaps translate a word:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">ReplaceMemberName</span><span class="p">(</span><span class="s">&quot;Ä&quot;</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">);</span>
    <span class="n">c</span><span class="p">.</span><span class="n">ReplaceMemberName</span><span class="p">(</span><span class="s">&quot;í&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">);</span>
    <span class="n">c</span><span class="p">.</span><span class="n">ReplaceMemberName</span><span class="p">(</span><span class="s">&quot;Airlina&quot;</span><span class="p">,</span> <span class="s">&quot;Airline&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="recognizing-pre-postfixes">
<h3>Recognizing pre/postfixes<a class="headerlink" href="#recognizing-pre-postfixes" title="Permalink to this headline">¶</a></h3>
<p>Sometimes your source/destination properties will have common pre/postfixes that cause you to have to do a bunch of custom member mappings because the names don’t match up. To address this, you can recognize pre/postfixes:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">frmValue</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">frmValue2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Dest</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">RecognizePrefixes</span><span class="p">(</span><span class="s">&quot;frm&quot;</span><span class="p">);</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;();</span>
<span class="p">});</span>
<span class="n">configuration</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>
</pre></div>
</div>
<p>By default AutoMapper recognizes the prefix “Get”, if you need to clear the prefix:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">ClearPrefixes</span><span class="p">();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">RecognizePrefixes</span><span class="p">(</span><span class="s">&quot;tmp&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="global-property-field-filtering">
<h3>Global property/field filtering<a class="headerlink" href="#global-property-field-filtering" title="Permalink to this headline">¶</a></h3>
<p>By default, AutoMapper tries to map every public property/field. You can filter out properties/fields with the property/field filters:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
<span class="p">{</span>
	<span class="c1">// don&#39;t map any fields</span>
	<span class="n">cfg</span><span class="p">.</span><span class="n">ShouldMapField</span> <span class="p">=</span> <span class="n">fi</span> <span class="p">=&gt;</span> <span class="k">false</span><span class="p">;</span>

	<span class="c1">// map properties with a public or private getter</span>
	<span class="n">cfg</span><span class="p">.</span><span class="n">ShouldMapProperty</span> <span class="p">=</span> <span class="n">pi</span> <span class="p">=&gt;</span>
		<span class="n">pi</span><span class="p">.</span><span class="n">GetMethod</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">GetMethod</span><span class="p">.</span><span class="n">IsPublic</span> <span class="p">||</span> <span class="n">pi</span><span class="p">.</span><span class="n">GetMethod</span><span class="p">.</span><span class="n">IsPrivate</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="configuring-visibility">
<h3>Configuring visibility<a class="headerlink" href="#configuring-visibility" title="Permalink to this headline">¶</a></h3>
<p>By default, AutoMapper only recognizes public members. It can map to private setters, but will skip internal/private methods and properties if the entire property is private/internal. To instruct AutoMapper to recognize members with other visibilities, override the default filters ShouldMapField and/or ShouldMapProperty :</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// map properties with public or internal getters</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">ShouldMapProperty</span> <span class="p">=</span> <span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">GetMethod</span><span class="p">.</span><span class="n">IsPublic</span> <span class="p">||</span> <span class="n">p</span><span class="p">.</span><span class="n">GetMethod</span><span class="p">.</span><span class="n">IsAssembly</span><span class="p">;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Map configurations will now recognize internal/private members.</p>
</div>
<div class="section" id="configuration-compilation">
<h3>Configuration compilation<a class="headerlink" href="#configuration-compilation" title="Permalink to this headline">¶</a></h3>
<p>Because expression compilation can be a bit resource intensive, AutoMapper lazily compiles the type map plans on first map. However, this behavior is not always desirable, so you can tell AutoMapper to compile its mappings directly:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{});</span>
<span class="n">configuration</span><span class="p">.</span><span class="n">CompileMappings</span><span class="p">();</span>
</pre></div>
</div>
<p>For a few hundred mappings, this may take a couple of seconds. If it’s a lot more than that, you probably have some really big execution plans.</p>
<div class="section" id="long-compilation-times">
<h4>Long compilation times<a class="headerlink" href="#long-compilation-times" title="Permalink to this headline">¶</a></h4>
<p>Compilation times increase with the size of the execution plan and that depends on the number of properties and their complexity. Ideally, you would fix your model so you have many small DTOs, each for a particular use case. But you can also decrease the size of the execution plan without changing your classes.</p>
<p>You can set <code class="docutils literal notranslate"><span class="pre">MapAtRuntime</span></code> per member or <code class="docutils literal notranslate"><span class="pre">MaxExecutionPlanDepth</span></code> globally (the default is one, set it to zero).</p>
<p>These will reduce the size of the execution plan by replacing the execution plan for a child object with a method call. The compilation will be faster, but the mapping itself might be slower. Search the repo for more details and use a profiler to better understand the effect.
Avoiding <code class="docutils literal notranslate"><span class="pre">PreserveReferences</span></code> and <code class="docutils literal notranslate"><span class="pre">MaxDepth</span></code> also helps.</p>
</div>
</div>
</div>
<span id="document-Configuration-validation"></span><div class="section" id="configuration-validation">
<h2>Configuration Validation<a class="headerlink" href="#configuration-validation" title="Permalink to this headline">¶</a></h2>
<p>Hand-rolled mapping code, though tedious, has the advantage of being testable.  One of the inspirations behind AutoMapper was to eliminate not just the custom mapping code, but eliminate the need for manual testing.  Because the mapping from source to destination is convention-based, you will still need to test your configuration.</p>
<p>AutoMapper provides configuration testing in the form of the AssertConfigurationIsValid method.  Suppose we have slightly misconfigured our source and destination types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">SomeValue</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">SomeValuefff</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the Destination type, we probably fat-fingered the destination property.  Other typical issues are source member renames.  To test our configuration, we simply create a unit test that sets up the configuration and executes the AssertConfigurationIsValid method:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;());</span>

<span class="n">configuration</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>
</pre></div>
</div>
<p>Executing this code produces an AutoMapperConfigurationException, with a descriptive message.  AutoMapper checks to make sure that <em>every single</em> Destination type member has a corresponding type member on the source type.</p>
<div class="section" id="overriding-configuration-errors">
<h3>Overriding configuration errors<a class="headerlink" href="#overriding-configuration-errors" title="Permalink to this headline">¶</a></h3>
<p>To fix a configuration error (besides renaming the source/destination members), you have three choices for providing an alternate configuration:</p>
<ul class="simple">
<li><a class="reference external" href="Custom-value-resolvers.html">Custom Value Resolvers</a></li>
<li><a class="reference external" href="Projection.html">Projection</a></li>
<li>Use the Ignore() option</li>
</ul>
<p>With the third option, we have a member on the destination type that we will fill with alternative means, and not through the Map operation.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">SomeValuefff</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">Ignore</span><span class="p">())</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="selecting-members-to-validate">
<h3>Selecting members to validate<a class="headerlink" href="#selecting-members-to-validate" title="Permalink to this headline">¶</a></h3>
<p>By default, AutoMapper uses the destination type to validate members. It assumes that all destination members need to be mapped. To modify this behavior, use the <code class="docutils literal notranslate"><span class="pre">CreateMap</span></code> overload to specify which member list to validate against:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;(</span><span class="n">MemberList</span><span class="p">.</span><span class="n">Source</span><span class="p">);</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source2</span><span class="p">,</span> <span class="n">Destination2</span><span class="p">&gt;(</span><span class="n">MemberList</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
<span class="p">);</span>
</pre></div>
</div>
<p>To skip validation altogether for this map, use <code class="docutils literal notranslate"><span class="pre">MemberList.None</span></code>.</p>
</div>
<div class="section" id="custom-validations">
<h3>Custom validations<a class="headerlink" href="#custom-validations" title="Permalink to this headline">¶</a></h3>
<p>You can add custom validations through an extension point. See <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/blob/bdc0120497d192a2741183415543f6119f50a982/src/UnitTests/CustomValidations.cs#L42">here</a>.</p>
</div>
</div>
<span id="document-Dependency-injection"></span><div class="section" id="dependency-injection">
<h2>Dependency Injection<a class="headerlink" href="#dependency-injection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="asp-net-core">
<h4>ASP.NET Core<a class="headerlink" href="#asp-net-core" title="Permalink to this headline">¶</a></h4>
<p>There is a <a class="reference external" href="https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection/">NuGet package</a> to be used with the default injection mechanism described <a class="reference external" href="https://github.com/AutoMapper/AutoMapper.Extensions.Microsoft.DependencyInjection">here</a> and used in <a class="reference external" href="https://github.com/jbogard/ContosoUniversityCore/blob/master/src/ContosoUniversityCore/Startup.cs">this project</a>.</p>
<p>You define the configuration using <a class="reference external" href="Configuration.html#profile-instances">profiles</a>. And then you let AutoMapper know in what assemblies are those profiles defined by calling the <code class="docutils literal notranslate"><span class="pre">IServiceCollection</span></code> extension method <code class="docutils literal notranslate"><span class="pre">AddAutoMapper</span></code> at startup:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAutoMapper</span><span class="p">(</span><span class="n">profileAssembly1</span><span class="p">,</span> <span class="n">profileAssembly2</span> <span class="cm">/*, ...*/</span><span class="p">);</span>
</pre></div>
</div>
<p>or marker types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">.</span><span class="n">AddAutoMapper</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ProfileTypeFromAssembly1</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ProfileTypeFromAssembly2</span><span class="p">)</span> <span class="cm">/*, ...*/</span><span class="p">);</span>
</pre></div>
</div>
<p>Now you can inject AutoMapper at runtime into your services/controllers:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">EmployeesController</span> <span class="p">{</span>
	<span class="k">private</span> <span class="k">readonly</span> <span class="n">IMapper</span> <span class="n">_mapper</span><span class="p">;</span>

	<span class="k">public</span> <span class="nf">EmployeesController</span><span class="p">(</span><span class="n">IMapper</span> <span class="n">mapper</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_mapper</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">;</span>

	<span class="c1">// use _mapper.Map or _mapper.ProjectTo</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="autofac">
<h4>AutoFac<a class="headerlink" href="#autofac" title="Permalink to this headline">¶</a></h4>
<p>There is a third-party <a class="reference external" href="https://www.nuget.org/packages/AutoMapper.Contrib.Autofac.DependencyInjection">NuGet package</a> you might want to try.</p>
<p>Also, check <a class="reference external" href="https://dotnetfalcon.com/autofac-support-for-automapper/">this blog</a>.</p>
</div>
<div class="section" id="other-di-engines">
<h4><a class="reference external" href="https://github.com/AutoMapper/AutoMapper/wiki/DI-examples">Other DI engines</a><a class="headerlink" href="#other-di-engines" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<div class="section" id="low-level-api-s">
<h3>Low level API-s<a class="headerlink" href="#low-level-api-s" title="Permalink to this headline">¶</a></h3>
<p>AutoMapper supports the ability to construct <a class="reference external" href="Custom-value-resolvers.html">Custom Value Resolvers</a>, <a class="reference external" href="Custom-type-converters.html">Custom Type Converters</a>, and <a class="reference external" href="Value-converters.html">Value Converters</a> using static service location:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">ConstructServicesUsing</span><span class="p">(</span><span class="n">ObjectFactory</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">);</span>

    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Or dynamic service location, to be used in the case of instance-based containers (including child/nested containers):</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mapper</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="n">childContainer</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">15</span> <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="queryable-extensions">
<h3>Queryable Extensions<a class="headerlink" href="#queryable-extensions" title="Permalink to this headline">¶</a></h3>
<p>Starting with 8.0 you can use <code class="docutils literal notranslate"><span class="pre">IMapper.ProjectTo</span></code>. For older versions you need to pass the configuration to the extension method <code class="docutils literal notranslate"><span class="pre">IQueryable.ProjectTo&lt;T&gt;(IConfigurationProvider)</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code> is <a class="reference external" href="Queryable-Extensions.html#supported-mapping-options">more limited</a> than <code class="docutils literal notranslate"><span class="pre">Map</span></code>, as only what is allowed by the underlying LINQ provider is supported. That means you cannot use DI with value resolvers and converters as you can with <code class="docutils literal notranslate"><span class="pre">Map</span></code>.</p>
</div>
</div>
<span id="document-Projection"></span><div class="section" id="projection">
<h2>Projection<a class="headerlink" href="#projection" title="Permalink to this headline">¶</a></h2>
<p>Projection transforms a source to a destination beyond flattening the object model.  Without extra configuration, AutoMapper requires a flattened destination to match the source type’s naming structure.  When you want to project source values into a destination that does not exactly match the source structure, you must specify custom member mapping definitions.  For example, we might want to turn this source structure:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CalendarEvent</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="n">DateTime</span> <span class="n">Date</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Into something that works better for an input form on a web page:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CalendarEventForm</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="n">DateTime</span> <span class="n">EventDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">EventHour</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">EventMinute</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because the names of the destination properties do not exactly match the source property (<code class="docutils literal notranslate"><span class="pre">CalendarEvent.Date</span></code> would need to be <code class="docutils literal notranslate"><span class="pre">CalendarEventForm.EventDate</span></code>), we need to specify custom member mappings in our type map configuration:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Model</span>
<span class="kt">var</span> <span class="n">calendarEvent</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CalendarEvent</span>
<span class="p">{</span>
	<span class="n">Date</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">2008</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
	<span class="n">Title</span> <span class="p">=</span> <span class="s">&quot;Company Holiday Party&quot;</span>
<span class="p">};</span>

<span class="c1">// Configure AutoMapper</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">CalendarEvent</span><span class="p">,</span> <span class="n">CalendarEventForm</span><span class="p">&gt;()</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">EventDate</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Date</span><span class="p">.</span><span class="n">Date</span><span class="p">))</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">EventHour</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Date</span><span class="p">.</span><span class="n">Hour</span><span class="p">))</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">EventMinute</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Date</span><span class="p">.</span><span class="n">Minute</span><span class="p">)));</span>

<span class="c1">// Perform mapping</span>
<span class="n">CalendarEventForm</span> <span class="n">form</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">CalendarEvent</span><span class="p">,</span> <span class="n">CalendarEventForm</span><span class="p">&gt;(</span><span class="n">calendarEvent</span><span class="p">);</span>

<span class="n">form</span><span class="p">.</span><span class="n">EventDate</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">2008</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">15</span><span class="p">));</span>
<span class="n">form</span><span class="p">.</span><span class="n">EventHour</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">20</span><span class="p">);</span>
<span class="n">form</span><span class="p">.</span><span class="n">EventMinute</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
<span class="n">form</span><span class="p">.</span><span class="n">Title</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;Company Holiday Party&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Each custom member configuration uses an action delegate to configure each individual member.  In the above example, we used the <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> option to perform custom source-to-destination member mappings.  The <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> method takes a lambda expression as a parameter, which is then evaluated later during mapping.  The <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> expression can be any <code class="docutils literal notranslate"><span class="pre">Func&lt;TSource,</span> <span class="pre">object&gt;</span></code> lambda expression.</p>
</div>
<span id="document-Nested-mappings"></span><div class="section" id="nested-mappings">
<h2>Nested Mappings<a class="headerlink" href="#nested-mappings" title="Permalink to this headline">¶</a></h2>
<p>As the mapping engine executes the mapping, it can use one of a variety of methods to resolve a destination member value.  One of these methods is to use another type map, where the source member type and destination member type are also configured in the mapping configuration.  This allows us to not only flatten our source types, but create complex destination types as well.  For example, our source type might contain another complex type:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OuterSource</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="n">InnerSource</span> <span class="n">Inner</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">InnerSource</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">OtherValue</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We <em>could</em> simply flatten the OuterSource.Inner.OtherValue to one InnerOtherValue property, but we might also want to create a corresponding complex type for the Inner property:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OuterDest</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="n">InnerDest</span> <span class="n">Inner</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">InnerDest</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">OtherValue</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In that case, we would need to configure the additional source/destination type mappings:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OuterSource</span><span class="p">,</span> <span class="n">OuterDest</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">InnerSource</span><span class="p">,</span> <span class="n">InnerDest</span><span class="p">&gt;();</span>
<span class="p">});</span>
<span class="n">config</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OuterSource</span>
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span>
		<span class="n">Inner</span> <span class="p">=</span> <span class="k">new</span> <span class="n">InnerSource</span> <span class="p">{</span><span class="n">OtherValue</span> <span class="p">=</span> <span class="m">15</span><span class="p">}</span>
	<span class="p">};</span>
<span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="n">config</span><span class="p">.</span><span class="n">CreateMapper</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">OuterSource</span><span class="p">,</span> <span class="n">OuterDest</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">dest</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>
<span class="n">dest</span><span class="p">.</span><span class="n">Inner</span><span class="p">.</span><span class="n">ShouldNotBeNull</span><span class="p">();</span>
<span class="n">dest</span><span class="p">.</span><span class="n">Inner</span><span class="p">.</span><span class="n">OtherValue</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">15</span><span class="p">);</span>
</pre></div>
</div>
<p>A few things to note here:</p>
<ul class="simple">
<li>Order of configuring types does not matter</li>
<li>Call to Map does not need to specify any inner type mappings, only the type map to use for the source value passed in</li>
</ul>
<p>With both flattening and nested mappings, we can create a variety of destination shapes to suit whatever our needs may be.</p>
</div>
<span id="document-Lists-and-arrays"></span><div class="section" id="lists-and-arrays">
<h2>Lists and Arrays<a class="headerlink" href="#lists-and-arrays" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper only requires configuration of element types, not of any array or list type that might be used.  For example, we might have a simple source and destination type:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All the basic generic collection types are supported:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;());</span>

<span class="kt">var</span> <span class="n">sources</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span>
	<span class="p">{</span>
		<span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">5</span> <span class="p">},</span>
		<span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">6</span> <span class="p">},</span>
		<span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">7</span> <span class="p">}</span>
	<span class="p">};</span>

<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;</span> <span class="n">ienumerableDest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">[],</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;&gt;(</span><span class="n">sources</span><span class="p">);</span>
<span class="n">ICollection</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;</span> <span class="n">icollectionDest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">[],</span> <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;&gt;(</span><span class="n">sources</span><span class="p">);</span>
<span class="n">IList</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;</span> <span class="n">ilistDest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">[],</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;&gt;(</span><span class="n">sources</span><span class="p">);</span>
<span class="n">List</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;</span> <span class="n">listDest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">[],</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;&gt;(</span><span class="n">sources</span><span class="p">);</span>
<span class="n">Destination</span><span class="p">[]</span> <span class="n">arrayDest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">[],</span> <span class="n">Destination</span><span class="p">[]&gt;(</span><span class="n">sources</span><span class="p">);</span>
</pre></div>
</div>
<p>To be specific, the source collection types supported include:</p>
<ul class="simple">
<li>IEnumerable</li>
<li>IEnumerable&lt;T&gt;</li>
<li>ICollection</li>
<li>ICollection&lt;T&gt;</li>
<li>IList</li>
<li>IList&lt;T&gt;</li>
<li>List&lt;T&gt;</li>
<li>Arrays</li>
</ul>
<p>For the non-generic enumerable types, only unmapped, assignable types are supported, as AutoMapper will be unable to “guess” what types you’re trying to map.  As shown in the example above, it’s not necessary to explicitly configure list types, only their member types.</p>
<p>When mapping to an existing collection, the destination collection is cleared first. If this is not what you want, take a look at <a class="reference external" href="https://github.com/AutoMapper/AutoMapper.Collection">AutoMapper.Collection</a>.</p>
<div class="section" id="handling-null-collections">
<h3>Handling null collections<a class="headerlink" href="#handling-null-collections" title="Permalink to this headline">¶</a></h3>
<p>When mapping a collection property, if the source value is null AutoMapper will map the destination field to an empty collection rather than setting the destination value to null. This aligns with the behavior of Entity Framework and Framework Design Guidelines that believe C# references, arrays, lists, collections, dictionaries and IEnumerables should NEVER be null, ever.</p>
<p>This behavior can be changed by setting the <code class="docutils literal notranslate"><span class="pre">AllowNullCollections</span></code> property to true when configuring the mapper.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">AllowNullCollections</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The setting can be applied globally and can be overridden per profile and per member with <code class="docutils literal notranslate"><span class="pre">AllowNull</span></code> and <code class="docutils literal notranslate"><span class="pre">DoNotAllowNull</span></code>.</p>
</div>
<div class="section" id="polymorphic-element-types-in-collections">
<h3>Polymorphic element types in collections<a class="headerlink" href="#polymorphic-element-types-in-collections" title="Permalink to this headline">¶</a></h3>
<p>Many times, we might have a hierarchy of types in both our source and destination types.  AutoMapper supports polymorphic arrays and collections, such that derived source/destination types are used if found.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ParentSource</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ChildSource</span> <span class="p">:</span> <span class="n">ParentSource</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ParentDestination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ChildDestination</span> <span class="p">:</span> <span class="n">ParentDestination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>AutoMapper still requires explicit configuration for child mappings, as AutoMapper cannot “guess” which specific child destination mapping to use.  Here is an example of the above types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">c</span><span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">ParentSource</span><span class="p">,</span> <span class="n">ParentDestination</span><span class="p">&gt;()</span>
	     <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">ChildSource</span><span class="p">,</span> <span class="n">ChildDestination</span><span class="p">&gt;();</span>
    <span class="n">c</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">ChildSource</span><span class="p">,</span> <span class="n">ChildDestination</span><span class="p">&gt;();</span>
<span class="p">});</span>

<span class="kt">var</span> <span class="n">sources</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span>
	<span class="p">{</span>
		<span class="k">new</span> <span class="nf">ParentSource</span><span class="p">(),</span>
		<span class="k">new</span> <span class="nf">ChildSource</span><span class="p">(),</span>
		<span class="k">new</span> <span class="nf">ParentSource</span><span class="p">()</span>
	<span class="p">};</span>

<span class="kt">var</span> <span class="n">destinations</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">ParentSource</span><span class="p">[],</span> <span class="n">ParentDestination</span><span class="p">[]&gt;(</span><span class="n">sources</span><span class="p">);</span>

<span class="n">destinations</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">ShouldBeInstanceOf</span><span class="p">&lt;</span><span class="n">ParentDestination</span><span class="p">&gt;();</span>
<span class="n">destinations</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">ShouldBeInstanceOf</span><span class="p">&lt;</span><span class="n">ChildDestination</span><span class="p">&gt;();</span>
<span class="n">destinations</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">ShouldBeInstanceOf</span><span class="p">&lt;</span><span class="n">ParentDestination</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
</div>
<span id="document-Construction"></span><div class="section" id="construction">
<h2>Construction<a class="headerlink" href="#construction" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper can map to destination constructors based on source members:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SourceDto</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">SourceDto</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">_value</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">SourceDto</span><span class="p">&gt;());</span>
</pre></div>
</div>
<p>If the destination constructor parameter names don’t match, you can modify them at config time:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SourceDto</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">SourceDto</span><span class="p">(</span><span class="kt">int</span> <span class="n">valueParamSomeOtherName</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_value</span> <span class="p">=</span> <span class="n">valueParamSomeOtherName</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">_value</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">SourceDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForCtorParam</span><span class="p">(</span><span class="s">&quot;valueParamSomeOtherName&quot;</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Value</span><span class="p">))</span>
<span class="p">);</span>
</pre></div>
</div>
<p>This works for both LINQ projections and in-memory mapping.</p>
<p>You can also disable constructor mapping:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">DisableConstructorMapping</span><span class="p">());</span>
</pre></div>
</div>
<p>You can configure which constructors are considered for the destination object:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// don&#39;t map private constructors</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">ShouldUseConstructor</span> <span class="p">=</span> <span class="n">ci</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">ci</span><span class="p">.</span><span class="n">IsPrivate</span><span class="p">);</span>
</pre></div>
</div>
</div>
<span id="document-Flattening"></span><div class="section" id="flattening">
<h2>Flattening<a class="headerlink" href="#flattening" title="Permalink to this headline">¶</a></h2>
<p>One of the common usages of object-object mapping is to take a complex object model and flatten it to a simpler model.  You can take a complex model such as:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Order</span>
<span class="p">{</span>
	<span class="k">private</span> <span class="k">readonly</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">OrderLineItem</span><span class="p">&gt;</span> <span class="n">_orderLineItems</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">OrderLineItem</span><span class="p">&gt;();</span>

	<span class="k">public</span> <span class="n">Customer</span> <span class="n">Customer</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">OrderLineItem</span><span class="p">[]</span> <span class="nf">GetOrderLineItems</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_orderLineItems</span><span class="p">.</span><span class="n">ToArray</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">void</span> <span class="nf">AddOrderLineItem</span><span class="p">(</span><span class="n">Product</span> <span class="n">product</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">_orderLineItems</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">OrderLineItem</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">decimal</span> <span class="nf">GetTotal</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_orderLineItems</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">li</span> <span class="p">=&gt;</span> <span class="n">li</span><span class="p">.</span><span class="n">GetTotal</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Product</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">decimal</span> <span class="n">Price</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderLineItem</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">OrderLineItem</span><span class="p">(</span><span class="n">Product</span> <span class="n">product</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Product</span> <span class="p">=</span> <span class="n">product</span><span class="p">;</span>
		<span class="n">Quantity</span> <span class="p">=</span> <span class="n">quantity</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Product</span> <span class="n">Product</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Quantity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;}</span>

	<span class="k">public</span> <span class="kt">decimal</span> <span class="nf">GetTotal</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Quantity</span><span class="p">*</span><span class="n">Product</span><span class="p">.</span><span class="n">Price</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Customer</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We want to flatten this complex Order object into a simpler OrderDto that contains only the data needed for a certain scenario:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">CustomerName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When you configure a source/destination type pair in AutoMapper, the configurator attempts to match properties and methods on the source type to properties on the destination type.  If for any property on the destination type a property, method, or a method prefixed with “Get” does not exist on the source type, AutoMapper splits the destination member name into individual words (by PascalCase conventions).</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Complex model</span>

<span class="kt">var</span> <span class="n">customer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Customer</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;George Costanza&quot;</span>
	<span class="p">};</span>
<span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Order</span>
	<span class="p">{</span>
		<span class="n">Customer</span> <span class="p">=</span> <span class="n">customer</span>
	<span class="p">};</span>
<span class="kt">var</span> <span class="n">bosco</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Product</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;Bosco&quot;</span><span class="p">,</span>
		<span class="n">Price</span> <span class="p">=</span> <span class="m">4.99</span><span class="n">m</span>
	<span class="p">};</span>
<span class="n">order</span><span class="p">.</span><span class="n">AddOrderLineItem</span><span class="p">(</span><span class="n">bosco</span><span class="p">,</span> <span class="m">15</span><span class="p">);</span>

<span class="c1">// Configure AutoMapper</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;());</span>

<span class="c1">// Perform mapping</span>

<span class="n">OrderDto</span> <span class="n">dto</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">order</span><span class="p">);</span>

<span class="n">dto</span><span class="p">.</span><span class="n">CustomerName</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;George Costanza&quot;</span><span class="p">);</span>
<span class="n">dto</span><span class="p">.</span><span class="n">Total</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">74.85</span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>We configured the type map in AutoMapper with the CreateMap method.  AutoMapper can only map type pairs it knows about, so we have explicitly register the source/destination type pair with CreateMap.  To perform the mapping, we use the Map method.</p>
<p>On the OrderDto type, the Total property matched to the GetTotal() method on Order.  The CustomerName property matched to the Customer.Name property on Order.  As long as we name our destination properties appropriately, we do not need to configure individual property matching.</p>
<p>If you want to disable this behavior, you can use the <code class="docutils literal notranslate"><span class="pre">ExactMatchNamingConvention</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="o">.</span><span class="n">DestinationMemberNamingConvention</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ExactMatchNamingConvention</span><span class="p">();</span>
</pre></div>
</div>
<div class="section" id="includemembers">
<h3>IncludeMembers<a class="headerlink" href="#includemembers" title="Permalink to this headline">¶</a></h3>
<p>If you need more control when flattening, you can use IncludeMembers. You can map members of a child object to the destination object when you already have a map from the child type to the destination type (unlike the classic flattening that doesn’t require a map for the child type).</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">InnerSource</span> <span class="n">InnerSource</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">OtherInnerSource</span> <span class="n">OtherInnerSource</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">InnerSource</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">OtherInnerSource</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;().</span><span class="n">IncludeMembers</span><span class="p">(</span><span class="n">s</span><span class="p">=&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">InnerSource</span><span class="p">,</span> <span class="n">s</span><span class="p">=&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">OtherInnerSource</span><span class="p">);</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">InnerSource</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;(</span><span class="n">MemberList</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OtherInnerSource</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;();</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">InnerSource</span> <span class="p">=</span> <span class="k">new</span> <span class="n">InnerSource</span><span class="p">{</span> <span class="n">Description</span> <span class="p">=</span> <span class="s">&quot;description&quot;</span> <span class="p">},</span> 
                          <span class="n">OtherInnerSource</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OtherInnerSource</span><span class="p">{</span> <span class="n">Title</span> <span class="p">=</span> <span class="s">&quot;title&quot;</span> <span class="p">}</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">destination</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Destination</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>
<span class="n">destination</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">ShouldBe</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">);</span>
<span class="n">destination</span><span class="p">.</span><span class="n">Description</span><span class="p">.</span><span class="n">ShouldBe</span><span class="p">(</span><span class="s">&quot;description&quot;</span><span class="p">);</span>
<span class="n">destination</span><span class="p">.</span><span class="n">Title</span><span class="p">.</span><span class="n">ShouldBe</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>So this allows you to reuse the configuration in the existing map for the child types <code class="docutils literal notranslate"><span class="pre">InnerSource</span></code> and <code class="docutils literal notranslate"><span class="pre">OtherInnerSource</span></code> when mapping the parent types <code class="docutils literal notranslate"><span class="pre">Source</span></code> and <code class="docutils literal notranslate"><span class="pre">Destination</span></code>. It works in a similar way to <a class="reference external" href="Mapping-inheritance.html">mapping inheritance</a>, but it uses composition, not inheritance.</p>
<p>The order of the parameters in the <code class="docutils literal notranslate"><span class="pre">IncludeMembers</span></code> call is relevant. When mapping a destination member, the first match wins, starting with the source object itself and then with the included child objects in the order you specified. So in the example above, <code class="docutils literal notranslate"><span class="pre">Name</span></code> is mapped from the source object itself and <code class="docutils literal notranslate"><span class="pre">Description</span></code> from <code class="docutils literal notranslate"><span class="pre">InnerSource</span></code> because it’s the first match.</p>
<p>Note that this matching is static, it happens at configuration time, not at <code class="docutils literal notranslate"><span class="pre">Map</span></code> time, so the runtime types of the child objects are not considered.</p>
<p>IncludeMembers integrates with <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code>. An included member will be reversed to</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">ForPath</span><span class="p">(</span><span class="n">destination</span> <span class="p">=&gt;</span> <span class="n">destination</span><span class="p">.</span><span class="n">IncludedMember</span><span class="p">,</span> <span class="n">member</span> <span class="p">=&gt;</span> <span class="n">member</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">source</span> <span class="p">=&gt;</span> <span class="n">source</span><span class="p">))</span>
</pre></div>
</div>
<p>and the other way around. If that’s not what you want, you can avoid <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> (explicitly create the reverse map) or you can override the default settings (using <code class="docutils literal notranslate"><span class="pre">Ignore</span></code> or <code class="docutils literal notranslate"><span class="pre">IncludeMembers</span></code> without parameters respectively).</p>
<p>For details, check <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/blob/master/src/UnitTests/IMappingExpression/IncludeMembers.cs">the tests</a>.</p>
</div>
</div>
<span id="document-Reverse-Mapping-and-Unflattening"></span><div class="section" id="reverse-mapping-and-unflattening">
<h2>Reverse Mapping and Unflattening<a class="headerlink" href="#reverse-mapping-and-unflattening" title="Permalink to this headline">¶</a></h2>
<p>Starting with 6.1.0, AutoMapper now supports richer reverse mapping support. Given our entities:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Order</span> <span class="p">{</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="n">Customer</span> <span class="n">Customer</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Customer</span> <span class="p">{</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can flatten this into a DTO:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">CustomerName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can map both directions, including unflattening:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
     <span class="p">.</span><span class="n">ReverseMap</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>By calling <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code>, AutoMapper creates a reverse mapping configuration that includes unflattening:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">customer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Customer</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;Bob&quot;</span>
<span class="p">};</span>

<span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Order</span> <span class="p">{</span>
  <span class="n">Customer</span> <span class="p">=</span> <span class="n">customer</span><span class="p">,</span>
  <span class="n">Total</span> <span class="p">=</span> <span class="m">15.8</span><span class="n">m</span>
<span class="p">};</span>

<span class="kt">var</span> <span class="n">orderDto</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">order</span><span class="p">);</span>

<span class="n">orderDto</span><span class="p">.</span><span class="n">CustomerName</span> <span class="p">=</span> <span class="s">&quot;Joe&quot;</span><span class="p">;</span>

<span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">orderDto</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

<span class="n">order</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;Joe&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Unflattening is only configured for <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code>. If you want unflattening, you must configure <code class="docutils literal notranslate"><span class="pre">Entity</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Dto</span></code> then call <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> to create an unflattening type map configuration from the <code class="docutils literal notranslate"><span class="pre">Dto</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Entity</span></code>.</p>
<div class="section" id="customizing-reverse-mapping">
<h3>Customizing reverse mapping<a class="headerlink" href="#customizing-reverse-mapping" title="Permalink to this headline">¶</a></h3>
<p>AutoMapper will automatically reverse map “Customer.Name” from “CustomerName” based on the original flattening. If you use MapFrom, AutoMapper will attempt to reverse the map:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">CustomerName</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">))</span>
  <span class="p">.</span><span class="n">ReverseMap</span><span class="p">();</span>
</pre></div>
</div>
<p>As long as the <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> path are member accessors, AutoMapper will unflatten from the same path (<code class="docutils literal notranslate"><span class="pre">CustomerName</span></code> =&gt; <code class="docutils literal notranslate"><span class="pre">Customer.Name</span></code>).</p>
<p>If you need to customize this, for a reverse map you can use <code class="docutils literal notranslate"><span class="pre">ForPath</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">CustomerName</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">))</span>
  <span class="p">.</span><span class="n">ReverseMap</span><span class="p">()</span>
  <span class="p">.</span><span class="n">ForPath</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">CustomerName</span><span class="p">));</span>
</pre></div>
</div>
<p>For most cases you shouldn’t need this, as the original MapFrom will be reversed for you. Use ForPath when the path to get and set the values are different.</p>
<p>If you do not want unflattening behavior, you can remove the call to <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> and create two separate maps. Or, you can use Ignore:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">CustomerName</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">))</span>
  <span class="p">.</span><span class="n">ReverseMap</span><span class="p">()</span>
  <span class="p">.</span><span class="n">ForPath</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Customer</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">Ignore</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="includemembers">
<h3>IncludeMembers<a class="headerlink" href="#includemembers" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> also integrates with <a class="reference external" href="Flattening.html#includemembers"><code class="docutils literal notranslate"><span class="pre">IncludeMembers</span></code></a> and configuration like</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">ForMember</span><span class="p">(</span><span class="n">destination</span> <span class="p">=&gt;</span> <span class="n">destination</span><span class="p">.</span><span class="n">IncludedMember</span><span class="p">,</span> <span class="n">member</span> <span class="p">=&gt;</span> <span class="n">member</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">source</span> <span class="p">=&gt;</span> <span class="n">source</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-Mapping-inheritance"></span><div class="section" id="mapping-inheritance">
<h2>Mapping Inheritance<a class="headerlink" href="#mapping-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Mapping inheritance serves two functions:</p>
<ul class="simple">
<li>Inheriting mapping configuration from a base class or interface configuration</li>
<li>Runtime polymorphic mapping</li>
</ul>
<p>Inheriting base class configuration is opt-in, and you can either explicitly specify the mapping to inherit from the base type configuration with <code class="docutils literal notranslate"><span class="pre">Include</span></code> or in the derived type configuration with <code class="docutils literal notranslate"><span class="pre">IncludeBase</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">BaseEntity</span><span class="p">,</span> <span class="n">BaseDto</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">DerivedEntity</span><span class="p">,</span> <span class="n">DerivedDto</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">SomeMember</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">OtherMember</span><span class="p">));</span>

<span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">DerivedEntity</span><span class="p">,</span> <span class="n">DerivedDto</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">BaseEntity</span><span class="p">,</span> <span class="n">BaseDto</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">SomeMember</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">OtherMember</span><span class="p">));</span>

<span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">DerivedEntity</span><span class="p">,</span> <span class="n">DerivedDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">IncludeBase</span><span class="p">&lt;</span><span class="n">BaseEntity</span><span class="p">,</span> <span class="n">BaseDto</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>In each case above, the derived mapping inherits the custom mapping configuration from the base mapping configuration.</p>
<p>To include all derived maps, from the base type map configuration:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">BaseEntity</span><span class="p">,</span> <span class="n">BaseDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">IncludeAllDerived</span><span class="p">();</span>

<span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">DerivedEntity</span><span class="p">,</span> <span class="n">DerivedDto</span><span class="p">&gt;();</span>
</pre></div>
</div>
<div class="section" id="runtime-polymorphism">
<h3>Runtime polymorphism<a class="headerlink" href="#runtime-polymorphism" title="Permalink to this headline">¶</a></h3>
<p>Take:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Order</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OnlineOrder</span> <span class="p">:</span> <span class="n">Order</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MailOrder</span> <span class="p">:</span> <span class="n">Order</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OnlineOrderDto</span> <span class="p">:</span> <span class="n">OrderDto</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MailOrderDto</span> <span class="p">:</span> <span class="n">OrderDto</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OnlineOrderDto</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">MailOrder</span><span class="p">,</span> <span class="n">MailOrderDto</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OnlineOrderDto</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">MailOrder</span><span class="p">,</span> <span class="n">MailOrderDto</span><span class="p">&gt;();</span>
<span class="p">});</span>

<span class="c1">// Perform Mapping</span>
<span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OnlineOrder</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">mapped</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">OrderDto</span><span class="p">));</span>
<span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">OnlineOrderDto</span><span class="p">&gt;(</span><span class="n">mapped</span><span class="p">);</span>
</pre></div>
</div>
<p>You will notice that because the mapped object is a OnlineOrder, AutoMapper has seen you have a more specific mapping for OnlineOrder than OrderDto, and automatically chosen that.</p>
</div>
<div class="section" id="specifying-inheritance-in-derived-classes">
<h3>Specifying inheritance in derived classes<a class="headerlink" href="#specifying-inheritance-in-derived-classes" title="Permalink to this headline">¶</a></h3>
<p>Instead of configuring inheritance from the base class, you can specify inheritance from the derived classes:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">m</span> <span class="p">=&gt;</span> <span class="n">m</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">OrderId</span><span class="p">));</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OnlineOrderDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">IncludeBase</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;();</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">MailOrder</span><span class="p">,</span> <span class="n">MailOrderDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">IncludeBase</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="as">
<h3>As<a class="headerlink" href="#as" title="Permalink to this headline">¶</a></h3>
<p>For simple cases, you can use <code class="docutils literal notranslate"><span class="pre">As</span></code> to redirect a base map to an existing derived map:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span>    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OnlineOrderDto</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;().</span><span class="n">As</span><span class="p">&lt;</span><span class="n">OnlineOrderDto</span><span class="p">&gt;();</span>
    
    <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">Order</span><span class="p">()).</span><span class="n">ShouldBeOfType</span><span class="p">&lt;</span><span class="n">OnlineOrderDto</span><span class="p">&gt;();</span>
</pre></div>
</div>
</div>
<div class="section" id="inheritance-mapping-priorities">
<h3>Inheritance Mapping Priorities<a class="headerlink" href="#inheritance-mapping-priorities" title="Permalink to this headline">¶</a></h3>
<p>This introduces additional complexity because there are multiple ways a property can be mapped. The priority of these sources are as follows</p>
<ul class="simple">
<li>Explicit Mapping (using .MapFrom())</li>
<li>Inherited Explicit Mapping</li>
<li>Ignore Property Mapping</li>
<li>Convention Mapping (Properties that are matched via convention)</li>
</ul>
<p>To demonstrate this, lets modify our classes shown above</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">//Domain Objects</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Order</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OnlineOrder</span> <span class="p">:</span> <span class="n">Order</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Referrer</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MailOrder</span> <span class="p">:</span> <span class="n">Order</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">//Dtos</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Referrer</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//Mappings</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">Include</span><span class="p">&lt;</span><span class="n">MailOrder</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">o</span><span class="p">=&gt;</span><span class="n">o</span><span class="p">.</span><span class="n">Referrer</span><span class="p">,</span> <span class="n">m</span><span class="p">=&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">Ignore</span><span class="p">());</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;();</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">MailOrder</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;();</span>
<span class="p">});</span>

<span class="c1">// Perform Mapping</span>
<span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OnlineOrder</span> <span class="p">{</span> <span class="n">Referrer</span> <span class="p">=</span> <span class="s">&quot;google&quot;</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">mapped</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">OrderDto</span><span class="p">));</span>
<span class="n">Assert</span><span class="p">.</span><span class="n">IsNull</span><span class="p">(</span><span class="n">mapped</span><span class="p">.</span><span class="n">Referrer</span><span class="p">);</span>
</pre></div>
</div>
<p>Notice that in our mapping configuration, we have ignored <code class="docutils literal notranslate"><span class="pre">Referrer</span></code> (because it doesn’t exist in the order base class) and that has a higher priority than convention mapping, so the property doesn’t get mapped.</p>
<p>If you do want the <code class="docutils literal notranslate"><span class="pre">Referrer</span></code> property to be mapped in the mapping from <code class="docutils literal notranslate"><span class="pre">OnlineOrder</span></code> to <code class="docutils literal notranslate"><span class="pre">OrderDto</span></code> you should include an explicit mapping in the mapping like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">cfg</span><span class="o">.</span><span class="n">CreateMap</span><span class="o">&lt;</span><span class="n">OnlineOrder</span><span class="p">,</span> <span class="n">OrderDto</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="o">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">o</span><span class="o">=&gt;</span><span class="n">o</span><span class="o">.</span><span class="n">Referrer</span><span class="p">,</span> <span class="n">m</span><span class="o">=&gt;</span><span class="n">m</span><span class="o">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">x</span><span class="o">=&gt;</span><span class="n">x</span><span class="o">.</span><span class="n">Referrer</span><span class="p">));</span>
</pre></div>
</div>
<p>Overall this feature should make using AutoMapper with classes that leverage inheritance feel more natural.</p>
</div>
</div>
<span id="document-Attribute-mapping"></span><div class="section" id="attribute-mapping">
<h2>Attribute Mapping<a class="headerlink" href="#attribute-mapping" title="Permalink to this headline">¶</a></h2>
<p>In addition to fluent configuration is the ability to declare and configure maps via attributes. Attribute maps can supplement or replace fluent mapping configuration.</p>
<div class="section" id="type-map-configuration">
<h3>Type Map configuration<a class="headerlink" href="#type-map-configuration" title="Permalink to this headline">¶</a></h3>
<p>In order to search for maps to configure, use the <code class="docutils literal notranslate"><span class="pre">AddMaps</span></code> method:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="s">&quot;MyAssembly&quot;</span><span class="p">));</span>

<span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mapper</span><span class="p">(</span><span class="n">configuration</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AddMaps</span></code> looks for fluent map configuration (<code class="docutils literal notranslate"><span class="pre">Profile</span></code> classes) and attribute-based mappings.</p>
<p>To declare an attribute map, decorate your destination type with the <code class="docutils literal notranslate"><span class="pre">AutoMapAttribute</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="na">[AutoMap(typeof(Order))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
    <span class="c1">// destination members</span>
</pre></div>
</div>
<p>This is equivalent to a <code class="docutils literal notranslate"><span class="pre">CreateMap&lt;Order,</span> <span class="pre">OrderDto&gt;()</span></code> configuration.</p>
<div class="section" id="customizing-type-map-configuration">
<h4>Customizing type map configuration<a class="headerlink" href="#customizing-type-map-configuration" title="Permalink to this headline">¶</a></h4>
<p>To customize the overall type map configuration, you can set the following properties on the <code class="docutils literal notranslate"><span class="pre">AutoMapAttribute</span></code>:</p>
<ul class="simple">
<li>ReverseMap (bool)</li>
<li>ConstructUsingServiceLocator (bool)</li>
<li>MaxDepth (int)</li>
<li>PreserveReferences (bool)</li>
<li>DisableCtorValidation (bool)</li>
<li>IncludeAllDerived (bool)</li>
<li>TypeConverter (Type)</li>
<li>AsProxy (bool)</li>
</ul>
<p>These all correspond to the similar fluent mapping configuration options. Only the <code class="docutils literal notranslate"><span class="pre">sourceType</span></code> value is required to map.</p>
</div>
</div>
<div class="section" id="member-configuration">
<h3>Member configuration<a class="headerlink" href="#member-configuration" title="Permalink to this headline">¶</a></h3>
<p>For attribute-based maps, you can decorate individual members with additional configuration. Because attributes have limitations in C# (no expressions, for example), the configuration options available are a bit limited.</p>
<p>Member-based attributes are declared in the <code class="docutils literal notranslate"><span class="pre">AutoMapper.Configuration.Annotations</span></code> namespace.</p>
<p>If the attribute-based configuration is not available or will not work, you can combine both attribute and profile-based maps (though this may be confusing).</p>
<div class="section" id="ignoring-members">
<h4>Ignoring members<a class="headerlink" href="#ignoring-members" title="Permalink to this headline">¶</a></h4>
<p>Use the <code class="docutils literal notranslate"><span class="pre">IgnoreAttribute</span></code> to ignore an individual destination member from mapping and/or validation:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">AutoMapper.Configuration.Annotations</span><span class="p">;</span>

<span class="na">[AutoMap(typeof(Order))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
<span class="na">    [Ignore]</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="redirecting-to-a-different-source-member">
<h4>Redirecting to a different source member<a class="headerlink" href="#redirecting-to-a-different-source-member" title="Permalink to this headline">¶</a></h4>
<p>It is not possible to use <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> with an expression in an attribute, but <code class="docutils literal notranslate"><span class="pre">SourceMemberAttribute</span></code> can redirect to a separate named member:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">AutoMapper.Configuration.Annotations</span><span class="p">;</span>

<span class="na">[AutoMap(typeof(Order))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
<span class="na">   [SourceMember(&quot;OrderTotal&quot;)]</span>
   <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Or use the <code class="docutils literal notranslate"><span class="pre">nameof</span></code> operator:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">AutoMapper.Configuration.Annotations</span><span class="p">;</span>

<span class="na">[AutoMap(typeof(Order))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
<span class="na">   [SourceMember(nameof(Order.OrderTotal))]</span>
   <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>You cannot flatten with this attribute, only redirect source type members (i.e. no “Order.Customer.Office.Name” in the name). Configuring flattening is only available with the fluent configuration.</p>
</div>
<div class="section" id="additional-configuration-options">
<h4>Additional configuration options<a class="headerlink" href="#additional-configuration-options" title="Permalink to this headline">¶</a></h4>
<p>Additional attribute-based configuration options include:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">MapAtRuntimeAttribute</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">MappingOrderAttribute</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">NullSubstituteAttribute</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">UseExistingValueAttribute</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ValueConverterAttribute</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ValueResolverAttribute</span></code></li>
</ul>
<p>Each corresponds to the same fluent configuration mapping option.</p>
</div>
</div>
</div>
<span id="document-Dynamic-and-ExpandoObject-Mapping"></span><div class="section" id="dynamic-and-expandoobject-mapping">
<h2>Dynamic and ExpandoObject Mapping<a class="headerlink" href="#dynamic-and-expandoobject-mapping" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper can map to/from dynamic objects without any explicit configuration:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Bar</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Baz</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Foo</span> <span class="n">InnerFoo</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">dynamic</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyDynamicObject</span><span class="p">();</span>
<span class="n">foo</span><span class="p">.</span><span class="n">Bar</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">foo</span><span class="p">.</span><span class="n">Baz</span> <span class="p">=</span> <span class="m">6</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{});</span>

<span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">result</span><span class="p">.</span><span class="n">Bar</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>
<span class="n">result</span><span class="p">.</span><span class="n">Baz</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">6</span><span class="p">);</span>

<span class="kt">dynamic</span> <span class="n">foo2</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">MyDynamicObject</span><span class="p">&gt;(</span><span class="n">result</span><span class="p">);</span>
<span class="n">foo2</span><span class="p">.</span><span class="n">Bar</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>
<span class="n">foo2</span><span class="p">.</span><span class="n">Baz</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">6</span><span class="p">);</span>
</pre></div>
</div>
<p>Similarly you can map straight from <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;string,</span> <span class="pre">object&gt;</span></code> to objects, AutoMapper will line up the keys with property names.
For mapping to destination child objects, you can use the dot notation.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">[</span><span class="s">&quot;InnerFoo.Bar&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="m">42</span> <span class="p">});</span>
<span class="n">result</span><span class="p">.</span><span class="n">InnerFoo</span><span class="p">.</span><span class="n">Bar</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">42</span><span class="p">);</span>
</pre></div>
</div>
</div>
<span id="document-Open-Generics"></span><div class="section" id="open-generics">
<h2>Open Generics<a class="headerlink" href="#open-generics" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper can support an open generic type map. Create a map for the open generic types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Create the mapping</span>
<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Source</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Destination</span><span class="p">&lt;&gt;)));</span>
</pre></div>
</div>
<p>You don’t need to create maps for closed generic types. AutoMapper will apply any configuration from the open generic mapping to the closed mapping at runtime:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">10</span> <span class="p">};</span>

<span class="kt">var</span> <span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> <span class="n">Destination</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">dest</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
</pre></div>
</div>
<p>Because C# only allows closed generic type parameters, you have to use the System.Type version of CreateMap to create your open generic type maps. From there, you can use all of the mapping configuration available and the open generic configuration will be applied to the closed type map at runtime.
AutoMapper will skip open generic type maps during configuration validation, since you can still create closed types that don’t convert, such as <code class="docutils literal notranslate"><span class="pre">Source&lt;Foo&gt;</span> <span class="pre">-&gt;</span> <span class="pre">Destination&lt;Bar&gt;</span></code> where there is no conversion from Foo to Bar.</p>
<p>You can also create an open generic type converter:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Source</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Destination</span><span class="p">&lt;&gt;)).</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Converter</span><span class="p">&lt;&gt;)));</span>
</pre></div>
</div>
<p>AutoMapper also supports open generic type converters with any number of generic arguments:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Source</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Destination</span><span class="p">&lt;&gt;)).</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Converter</span><span class="p">&lt;,&gt;)));</span>
</pre></div>
</div>
<p>The closed type from <code class="docutils literal notranslate"><span class="pre">Source</span></code> will be the first generic argument, and the closed type of <code class="docutils literal notranslate"><span class="pre">Destination</span></code> will be the second argument to close <code class="docutils literal notranslate"><span class="pre">Converter&lt;,&gt;</span></code>.</p>
<p>The same idea applies to value resolvers. Check <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/blob/e8249d582d384ea3b72eec31408126a0b69619bc/src/UnitTests/OpenGenerics.cs#L11">the tests</a>.</p>
</div>
<span id="document-Queryable-Extensions"></span><div class="section" id="queryable-extensions">
<h2>Queryable Extensions<a class="headerlink" href="#queryable-extensions" title="Permalink to this headline">¶</a></h2>
<p>When using an ORM such as NHibernate or Entity Framework with AutoMapper’s standard <code class="docutils literal notranslate"><span class="pre">mapper.Map</span></code> functions, you may notice that the ORM will query all the fields of all the objects within a graph when AutoMapper is attempting to map the results to a destination type.</p>
<p>If your ORM exposes <code class="docutils literal notranslate"><span class="pre">IQueryable</span></code>s, you can use AutoMapper’s QueryableExtensions helper methods to address this key pain.</p>
<p>Using Entity Framework for an example, say that you have an entity <code class="docutils literal notranslate"><span class="pre">OrderLine</span></code> with a relationship with an entity <code class="docutils literal notranslate"><span class="pre">Item</span></code>. If you want to map this to an <code class="docutils literal notranslate"><span class="pre">OrderLineDTO</span></code> with the <code class="docutils literal notranslate"><span class="pre">Item</span></code>’s <code class="docutils literal notranslate"><span class="pre">Name</span></code> property, the standard <code class="docutils literal notranslate"><span class="pre">mapper.Map</span></code> call will result in Entity Framework querying the entire <code class="docutils literal notranslate"><span class="pre">OrderLine</span></code> and <code class="docutils literal notranslate"><span class="pre">Item</span></code> table.</p>
<p>Use this approach instead.</p>
<p>Given the following entities:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrderLine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">OrderId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="n">Item</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Quantity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Item</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And the following DTO:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrderLineDTO</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">OrderId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Quantity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can use the Queryable Extensions like so:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">,</span> <span class="n">OrderLineDTO</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">Item</span><span class="p">.</span><span class="n">Name</span><span class="p">)));</span>

<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;</span> <span class="n">GetLinesForOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">orderId</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">orderEntities</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">OrderLines</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">OrderId</span> <span class="p">==</span> <span class="n">orderId</span><span class="p">)</span>
             <span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;(</span><span class="n">configuration</span><span class="p">).</span><span class="n">ToList</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.ProjectTo&lt;OrderLineDTO&gt;()</span></code> will tell AutoMapper’s mapping engine to emit a <code class="docutils literal notranslate"><span class="pre">select</span></code> clause to the IQueryable that will inform entity framework that it only needs to query the Name column of the Item table, same as if you manually projected your <code class="docutils literal notranslate"><span class="pre">IQueryable</span></code> to an <code class="docutils literal notranslate"><span class="pre">OrderLineDTO</span></code> with a <code class="docutils literal notranslate"><span class="pre">Select</span></code> clause.</p>
<p><code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code> must be the last call in the chain. ORMs work with entities, not DTOs. So apply any filtering and sorting on entities and, as the last step, project to DTOs.</p>
<p>Note that for this feature to work, all type conversions must be explicitly handled in your Mapping. For example, you can not rely on the <code class="docutils literal notranslate"><span class="pre">ToString()</span></code> override of the <code class="docutils literal notranslate"><span class="pre">Item</span></code> class to inform entity framework to only select from the <code class="docutils literal notranslate"><span class="pre">Name</span></code> column, and any data type changes, such as <code class="docutils literal notranslate"><span class="pre">Double</span></code> to <code class="docutils literal notranslate"><span class="pre">Decimal</span></code> must be explicitly handled as well.</p>
<div class="section" id="the-instance-api">
<h3>The instance API<a class="headerlink" href="#the-instance-api" title="Permalink to this headline">¶</a></h3>
<p>Starting with 8.0 there are similar ProjectTo methods on IMapper that feel more natural when you use IMapper with DI.</p>
</div>
<div class="section" id="preventing-lazy-loading-select-n-1-problems">
<h3>Preventing lazy loading/SELECT N+1 problems<a class="headerlink" href="#preventing-lazy-loading-select-n-1-problems" title="Permalink to this headline">¶</a></h3>
<p>Because the LINQ projection built by AutoMapper is translated directly to a SQL query by the query provider, the mapping occurs at the SQL/ADO.NET level, and not touching your entities. All data is eagerly fetched and loaded into your DTOs.</p>
<p>Nested collections use a Select to project child DTOs:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="n">i</span> <span class="k">in</span> <span class="n">db</span><span class="p">.</span><span class="n">Instructors</span>
<span class="k">orderby</span> <span class="n">i</span><span class="p">.</span><span class="n">LastName</span>
<span class="k">select</span> <span class="k">new</span> <span class="n">InstructorIndexData</span><span class="p">.</span><span class="n">InstructorModel</span>
<span class="p">{</span>
    <span class="n">ID</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span>
    <span class="n">FirstMidName</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">FirstMidName</span><span class="p">,</span>
    <span class="n">LastName</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">LastName</span><span class="p">,</span>
    <span class="n">HireDate</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">HireDate</span><span class="p">,</span>
    <span class="n">OfficeAssignmentLocation</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">OfficeAssignment</span><span class="p">.</span><span class="n">Location</span><span class="p">,</span>
    <span class="n">Courses</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">Courses</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">InstructorIndexData</span><span class="p">.</span><span class="n">InstructorCourseModel</span>
    <span class="p">{</span>
        <span class="n">CourseID</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">CourseID</span><span class="p">,</span>
        <span class="n">CourseTitle</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Title</span>
    <span class="p">}).</span><span class="n">ToList</span><span class="p">()</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This map through AutoMapper will result in a SELECT N+1 problem, as each child <code class="docutils literal notranslate"><span class="pre">Course</span></code> will be queried one at a time, unless specified through your ORM to eagerly fetch. With LINQ projection, no special configuration or specification is needed with your ORM. The ORM uses the LINQ projection to build the exact SQL query needed.</p>
</div>
<div class="section" id="custom-projection">
<h3>Custom projection<a class="headerlink" href="#custom-projection" title="Permalink to this headline">¶</a></h3>
<p>In the case where members names don’t line up, or you want to create calculated property, you can use MapFrom (the expression-based overload) to supply a custom expression for a destination member:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">Customer</span><span class="p">,</span> <span class="n">CustomerDto</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">FullName</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">+</span> <span class="s">&quot; &quot;</span> <span class="p">+</span> <span class="n">c</span><span class="p">.</span><span class="n">LastName</span><span class="p">))</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">TotalContacts</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Contacts</span><span class="p">.</span><span class="n">Count</span><span class="p">()));</span>
</pre></div>
</div>
<p>AutoMapper passes the supplied expression with the built projection. As long as your query provider can interpret the supplied expression, everything will be passed down all the way to the database.</p>
<p>If the expression is rejected from your query provider (Entity Framework, NHibernate, etc.), you might need to tweak your expression until you find one that is accepted.</p>
</div>
<div class="section" id="custom-type-conversion">
<h3>Custom Type Conversion<a class="headerlink" href="#custom-type-conversion" title="Permalink to this headline">¶</a></h3>
<p>Occasionally, you need to completely replace a type conversion from a source to a destination type. In normal runtime mapping, this is accomplished via the ConvertUsing method. To perform the analog in LINQ projection, use the ConvertUsing method:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;().</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Dest</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="m">10</span> <span class="p">});</span>
</pre></div>
</div>
<p>The expression-based <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code> is slightly more limited than Func-based <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code> overloads as only what is allowed in an Expression and the underlying LINQ provider will work.</p>
</div>
<div class="section" id="custom-destination-type-constructors">
<h3>Custom destination type constructors<a class="headerlink" href="#custom-destination-type-constructors" title="Permalink to this headline">¶</a></h3>
<p>If your destination type has a custom constructor but you don’t want to override the entire mapping, use the ConstructUsing expression-based method overload:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ConstructUsing</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Dest</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="m">10</span><span class="p">));</span>
</pre></div>
</div>
<p>AutoMapper will automatically match up destination constructor parameters to source members based on matching names, so only use this method if AutoMapper can’t match up the destination constructor properly, or if you need extra customization during construction.</p>
</div>
<div class="section" id="string-conversion">
<h3>String conversion<a class="headerlink" href="#string-conversion" title="Permalink to this headline">¶</a></h3>
<p>AutoMapper will automatically add <code class="docutils literal notranslate"><span class="pre">ToString()</span></code> when the destination member type is a string and the source member type is not.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Order</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">OrderTypeEnum</span> <span class="n">OrderType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderDto</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">OrderType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">orders</span> <span class="p">=</span> <span class="n">dbContext</span><span class="p">.</span><span class="n">Orders</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">configuration</span><span class="p">).</span><span class="n">ToList</span><span class="p">();</span>
<span class="n">orders</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">OrderType</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;Online&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-expansion">
<h3>Explicit expansion<a class="headerlink" href="#explicit-expansion" title="Permalink to this headline">¶</a></h3>
<p>In some scenarios, such as OData, a generic DTO is returned through an IQueryable controller action. Without explicit instructions, AutoMapper will expand all members in the result. To control which members are expanded during projection, set ExplicitExpansion in the configuration and then pass in the members you want to explicitly expand:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">dbContext</span><span class="p">.</span><span class="n">Orders</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">configuration</span><span class="p">,</span>
    <span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Customer</span><span class="p">,</span>
    <span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">LineItems</span><span class="p">);</span>
<span class="c1">// or string-based</span>
<span class="n">dbContext</span><span class="p">.</span><span class="n">Orders</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">configuration</span><span class="p">,</span>
    <span class="k">null</span><span class="p">,</span>
    <span class="s">&quot;Customer&quot;</span><span class="p">,</span>
    <span class="s">&quot;LineItems&quot;</span><span class="p">);</span>
<span class="c1">// for collections</span>
<span class="n">dbContext</span><span class="p">.</span><span class="n">Orders</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;(</span><span class="n">configuration</span><span class="p">,</span>
    <span class="k">null</span><span class="p">,</span>
    <span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">LineItems</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">item</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Product</span><span class="p">));</span>
</pre></div>
</div>
<p>For more information, see <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?p=1&amp;q=ExplicitExpansion&amp;utf8=%E2%9C%93">the tests</a>.</p>
</div>
<div class="section" id="aggregations">
<h3>Aggregations<a class="headerlink" href="#aggregations" title="Permalink to this headline">¶</a></h3>
<p>LINQ can support aggregate queries, and AutoMapper supports LINQ extension methods. In the custom projection example, if we renamed the <code class="docutils literal notranslate"><span class="pre">TotalContacts</span></code> property to <code class="docutils literal notranslate"><span class="pre">ContactsCount</span></code>, AutoMapper would match to the <code class="docutils literal notranslate"><span class="pre">Count()</span></code> extension method and the LINQ provider would translate the count into a correlated subquery to aggregate child records.</p>
<p>AutoMapper can also support complex aggregations and nested restrictions, if the LINQ provider supports it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">,</span> <span class="n">CourseModel</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">m</span> <span class="p">=&gt;</span> <span class="n">m</span><span class="p">.</span><span class="n">EnrollmentsStartingWithA</span><span class="p">,</span>
          <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Enrollments</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Student</span><span class="p">.</span><span class="n">LastName</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)).</span><span class="n">Count</span><span class="p">()));</span>
</pre></div>
</div>
<p>This query returns the total number of students, for each course, whose last name starts with the letter ‘A’.</p>
</div>
<div class="section" id="parameterization">
<h3>Parameterization<a class="headerlink" href="#parameterization" title="Permalink to this headline">¶</a></h3>
<p>Occasionally, projections need runtime parameters for their values. Consider a projection that needs to pull in the current username as part of its data. Instead of using post-mapping code, we can parameterize our MapFrom configuration:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">currentUserName</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateProjection</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">,</span> <span class="n">CourseModel</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">m</span> <span class="p">=&gt;</span> <span class="n">m</span><span class="p">.</span><span class="n">CurrentUserName</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">currentUserName</span><span class="p">));</span>
</pre></div>
</div>
<p>When we project, we’ll substitute our parameter at runtime:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">dbContext</span><span class="p">.</span><span class="n">Courses</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">CourseModel</span><span class="p">&gt;(</span><span class="n">Config</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">currentUserName</span> <span class="p">=</span> <span class="n">Request</span><span class="p">.</span><span class="n">User</span><span class="p">.</span><span class="n">Name</span> <span class="p">});</span>
</pre></div>
</div>
<p>This works by capturing the name of the closure’s field name in the original expression, then using an anonymous object/dictionary to apply the value to the parameter value before the query is sent to the query provider.</p>
<p>You may also use a dictionary to build the projection values:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">dbContext</span><span class="p">.</span><span class="n">Courses</span><span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">CourseModel</span><span class="p">&gt;(</span><span class="n">Config</span><span class="p">,</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">{</span><span class="s">&quot;currentUserName&quot;</span><span class="p">,</span> <span class="n">Request</span><span class="p">.</span><span class="n">User</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span> <span class="p">});</span>
</pre></div>
</div>
<p>However, using a dictionary will result in hard-coded values in the query instead of a parameterized query, so use with caution.</p>
</div>
<div class="section" id="supported-mapping-options">
<h3>Supported mapping options<a class="headerlink" href="#supported-mapping-options" title="Permalink to this headline">¶</a></h3>
<p>Not all mapping options can be supported, as the expression generated must be interpreted by a LINQ provider. Only what is supported by LINQ providers is supported by AutoMapper:</p>
<ul class="simple">
<li>MapFrom (Expression-based)</li>
<li>ConvertUsing (Expression-based)</li>
<li>Ignore</li>
<li>NullSubstitute</li>
<li>Value transformers</li>
<li>IncludeMembers</li>
</ul>
<p>Not supported:</p>
<ul class="simple">
<li>Condition</li>
<li>SetMappingOrder</li>
<li>UseDestinationValue</li>
<li>MapFrom (Func-based)</li>
<li>Before/AfterMap</li>
<li>Custom resolvers</li>
<li>Custom type converters</li>
<li>ForPath</li>
<li>Value converters</li>
<li><strong>Any calculated property on your domain object</strong></li>
</ul>
<p>Additionally, recursive or self-referencing destination types are not supported as LINQ providers do not support this. Typically hierarchical relational data models require common table expressions (CTEs) to correctly resolve a recursive join.</p>
</div>
</div>
<span id="document-Expression-Translation-(UseAsDataSource)"></span><div class="section" id="expression-translation-useasdatasource">
<h2>Expression Translation (UseAsDataSource)<a class="headerlink" href="#expression-translation-useasdatasource" title="Permalink to this headline">¶</a></h2>
<p>Automapper supports translating Expressions from one object to another in a separate <a class="reference external" href="https://www.nuget.org/packages/AutoMapper.Extensions.ExpressionMapping/">package</a>.
This is done by substituting the properties from the source class to what they map to in the destination class.</p>
<p>Given the example classes:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OrderLine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">OrderId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="n">Item</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Quantity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Item</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">OrderLineDTO</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">OrderId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">decimal</span> <span class="n">Quantity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
<span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">AddExpressionMapping</span><span class="p">();</span>
  
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">,</span> <span class="n">OrderLineDTO</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">Item</span><span class="p">.</span><span class="n">Name</span><span class="p">));</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">,</span> <span class="n">OrderLine</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">Item</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">));</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">,</span> <span class="n">Item</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>When mapping from DTO Expression</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;&gt;</span> <span class="n">dtoExpression</span> <span class="p">=</span> <span class="n">dto</span><span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">expression</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;&gt;&gt;(</span><span class="n">dtoExpression</span><span class="p">);</span>
</pre></div>
</div>
<p>Expression will be translated to <code class="docutils literal notranslate"><span class="pre">ol</span> <span class="pre">=&gt;</span> <span class="pre">ol.Item.Name.StartsWith(&quot;A&quot;)</span></code></p>
<p>Automapper knows <code class="docutils literal notranslate"><span class="pre">dto.Item</span></code> is mapped to <code class="docutils literal notranslate"><span class="pre">ol.Item.Name</span></code> so it substituted it for the expression.</p>
<p>Expression translation can work on expressions of collections as well.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;,</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;&gt;&gt;</span> <span class="n">dtoExpression</span> <span class="p">=</span> <span class="n">dtos</span> <span class="p">=&gt;</span> <span class="n">dtos</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Quantity</span> <span class="p">&gt;</span> <span class="m">5</span><span class="p">).</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Quantity</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">expression</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">&gt;,</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">&gt;&gt;&gt;(</span><span class="n">dtoExpression</span><span class="p">);</span>
</pre></div>
</div>
<p>Resulting in <code class="docutils literal notranslate"><span class="pre">ols</span> <span class="pre">=&gt;</span> <span class="pre">ols.Where(ol</span> <span class="pre">=&gt;</span> <span class="pre">ol.Quantity</span> <span class="pre">&gt;</span> <span class="pre">5).OrderBy(ol</span> <span class="pre">=&gt;</span> <span class="pre">ol.Quantity)</span></code></p>
<div class="section" id="mapping-flattened-properties-to-navigation-properties">
<h3>Mapping Flattened Properties to Navigation Properties<a class="headerlink" href="#mapping-flattened-properties-to-navigation-properties" title="Permalink to this headline">¶</a></h3>
<p>AutoMapper also supports mapping flattened (TModel or DTO) properties in expressions to their corresponding (TData) navigation properties (when the navigation property has been removed from the view model or DTO) e.g. CourseModel.DepartmentName from the model expression becomes Course.Department in the data expression.</p>
<p>Take the following set of classes:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CourseModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">CourseID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">DepartmentID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">DepartmentName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Course</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">CourseID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">DepartmentID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Department</span> <span class="n">Department</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Department</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">DepartmentID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then map exp below to expMapped.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">CourseModel</span><span class="p">&gt;,</span> <span class="n">IIncludableQueryable</span><span class="p">&lt;</span><span class="n">CourseModel</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;&gt;</span> <span class="n">exp</span> <span class="p">=</span> <span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Include</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">DepartmentName</span><span class="p">);</span>
<span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">&gt;,</span> <span class="n">IIncludableQueryable</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;&gt;</span> <span class="n">expMapped</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">MapExpressionAsInclude</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">&gt;,</span> <span class="n">IIncludableQueryable</span><span class="p">&lt;</span><span class="n">Course</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;&gt;&gt;(</span><span class="n">exp</span><span class="p">);</span>
</pre></div>
</div>
<p>The resulting mapped expression (expMapped.ToString()) is then <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=&gt;</span> <span class="pre">i.Include(s</span> <span class="pre">=&gt;</span> <span class="pre">s.Department);</span></code> . This feature allows navigation properties for the query to be defined based on the view model alone.</p>
</div>
<div class="section" id="supported-mapping-options">
<h3>Supported Mapping options<a class="headerlink" href="#supported-mapping-options" title="Permalink to this headline">¶</a></h3>
<p>Much like how Queryable Extensions can only support certain things that the LINQ providers support, expression translation follows the same rules as what it can and can’t support.</p>
</div>
<div class="section" id="useasdatasource">
<h3>UseAsDataSource<a class="headerlink" href="#useasdatasource" title="Permalink to this headline">¶</a></h3>
<p>Mapping expressions to one another is a tedious and produces long ugly code.</p>
<p><code class="docutils literal notranslate"><span class="pre">UseAsDataSource().For&lt;DTO&gt;()</span></code> makes this translation clean by not having to explicitly map expressions.
It also calls <code class="docutils literal notranslate"><span class="pre">ProjectTo&lt;TDO&gt;()</span></code> for you as well, where applicable.</p>
<p>Using EntityFramework as an example</p>
<p><code class="docutils literal notranslate"><span class="pre">dataContext.OrderLines.UseAsDataSource().For&lt;OrderLineDTO&gt;().Where(dto</span> <span class="pre">=&gt;</span> <span class="pre">dto.Name.StartsWith(&quot;A&quot;))</span></code></p>
<p>Does the equivalent of</p>
<p><code class="docutils literal notranslate"><span class="pre">dataContext.OrderLines.Where(ol</span> <span class="pre">=&gt;</span> <span class="pre">ol.Item.Name.StartsWith(&quot;A&quot;)).ProjectTo&lt;OrderLineDTO&gt;()</span></code></p>
<div class="section" id="when-projectto-is-not-called">
<h4>When ProjectTo() is not called<a class="headerlink" href="#when-projectto-is-not-called" title="Permalink to this headline">¶</a></h4>
<p>Expression Translation works for all kinds of functions, including <code class="docutils literal notranslate"><span class="pre">Select</span></code> calls.  If <code class="docutils literal notranslate"><span class="pre">Select</span></code> is used after <code class="docutils literal notranslate"><span class="pre">UseAsDataSource()</span></code> and changes the return type, then <code class="docutils literal notranslate"><span class="pre">ProjectTo&lt;&gt;()</span></code> won’t be called and <code class="docutils literal notranslate"><span class="pre">mapper.Map</span></code> will be used instead.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">dataContext.OrderLines.UseAsDataSource().For&lt;OrderLineDTO&gt;().Select(dto</span> <span class="pre">=&gt;</span> <span class="pre">dto.Name)</span></code></p>
<p>Does the equivalent of</p>
<p><code class="docutils literal notranslate"><span class="pre">dataContext.OrderLines.Select(ol</span> <span class="pre">=&gt;</span> <span class="pre">ol.Item.Name)</span></code></p>
</div>
<div class="section" id="register-a-callback-for-when-an-useasdatasource-query-is-enumerated">
<h4>Register a callback, for when an UseAsDataSource() query is enumerated<a class="headerlink" href="#register-a-callback-for-when-an-useasdatasource-query-is-enumerated" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, you may want to edit the collection, that is returned from a mapped query before forwarding it to the next application layer.
With <code class="docutils literal notranslate"><span class="pre">.ProjectTo&lt;TDto&gt;</span></code> this is quite simple, as there is no sense in directly returning the resulting <code class="docutils literal notranslate"><span class="pre">IQueryable&lt;TDto&gt;</span></code> because you cannot edit it anymore anyways. So you will most likely do this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">,</span> <span class="n">OrderLineDTO</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">Item</span><span class="p">.</span><span class="n">Name</span><span class="p">)));</span>

<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;</span> <span class="n">GetLinesForOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">orderId</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">orderEntities</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">dtos</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">OrderLines</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">OrderId</span> <span class="p">==</span> <span class="n">orderId</span><span class="p">)</span>
             <span class="p">.</span><span class="n">ProjectTo</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;().</span><span class="n">ToList</span><span class="p">();</span>
    <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">dto</span> <span class="k">in</span> <span class="n">dtos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// edit some property, or load additional data from the database and augment the dtos</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dtos</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, if you did this with the <code class="docutils literal notranslate"><span class="pre">.UseAsDataSource()</span></code> approach, you would lose all of its power - namely its ability to modify the internal expression until it is enumerated.
To solve that problem, we introduced the <code class="docutils literal notranslate"><span class="pre">.OnEnumerated</span></code> callback.
Using it, you can do the following:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">,</span> <span class="n">OrderLineDTO</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dto</span> <span class="p">=&gt;</span> <span class="n">dto</span><span class="p">.</span><span class="n">Item</span><span class="p">,</span> <span class="n">conf</span> <span class="p">=&gt;</span> <span class="n">conf</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">Item</span><span class="p">.</span><span class="n">Name</span><span class="p">)));</span>

<span class="k">public</span> <span class="n">IQueryable</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;</span> <span class="n">GetLinesForOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">orderId</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">orderEntities</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">OrderLines</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ol</span> <span class="p">=&gt;</span> <span class="n">ol</span><span class="p">.</span><span class="n">OrderId</span> <span class="p">==</span> <span class="n">orderId</span><span class="p">)</span>
             <span class="p">.</span><span class="n">UseAsDataSource</span><span class="p">()</span>
             <span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;()</span>
             <span class="p">.</span><span class="n">OnEnumerated</span><span class="p">((</span><span class="n">dtos</span><span class="p">)</span> <span class="p">=&gt;</span>
             <span class="p">{</span>
                <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">dto</span> <span class="k">in</span> <span class="n">dtosCast</span><span class="p">&lt;</span><span class="n">OrderLineDTO</span><span class="p">&gt;())</span>
                <span class="p">{</span>
                     <span class="c1">// edit some property, or load additional data from the database and augment the dtos</span>
                <span class="p">}</span>
             <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>this <code class="docutils literal notranslate"><span class="pre">OnEnumerated(IEnumerable)</span></code>callback is executed, when the <code class="docutils literal notranslate"><span class="pre">IQueryable&lt;OrderLineDTO&gt;</span></code> itself is enumerated.
So this also works with the OData samples mentioned above: The OData $filter and $orderby expressions are still converted into SQL, and the <code class="docutils literal notranslate"><span class="pre">OnEnumerated()</span></code>callback is provided with the filtered, ordered resultset from the database.</p>
</div>
</div>
</div>
<span id="document-Enum-Mapping"></span><div class="section" id="automapper-extensions-enummapping">
<h2>AutoMapper.Extensions.EnumMapping<a class="headerlink" href="#automapper-extensions-enummapping" title="Permalink to this headline">¶</a></h2>
<p>The built-in enum mapper is not configurable, it can only be replaced. Alternatively, AutoMapper supports convention based mapping of enum values in a separate package <a class="reference external" href="https://www.nuget.org/packages/AutoMapper.Extensions.EnumMapping/">AutoMapper.Extensions.EnumMapping</a>.</p>
<div class="section" id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h3>
<p>For method <code class="docutils literal notranslate"><span class="pre">CreateMap</span></code> this library provide a <code class="docutils literal notranslate"><span class="pre">ConvertUsingEnumMapping</span></code> method. This method add all default mappings from source to destination enum values.</p>
<p>If you want to change some mappings, then you can use <code class="docutils literal notranslate"><span class="pre">MapValue</span></code> method. This is a chainable method.</p>
<p>Default the enum values are mapped by value (explicitly: <code class="docutils literal notranslate"><span class="pre">MapByValue()</span></code>), but it is possible to map by name calling  <code class="docutils literal notranslate"><span class="pre">MapByName()</span></code>.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">AutoMapper.Extensions.EnumMapping</span><span class="p">;</span>

<span class="k">public</span> <span class="k">enum</span> <span class="n">Source</span>
<span class="p">{</span>
    <span class="n">Default</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
    <span class="n">First</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
    <span class="n">Second</span> <span class="p">=</span> <span class="m">2</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">enum</span> <span class="n">Destination</span>
<span class="p">{</span>
    <span class="n">Default</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
    <span class="n">Second</span> <span class="p">=</span> <span class="m">2</span>
<span class="p">}</span>

<span class="k">internal</span> <span class="k">class</span> <span class="nc">YourProfile</span> <span class="p">:</span> <span class="n">Profile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">YourProfile</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
            <span class="p">.</span><span class="n">ConvertUsingEnumMapping</span><span class="p">(</span><span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span>
		        <span class="c1">// optional: .MapByValue() or MapByName(), without configuration MapByValue is used</span>
		        <span class="p">.</span><span class="n">MapValue</span><span class="p">(</span><span class="n">Source</span><span class="p">.</span><span class="n">First</span><span class="p">,</span> <span class="n">Destination</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="n">ReverseMap</span><span class="p">();</span> <span class="c1">// to support Destination to Source mapping, including custom mappings of ConvertUsingEnumMapping</span>
    <span class="p">}</span>
<span class="p">}</span>
    <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="default-convention">
<h3>Default Convention<a class="headerlink" href="#default-convention" title="Permalink to this headline">¶</a></h3>
<p>The package <a class="reference external" href="https://www.nuget.org/packages/AutoMapper.Extensions.EnumMapping/">AutoMapper.Extensions.EnumMapping</a> will map all values from Source type to Destination type if both enum types have the same value (or by name or by value). All Source enum values which have no Target equivalent, will throw an exception if EnumMappingValidation is enabled.</p>
</div>
<div class="section" id="reversemap-convention">
<h3>ReverseMap Convention<a class="headerlink" href="#reversemap-convention" title="Permalink to this headline">¶</a></h3>
<p>For method <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> the same convention is used as for default mappings, but it also respects override enum value mappings if possible.</p>
<p>The following steps determines the reversed overrides:</p>
<ol>
<li><p class="first">Create mappings for <code class="docutils literal notranslate"><span class="pre">Source</span></code> to <code class="docutils literal notranslate"><span class="pre">Destination</span></code> (default convention), including custom overrides.</p>
</li>
<li><p class="first">Create mappings for <code class="docutils literal notranslate"><span class="pre">Destination</span></code> to <code class="docutils literal notranslate"><span class="pre">Source</span></code> (default convention), without custom overrides (must be determined)</p>
</li>
<li><p class="first">The mappings from step 1 will be used to determine the overrides for the <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code>.
Therefore the mappings are grouped by <code class="docutils literal notranslate"><span class="pre">Destination</span></code> value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> 3a) if there is a matching `Source` value for the `Destination` value, then that mapping is preferred and no override is needed
</pre></div>
</div>
<p>It is possible that a <code class="docutils literal notranslate"><span class="pre">Destination</span></code> value has multiple <code class="docutils literal notranslate"><span class="pre">Source</span></code> values specified by override mappings.</p>
<p>We have to determine which <code class="docutils literal notranslate"><span class="pre">Source</span></code> value will be the new <code class="docutils literal notranslate"><span class="pre">Destination</span></code> for the current <code class="docutils literal notranslate"><span class="pre">Destination</span></code> value (which is the new <code class="docutils literal notranslate"><span class="pre">Source</span></code> value)</p>
<p>For every <code class="docutils literal notranslate"><span class="pre">Source</span></code> value per grouped <code class="docutils literal notranslate"><span class="pre">Destination</span></code> value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> 3b) if the `Source` enum value does not exists in the `Destination` enum type, then that mapping cannot reversed

 3c) if there is a `Source` value which is not a `Destination` part of the mappings from step 1, then that mapping cannot reversed

 3d) if the `Source` value is not excluded by option b and c, the that `Source` value is the new `Destination` value.
</pre></div>
</div>
</li>
<li><p class="first">All overrides which are determined in step 3 will be applied to mappings from step 2.</p>
</li>
<li><p class="first">Finally, the custom mappings provided to method <code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> will be applied.</p>
</li>
</ol>
</div>
<div class="section" id="testing">
<h3>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://www.nuget.org/packages/AutoMapper/">AutoMapper</a> provides a nice tooling for validating typemaps. This package adds an extra <code class="docutils literal notranslate"><span class="pre">EnumMapperConfigurationExpressionExtensions.EnableEnumMappingValidation</span></code> extension method to extend the existing <code class="docutils literal notranslate"><span class="pre">AssertConfigurationIsValid()</span></code> method to validate also the enum mappings.</p>
<p>To enable testing the enum mapping configuration:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MappingConfigurationsTests</span>
<span class="p">{</span>
<span class="na">    [Fact]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">WhenProfilesAreConfigured_ItShouldNotThrowException</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Arrange</span>
        <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">configuration</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">configuration</span><span class="p">.</span><span class="n">EnableEnumMappingValidation</span><span class="p">();</span>

            <span class="n">configuration</span><span class="p">.</span><span class="n">AddMaps</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">AssemblyInfo</span><span class="p">).</span><span class="n">GetTypeInfo</span><span class="p">().</span><span class="n">Assembly</span><span class="p">);</span>
        <span class="p">});</span>
		
        <span class="c1">// Assert</span>
        <span class="n">config</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound" id="extensibility">
<span id="document-Custom-type-converters"></span><div class="section" id="custom-type-converters">
<h2>Custom Type Converters<a class="headerlink" href="#custom-type-converters" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, you need to take complete control over the conversion of one type to another.  This is typically when one type looks nothing like the other, a conversion function already exists, and you would like to go from a “looser” type to a stronger type, such as a source type of string to a destination type of Int32.</p>
<p>For example, suppose we have a source type of:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Value3</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But you would like to map it to:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="n">DateTime</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="n">Type</span> <span class="n">Value3</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we were to try and map these two types as-is, AutoMapper would throw an exception (at map time and configuration-checking time), as AutoMapper does not know about any mapping from string to int, DateTime or Type.  To create maps for these types, we must supply a custom type converter, and we have three ways of doing so:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="nf">ConvertUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">ConvertUsing</span><span class="p">(</span><span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">converter</span><span class="p">);</span>
<span class="k">void</span> <span class="n">ConvertUsing</span><span class="p">&lt;</span><span class="n">TTypeConverter</span><span class="p">&gt;()</span> <span class="k">where</span> <span class="n">TTypeConverter</span> <span class="p">:</span> <span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;;</span>
</pre></div>
</div>
<p>The first option is simply any function that takes a source and returns a destination (there are several overloads too). This works for simple cases, but becomes unwieldy for larger ones.  In more difficult cases, we can create a custom ITypeConverter&lt;TSource, TDestination&gt;:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span>
<span class="p">{</span>
	<span class="n">TDestination</span> <span class="nf">Convert</span><span class="p">(</span><span class="n">TSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">TDestination</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And supply AutoMapper with either an instance of a custom type converter, or simply the type, which AutoMapper will instantiate at run time.  The mapping configuration for our above source/destination types then becomes:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;().</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
      <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">&gt;().</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">DateTimeTypeConverter</span><span class="p">());</span>
      <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Type</span><span class="p">&gt;().</span><span class="n">ConvertUsing</span><span class="p">&lt;</span><span class="n">TypeTypeConverter</span><span class="p">&gt;();</span>
      <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;();</span>
    <span class="p">});</span>
    <span class="n">configuration</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span>
    <span class="p">{</span>
        <span class="n">Value1</span> <span class="p">=</span> <span class="s">&quot;5&quot;</span><span class="p">,</span>
        <span class="n">Value2</span> <span class="p">=</span> <span class="s">&quot;01/01/2000&quot;</span><span class="p">,</span>
        <span class="n">Value3</span> <span class="p">=</span> <span class="s">&quot;AutoMapperSamples.GlobalTypeConverters.GlobalTypeConverters+Destination&quot;</span>
    <span class="p">};</span>

    <span class="n">Destination</span> <span class="n">result</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">Value3</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Destination</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DateTimeTypeConverter</span> <span class="p">:</span> <span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">string</span> <span class="n">source</span><span class="p">,</span> <span class="n">DateTime</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">System</span><span class="p">.</span><span class="n">Convert</span><span class="p">.</span><span class="n">ToDateTime</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">TypeTypeConverter</span> <span class="p">:</span> <span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Type</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Type</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">string</span> <span class="n">source</span><span class="p">,</span> <span class="n">Type</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
          <span class="k">return</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">GetExecutingAssembly</span><span class="p">().</span><span class="n">GetType</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the first mapping, from string to Int32, we simply use the built-in Convert.ToInt32 function (supplied as a method group).  The next two use custom ITypeConverter implementations.</p>
<p>The real power of custom type converters is that they are used any time AutoMapper finds the source/destination pairs on any mapped types.  We can build a set of custom type converters, on top of which other mapping configurations use, without needing any extra configuration.  In the above example, we never have to specify the string/int conversion again.  Where as <a class="reference external" href="Custom-value-resolvers.html">Custom Value Resolvers</a> have to be configured at a type member level, custom type converters are global in scope.</p>
</div>
<span id="document-Custom-value-resolvers"></span><div class="section" id="custom-value-resolvers">
<h2>Custom Value Resolvers<a class="headerlink" href="#custom-value-resolvers" title="Permalink to this headline">¶</a></h2>
<p>Although AutoMapper covers quite a few destination member mapping scenarios, there are the 1 to 5% of destination values that need a little help in resolving.  Many times, this custom value resolution logic is domain logic that can go straight on our domain.  However, if this logic pertains only to the mapping operation, it would clutter our source types with unnecessary behavior.  In these cases, AutoMapper allows for configuring custom value resolvers for destination members.  For example, we might want to have a calculated value just during mapping:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Source</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Destination</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">Total</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For whatever reason, we want Total to be the sum of the source Value properties.  For some other reason, we can’t or shouldn’t put this logic on our Source type.  To supply a custom value resolver, we’ll need to first create a type that implements IValueResolver:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IValueResolver</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TSource</span><span class="p">,</span> <span class="k">in</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TDestMember</span><span class="p">&gt;</span>
<span class="p">{</span>
	<span class="n">TDestMember</span> <span class="nf">Resolve</span><span class="p">(</span><span class="n">TSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">TDestination</span> <span class="n">destination</span><span class="p">,</span> <span class="n">TDestMember</span> <span class="n">destMember</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The ResolutionContext contains all of the contextual information for the current resolution operation, such as source type, destination type, source value and so on.  An example implementation:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CustomResolver</span> <span class="p">:</span> <span class="n">IValueResolver</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="nf">Resolve</span><span class="p">(</span><span class="n">Source</span> <span class="n">source</span><span class="p">,</span> <span class="n">Destination</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="k">return</span> <span class="n">source</span><span class="p">.</span><span class="n">Value1</span> <span class="p">+</span> <span class="n">source</span><span class="p">.</span><span class="n">Value2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once we have our IValueResolver implementation, we’ll need to tell AutoMapper to use this custom value resolver when resolving a specific destination member.  We have several options in telling AutoMapper a custom value resolver to use, including:</p>
<ul class="simple">
<li>MapFrom&lt;TValueResolver&gt;</li>
<li>MapFrom(typeof(CustomValueResolver))</li>
<li>MapFrom(aValueResolverInstance)</li>
</ul>
<p>In the below example, we’ll use the first option, telling AutoMapper the custom resolver type through generics:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
	 <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">&lt;</span><span class="n">CustomResolver</span><span class="p">&gt;()));</span>
<span class="n">configuration</span><span class="p">.</span><span class="n">AssertConfigurationIsValid</span><span class="p">();</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span>
	<span class="p">{</span>
		<span class="n">Value1</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span>
		<span class="n">Value2</span> <span class="p">=</span> <span class="m">7</span>
	<span class="p">};</span>

<span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">result</span><span class="p">.</span><span class="n">Total</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="m">12</span><span class="p">);</span>
</pre></div>
</div>
<p>Although the destination member (Total) did not have any matching source member, specifying a custom resolver made the configuration valid, as the resolver is now responsible for supplying a value for the destination member.</p>
<p>If we don’t care about the source/destination types in our value resolver, or want to reuse them across maps, we can just use “object” as the source/destination types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MultBy2Resolver</span> <span class="p">:</span> <span class="n">IValueResolver</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="kt">object</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Resolve</span><span class="p">(</span><span class="kt">object</span> <span class="n">source</span><span class="p">,</span> <span class="kt">object</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destMember</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">destMember</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="custom-constructor-methods">
<h3>Custom constructor methods<a class="headerlink" href="#custom-constructor-methods" title="Permalink to this headline">¶</a></h3>
<p>Because we only supplied the type of the custom resolver to AutoMapper, the mapping engine will use reflection to create an instance of the value resolver.</p>
<p>If we don’t want AutoMapper to use reflection to create the instance, we can supply it directly:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span>
		<span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="k">new</span> <span class="n">CustomResolver</span><span class="p">())</span>
	<span class="p">));</span>
</pre></div>
</div>
<p>AutoMapper will use that specific object, helpful in scenarios where the resolver might have constructor arguments or need to be constructed by an IoC container.</p>
</div>
<div class="section" id="the-resolved-value-is-mapped-to-the-destination-property">
<h3>The resolved value is mapped to the destination property<a class="headerlink" href="#the-resolved-value-is-mapped-to-the-destination-property" title="Permalink to this headline">¶</a></h3>
<p>Note that the value you return from your resolver is not simply assigned to the destination property. Any map that applies will be used and the result of that mapping will be the final destination property value. Check <a class="reference external" href="Understanding-your-mapping.html">the execution plan</a>.</p>
</div>
<div class="section" id="customizing-the-source-value-supplied-to-the-resolver">
<h3>Customizing the source value supplied to the resolver<a class="headerlink" href="#customizing-the-source-value-supplied-to-the-resolver" title="Permalink to this headline">¶</a></h3>
<p>By default, AutoMapper passes the source object to the resolver. This limits the reusability of resolvers, since the resolver is coupled to the source type. If, however, we supply a common resolver across multiple types, we configure AutoMapper to redirect the source value supplied to the resolver, and also use a different resolver interface so that our resolver can get use of the source/destination members:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span>
        <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">&lt;</span><span class="n">CustomResolver</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">&gt;(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">SubTotal</span><span class="p">));</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OtherSource</span><span class="p">,</span> <span class="n">OtherDest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">OtherTotal</span><span class="p">,</span>
        <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">&lt;</span><span class="n">CustomResolver</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">&gt;(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">OtherSubTotal</span><span class="p">));</span>
<span class="p">});</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomResolver</span> <span class="p">:</span> <span class="n">IMemberValueResolver</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="kt">object</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="nf">Resolve</span><span class="p">(</span><span class="kt">object</span> <span class="n">source</span><span class="p">,</span> <span class="kt">object</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">sourceMember</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">destinationMember</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// logic here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="passing-in-key-value-to-mapper">
<h3>Passing in key-value to Mapper<a class="headerlink" href="#passing-in-key-value-to-mapper" title="Permalink to this headline">¶</a></h3>
<p>When calling map you can pass in extra objects by using key-value and using a custom resolver to get the object from context.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;(</span><span class="n">src</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">Items</span><span class="p">[</span><span class="s">&quot;Foo&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Bar&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is how to setup the mapping for this custom resolver</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">destMember</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">context</span><span class="p">.</span><span class="n">Items</span><span class="p">[</span><span class="s">&quot;Foo&quot;</span><span class="p">]));</span>
</pre></div>
</div>
</div>
<div class="section" id="forpath">
<h3>ForPath<a class="headerlink" href="#forpath" title="Permalink to this headline">¶</a></h3>
<p>Similar to ForMember, from 6.1.0 there is ForPath. Check out <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?utf8=%E2%9C%93&amp;q=ForPath&amp;type=">the tests</a> for examples.</p>
</div>
<div class="section" id="resolvers-and-conditions">
<h3>Resolvers and conditions<a class="headerlink" href="#resolvers-and-conditions" title="Permalink to this headline">¶</a></h3>
<p>For each property mapping, AutoMapper attempts to resolve the destination value <strong>before</strong> evaluating the condition. So it needs to be able to do that without throwing an exception even if the condition will prevent the resulting value from being used.</p>
<p>As an example, here’s sample output from <a class="reference external" href="Understanding-your-mapping.html">BuildExecutionPlan</a> (displayed using <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-1232914.ReadableExpressionsVisualizers">ReadableExpressions</a>) for a single property:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">try</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">resolvedValue</span> <span class="p">=</span>
	<span class="p">{</span>
		<span class="k">try</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="c1">// ... tries to resolve the destination value here</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">NullReferenceException</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="k">null</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentNullException</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="k">null</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">typeMapDestination</span><span class="p">,</span> <span class="n">resolvedValue</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">typeMapDestination</span><span class="p">.</span><span class="n">WorkStatus</span> <span class="p">=</span> <span class="n">resolvedValue</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">AutoMapperMappingException</span><span class="p">(</span>
		<span class="s">&quot;Error mapping types.&quot;</span><span class="p">,</span>
		<span class="n">ex</span><span class="p">,</span>
		<span class="n">AutoMapper</span><span class="p">.</span><span class="n">TypePair</span><span class="p">,</span>
		<span class="n">AutoMapper</span><span class="p">.</span><span class="n">TypeMap</span><span class="p">,</span>
		<span class="n">AutoMapper</span><span class="p">.</span><span class="n">PropertyMap</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The default generated code for resolving a property, if you haven’t customized the mapping for that member, generally doesn’t have any problems.  But if you’re using custom code to map the property that will crash if the condition isn’t met, the mapping will fail despite the condition.</p>
<p>This example code would fail:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SourceClass</span> 
<span class="p">{</span> 
	<span class="k">public</span> <span class="kt">string</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">TargetClass</span> 
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">ValueLength</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SourceClass</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="k">null</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">target</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TargetClass</span><span class="p">;</span>

<span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">SourceClass</span><span class="p">,</span> <span class="n">TargetClass</span><span class="p">&gt;()</span>
	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">ValueLength</span><span class="p">,</span> <span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Length</span><span class="p">))</span>
	<span class="p">.</span><span class="n">ForAllMembers</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Condition</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="k">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">value</span> <span class="p">!=</span> <span class="k">null</span><span class="p">));</span>
</pre></div>
</div>
<p>The condition prevents the Value property from being mapped onto the target, but the custom member mapping would fail before that point because it calls Value.Length, and Value is null.</p>
<p>Prevent this by using a <a class="reference external" href="Conditional-mapping.html#preconditions">PreCondition</a> instead or by ensuring the custom member mapping code can complete safely regardless of conditions:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span>	<span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">ValueLength</span><span class="p">,</span> <span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">?</span> <span class="n">s</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Length</span> <span class="p">:</span> <span class="m">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-Conditional-mapping"></span><div class="section" id="conditional-mapping">
<h2>Conditional Mapping<a class="headerlink" href="#conditional-mapping" title="Permalink to this headline">¶</a></h2>
<p>AutoMapper allows you to add conditions to properties that must be met before that property will be mapped.</p>
<p>This can be used in situations like the following where we are trying to map from an int to an unsigned int.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">baz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
  <span class="k">public</span> <span class="kt">uint</span> <span class="n">baz</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the following mapping the property baz will only be mapped if it is greater than or equal to 0 in the source object.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="n">Bar</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">baz</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">Condition</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">baz</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>If you have a resolver, see <a class="reference external" href="Custom-value-resolvers.html#resolvers-and-conditions">here</a> for a concrete example.</p>
<div class="section" id="preconditions">
<h3>Preconditions<a class="headerlink" href="#preconditions" title="Permalink to this headline">¶</a></h3>
<p>Similarly, there is a PreCondition method. The difference is that it runs sooner in the mapping process, before the source value is resolved (think MapFrom). So the precondition is called, then we decide which will be the source of the mapping (resolving), then the condition is called and finally the destination value is assigned.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="n">Bar</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">baz</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">opt</span><span class="p">.</span><span class="n">PreCondition</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">baz</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">));</span>
        <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Expensive resolution process that can be avoided with a PreCondition</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>You can <a class="reference external" href="Understanding-your-mapping.html">see the steps</a> yourself.</p>
<p>See <a class="reference external" href="Custom-value-resolvers.html#resolvers-and-conditions">here</a> for a concrete example.</p>
</div>
</div>
<span id="document-Null-substitution"></span><div class="section" id="null-substitution">
<h2>Null Substitution<a class="headerlink" href="#null-substitution" title="Permalink to this headline">¶</a></h2>
<p>Null substitution allows you to supply an alternate value for a destination member if the source value is null anywhere along the member chain. This means that instead of mapping from null, it will map from the value you supply.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">destination</span> <span class="p">=&gt;</span> <span class="n">destination</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">NullSubstitute</span><span class="p">(</span><span class="s">&quot;Other Value&quot;</span><span class="p">)));</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="k">null</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">mapper</span> <span class="p">=</span> <span class="n">config</span><span class="p">.</span><span class="n">CreateMapper</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">dest</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;Other Value&quot;</span><span class="p">);</span>

<span class="n">source</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="s">&quot;Not null&quot;</span><span class="p">;</span>

<span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">dest</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">ShouldEqual</span><span class="p">(</span><span class="s">&quot;Not null&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The substitute is assumed to be of the source member type, and will go through any mapping/conversion after to the destination type.</p>
</div>
<span id="document-Value-converters"></span><div class="section" id="value-converters">
<h2>Value Converters<a class="headerlink" href="#value-converters" title="Permalink to this headline">¶</a></h2>
<p>Value converters are a cross between <a class="reference external" href="Custom-type-converters.html">Type Converters</a> and <a class="reference external" href="Custom-value-resolvers.html">Value Resolvers</a>. Type converters are globally scoped, so that any time you map from type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> to type <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in any mapping, the type converter will be used. Value converters are scoped to a single map, and receive the source and destination objects to resolve to a value to map to the destination member. Optionally value converters can receive the source member as well.</p>
<p>In simplified syntax:</p>
<ul class="simple">
<li>Type converter = <code class="docutils literal notranslate"><span class="pre">Func&lt;TSource,</span> <span class="pre">TDestination,</span> <span class="pre">TDestination&gt;</span></code></li>
<li>Value resolver = <code class="docutils literal notranslate"><span class="pre">Func&lt;TSource,</span> <span class="pre">TDestination,</span> <span class="pre">TDestinationMember&gt;</span></code></li>
<li>Member value resolver = <code class="docutils literal notranslate"><span class="pre">Func&lt;TSource,</span> <span class="pre">TDestination,</span> <span class="pre">TSourceMember,</span> <span class="pre">TDestinationMember&gt;</span></code></li>
<li>Value converter = <code class="docutils literal notranslate"><span class="pre">Func&lt;TSourceMember,</span> <span class="pre">TDestinationMember&gt;</span></code></li>
</ul>
<p>To configure a value converter, use at the member level:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CurrencyFormatter</span> <span class="p">:</span> <span class="n">IValueConverter</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">source</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Amount</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">()));</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLineItem</span><span class="p">,</span> <span class="n">OrderLineItemDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">()));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>You can customize the source member when the source member name does not match:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CurrencyFormatter</span> <span class="p">:</span> <span class="n">IValueConverter</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">source</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Amount</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">(),</span> <span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">OrderAmount</span><span class="p">));</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLineItem</span><span class="p">,</span> <span class="n">OrderLineItemDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">(),</span> <span class="n">src</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">LITotal</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>If you need the value converters instantiated by the <a class="reference external" href="Dependency-injection.html">service locator</a>, you can specify the type instead:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CurrencyFormatter</span> <span class="p">:</span> <span class="n">IValueConverter</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">source</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Amount</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">&lt;</span><span class="n">CurrencyFormatter</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">&gt;());</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">OrderLineItem</span><span class="p">,</span> <span class="n">OrderLineItemDto</span><span class="p">&gt;()</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Total</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">&lt;</span><span class="n">CurrencyFormatter</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">&gt;());</span>
<span class="p">});</span>
</pre></div>
</div>
<p>If you do not know the types or member names at runtime, use the various overloads that accept <code class="docutils literal notranslate"><span class="pre">System.Type</span></code> and <code class="docutils literal notranslate"><span class="pre">string</span></code>-based members:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">CurrencyFormatter</span> <span class="p">:</span> <span class="n">IValueConverter</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">source</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Order</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">OrderDto</span><span class="p">))</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="s">&quot;Amount&quot;</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">(),</span> <span class="s">&quot;OrderAmount&quot;</span><span class="p">));</span>
   <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">OrderLineItem</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">OrderLineItemDto</span><span class="p">))</span>
       <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="s">&quot;Total&quot;</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">ConvertUsing</span><span class="p">(</span><span class="k">new</span> <span class="n">CurrencyFormatter</span><span class="p">(),</span> <span class="s">&quot;LITotal&quot;</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Value converters are only used for in-memory mapping execution. They will not work for <a class="reference external" href="Queryable-Extensions.html"><code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code></a>.</p>
</div>
<span id="document-Value-transformers"></span><div class="section" id="value-transformers">
<h2>Value Transformers<a class="headerlink" href="#value-transformers" title="Permalink to this headline">¶</a></h2>
<p>Value transformers apply an additional transformation to a single type. Before assigning the value, AutoMapper will check to see if the value to be set has any value transformations associated, and will apply them before setting.</p>
<p>You can create value transformers at several different levels:</p>
<ul class="simple">
<li>Globally</li>
<li>Profile</li>
<li>Map</li>
<li>Member</li>
</ul>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">cfg</span><span class="p">.</span><span class="n">ValueTransformers</span><span class="p">.</span><span class="n">Add</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">val</span> <span class="p">=&gt;</span> <span class="n">val</span> <span class="p">+</span> <span class="s">&quot;!!!&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Source</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">dest</span> <span class="p">=</span> <span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Dest</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">);</span>

<span class="n">dest</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">ShouldBe</span><span class="p">(</span><span class="s">&quot;Hello!!!&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<span id="document-Before-and-after-map-actions"></span><div class="section" id="before-and-after-map-action">
<h2>Before and After Map Action<a class="headerlink" href="#before-and-after-map-action" title="Permalink to this headline">¶</a></h2>
<p>Occasionally, you might need to perform custom logic before or after a map occurs. These should be a rarity, as it’s more obvious to do this work outside of AutoMapper. You can create global before/after map actions:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">BeforeMap</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="n">src</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="m">10</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AfterMap</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;John&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Or you can create before/after map callbacks during mapping:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
<span class="n">mapper</span><span class="p">.</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;(</span><span class="n">src</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">opt</span><span class="p">.</span><span class="n">BeforeMap</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">src</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="n">src</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">opt</span><span class="p">.</span><span class="n">AfterMap</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="n">HttpContext</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Identity</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The latter configuration is helpful when you need contextual information fed into before/after map actions.</p>
<div class="section" id="using-imappingaction">
<h3>Using <code class="docutils literal notranslate"><span class="pre">IMappingAction</span></code><a class="headerlink" href="#using-imappingaction" title="Permalink to this headline">¶</a></h3>
<p>You can encapsulate Before and After Map Actions into small reusable classes. Those classes need to implement the <code class="docutils literal notranslate"><span class="pre">IMappingAction&lt;in</span> <span class="pre">TSource,</span> <span class="pre">in</span> <span class="pre">TDestination&gt;</span></code> interface.</p>
<p>Using the previous example, here is an encapsulation of naming some objects “John”:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">NameMeJohnAction</span> <span class="p">:</span> <span class="n">IMappingAction</span><span class="p">&lt;</span><span class="n">SomePersonObject</span><span class="p">,</span> <span class="n">SomeOtherPersonObject</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Process</span><span class="p">(</span><span class="n">SomePersonObject</span> <span class="n">source</span><span class="p">,</span> <span class="n">SomeOtherPersonObject</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">destination</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;John&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">configuration</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MapperConfiguration</span><span class="p">(</span><span class="n">cfg</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">SomePersonObject</span><span class="p">,</span> <span class="n">SomeOtherPersonObject</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">AfterMap</span><span class="p">&lt;</span><span class="n">NameMeJohnAction</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="section" id="asp-net-core-and-automapper-extensions-microsoft-dependencyinjection">
<h4>Asp.Net Core and <code class="docutils literal notranslate"><span class="pre">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code><a class="headerlink" href="#asp-net-core-and-automapper-extensions-microsoft-dependencyinjection" title="Permalink to this headline">¶</a></h4>
<p>If you are using Asp.Net Core and the <code class="docutils literal notranslate"><span class="pre">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code> package, this is also a good way of using Dependency Injection. You can’t inject dependencies into <code class="docutils literal notranslate"><span class="pre">Profile</span></code> classes, but you can do it in <code class="docutils literal notranslate"><span class="pre">IMappingAction</span></code> implementations.</p>
<p>The following example shows how to connect an <code class="docutils literal notranslate"><span class="pre">IMappingAction</span></code> accessing the current <code class="docutils literal notranslate"><span class="pre">HttpContext</span></code> to a <code class="docutils literal notranslate"><span class="pre">Profile</span></code> after map action, leveraging Dependency Injection:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">SetTraceIdentifierAction</span> <span class="p">:</span> <span class="n">IMappingAction</span><span class="p">&lt;</span><span class="n">SomeModel</span><span class="p">,</span> <span class="n">SomeOtherModel</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IHttpContextAccessor</span> <span class="n">_httpContextAccessor</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">SetTraceIdentifierAction</span><span class="p">(</span><span class="n">IHttpContextAccessor</span> <span class="n">httpContextAccessor</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_httpContextAccessor</span> <span class="p">=</span> <span class="n">httpContextAccessor</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">httpContextAccessor</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Process</span><span class="p">(</span><span class="n">SomeModel</span> <span class="n">source</span><span class="p">,</span> <span class="n">SomeOtherModel</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">destination</span><span class="p">.</span><span class="n">TraceIdentifier</span> <span class="p">=</span> <span class="n">_httpContextAccessor</span><span class="p">.</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">TraceIdentifier</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeProfile</span> <span class="p">:</span> <span class="n">Profile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">SomeProfile</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">SomeModel</span><span class="p">,</span> <span class="n">SomeOtherModel</span><span class="p">&gt;()</span>
            <span class="p">.</span><span class="n">AfterMap</span><span class="p">&lt;</span><span class="n">SetTraceIdentifierAction</span><span class="p">&gt;();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Everything is connected together by:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">AddAutoMapper</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Startup</span><span class="p">).</span><span class="n">Assembly</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//..</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>See <code class="docutils literal notranslate"><span class="pre">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code> for more info.</em></p>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound" id="upgrading">
<span id="document-API-Changes"></span><div class="section" id="api-changes">
<h2>API Changes<a class="headerlink" href="#api-changes" title="Permalink to this headline">¶</a></h2>
<p>Starting with version 9.0, you can find out <a class="reference external" href="https://raw.githubusercontent.com/AutoMapper/AutoMapper/master/src/AutoMapper/ApiCompatBaseline.txt">what changed</a> in the public API from the last major version release.
From the <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/releases">releases page</a> you can reach the source code for that release and the version of ApiCompatBaseline.txt in that tree will tell you what changed.
A major version release is compared with the previous major version release (so 9.0.0 with 8.0.0) and a minor version release with the current major version release (so 9.1.1 with 9.0.0).</p>
</div>
<span id="document-11.0-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>11.0 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/AutoMapper/AutoMapper/releases/tag/v11.0.0">Release notes</a>.</p>
<div class="section" id="automapper-now-targets-net-standard-2-1-and-doesn-t-work-on-net-framework">
<h3>AutoMapper now targets .Net Standard 2.1 and doesn’t work on .Net Framework<a class="headerlink" href="#automapper-now-targets-net-standard-2-1-and-doesn-t-work-on-net-framework" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="forallmaps-forallpropertymaps-advanced-and-other-missing-apis">
<h3><code class="docutils literal notranslate"><span class="pre">ForAllMaps</span></code>, <code class="docutils literal notranslate"><span class="pre">ForAllPropertyMaps</span></code>, <code class="docutils literal notranslate"><span class="pre">Advanced</span></code> and other “missing” APIs<a class="headerlink" href="#forallmaps-forallpropertymaps-advanced-and-other-missing-apis" title="Permalink to this headline">¶</a></h3>
<p>Some APIs were hidden for normal usage. To light them up, you need to add an <code class="docutils literal notranslate"><span class="pre">using</span></code> for <code class="docutils literal notranslate"><span class="pre">AutoMapper.Internal</span></code> and call the <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/blob/9f2f16067ab201a5a8b9bc982f3a37e8790da7a0/src/AutoMapper/Internal/InternalApi.cs#L15"><code class="docutils literal notranslate"><span class="pre">Internal</span></code> extension method</a> on the configuration object.
Most users don’t need these advanced methods. Some expose internals and are not subject to the usual semantic versioning rules. To avoid such tight coupling to AutoMapper, you should try to stick to the public API.</p>
</div>
<div class="section" id="mapping-into-existing-collections">
<h3>Mapping <em>into</em> existing collections<a class="headerlink" href="#mapping-into-existing-collections" title="Permalink to this headline">¶</a></h3>
<p>When calling <code class="docutils literal notranslate"><span class="pre">Map</span></code> with an existing readonly collection, such as <code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;&gt;</span></code>, the setter will be used to replace it. If you actually have to map <em>into</em> that collection, you need to change its type to a writable
collection, such as <code class="docutils literal notranslate"><span class="pre">List&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">HashSet&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">ICollection&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">IList&lt;&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">IList</span></code>. Alternatively, you can remove the setter or set <code class="docutils literal notranslate"><span class="pre">UseDestinationValue</span></code>.</p>
</div>
<div class="section" id="createprojection">
<h3><code class="docutils literal notranslate"><span class="pre">CreateProjection</span></code><a class="headerlink" href="#createprojection" title="Permalink to this headline">¶</a></h3>
<p>If you don’t use <code class="docutils literal notranslate"><span class="pre">Map</span></code>, just <code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code>, you should use <code class="docutils literal notranslate"><span class="pre">CreateProjection</span></code> instead of <code class="docutils literal notranslate"><span class="pre">CreateMap</span></code>. That way you’ll use only the API subset supported by <code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code> and start-up should be faster.</p>
</div>
<div class="section" id="system-componentmodel-typeconverter-is-no-longer-supported">
<h3><code class="docutils literal notranslate"><span class="pre">System.ComponentModel.TypeConverter</span></code> is no longer supported<a class="headerlink" href="#system-componentmodel-typeconverter-is-no-longer-supported" title="Permalink to this headline">¶</a></h3>
<p>It was removed for performance reasons. So it’s best not to use it anymore. But if you must, there is <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?q=TypeConverterMapper">a sample</a> in the test project.</p>
</div>
<div class="section" id="generating-interface-proxies-is-disabled-by-default">
<h3>Generating interface proxies is disabled by default<a class="headerlink" href="#generating-interface-proxies-is-disabled-by-default" title="Permalink to this headline">¶</a></h3>
<p>That was misleading for a lot of people. You can opt-in per map with <code class="docutils literal notranslate"><span class="pre">AsProxy</span></code> (and <code class="docutils literal notranslate"><span class="pre">ForAllMaps</span></code> if needed).</p>
</div>
<div class="section" id="maptoattribute-and-ignoremapattribute-were-removed">
<h3><code class="docutils literal notranslate"><span class="pre">MapToAttribute</span></code> and <code class="docutils literal notranslate"><span class="pre">IgnoreMapAttribute</span></code> were removed<a class="headerlink" href="#maptoattribute-and-ignoremapattribute-were-removed" title="Permalink to this headline">¶</a></h3>
<p>These were older attributes, unrelated to the newer attributes API. You can switch to the fluent API or implement the attributes in your own code. Check the tests for sample code (<a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?q=MapToAttribute">here</a> and <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?q=IgnoreMapAttribute">here</a>).</p>
</div>
<div class="section" id="global-pre-and-postfixes-are-now-applied-in-all-maps">
<h3>Global pre and postfixes are now applied in all maps<a class="headerlink" href="#global-pre-and-postfixes-are-now-applied-in-all-maps" title="Permalink to this headline">¶</a></h3>
<p>They used to be applied only in the global configuration, now they are applied in all profiles, consistent with how settings work.</p>
</div>
<div class="section" id="forallothermembers-was-removed">
<h3><code class="docutils literal notranslate"><span class="pre">ForAllOtherMembers</span></code> was removed<a class="headerlink" href="#forallothermembers-was-removed" title="Permalink to this headline">¶</a></h3>
<p>That was used to disable mapping by convention, not something we want to support. When only used for validation, it can be replaced with <code class="docutils literal notranslate"><span class="pre">MemberList.None</span></code>.</p>
</div>
<div class="section" id="c-indexers-item-property">
<h3>C# Indexers (<code class="docutils literal notranslate"><span class="pre">Item</span></code> property)<a class="headerlink" href="#c-indexers-item-property" title="Permalink to this headline">¶</a></h3>
<p>These used to be ignored by default, but that’s expensive and most types don’t have them. So you have to explicitly ignore them. Globally, with <code class="docutils literal notranslate"><span class="pre">ShouldMapProperty</span></code> or <code class="docutils literal notranslate"><span class="pre">GlobalIgnores</span></code>, or per member.</p>
</div>
<div class="section" id="configuration-performance">
<h3>Configuration performance<a class="headerlink" href="#configuration-performance" title="Permalink to this headline">¶</a></h3>
<p>While you should get improvements without code changes, you can do even better. Definitely use <code class="docutils literal notranslate"><span class="pre">CreateProjection</span></code> with <code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code>. If you’re an advanced user and you’re confident in your test coverage, you can <a class="reference external" href="https://gist.github.com/lbargaoanu/9948bf66d452ba6b816252f9965143ee">disable</a> any features you don’t need. Needless to say, do measure to see if these help in your particular case.</p>
</div>
</div>
<span id="document-10.0-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>10.0 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/AutoMapper/AutoMapper/releases/tag/v10.0.0">Release notes</a>.</p>
<div class="section" id="all-collections-are-mapped-by-default-even-if-they-have-no-setter">
<h3>All collections are mapped by default, even if they have no setter<a class="headerlink" href="#all-collections-are-mapped-by-default-even-if-they-have-no-setter" title="Permalink to this headline">¶</a></h3>
<p>You’ll have to explicitly ignore those you don’t want mapped. See also <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/issues/3449#issuecomment-651522397">this</a>.</p>
</div>
<div class="section" id="matching-constructor-parameters-will-be-mapped-from-the-source-even-if-they-are-optional">
<h3>Matching constructor parameters will be mapped from the source, even if they are optional<a class="headerlink" href="#matching-constructor-parameters-will-be-mapped-from-the-source-even-if-they-are-optional" title="Permalink to this headline">¶</a></h3>
<p>You can always rename things or use an explicit <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>.</p>
</div>
<div class="section" id="context-mapper-map-overloads-that-receive-a-context-were-removed">
<h3><code class="docutils literal notranslate"><span class="pre">Context.Mapper.Map</span></code> overloads that receive a context were removed<a class="headerlink" href="#context-mapper-map-overloads-that-receive-a-context-were-removed" title="Permalink to this headline">¶</a></h3>
<p>Not needed, because the context is passed by default, so you can change the context instance you already have.</p>
</div>
<div class="section" id="usedestinationvalue-is-now-inherited-by-default">
<h3><code class="docutils literal notranslate"><span class="pre">UseDestinationValue</span></code> is now inherited by default<a class="headerlink" href="#usedestinationvalue-is-now-inherited-by-default" title="Permalink to this headline">¶</a></h3>
<p>You can override that with <code class="docutils literal notranslate"><span class="pre">DoNotUseDestinationValue</span></code>.</p>
</div>
<div class="section" id="allownull-allows-you-to-override-per-member-allownulldestinationvalues-and-allownullcollections">
<h3><code class="docutils literal notranslate"><span class="pre">AllowNull</span></code> allows you to override per member <code class="docutils literal notranslate"><span class="pre">AllowNullDestinationValues</span></code> and <code class="docutils literal notranslate"><span class="pre">AllowNullCollections</span></code><a class="headerlink" href="#allownull-allows-you-to-override-per-member-allownulldestinationvalues-and-allownullcollections" title="Permalink to this headline">¶</a></h3>
<p>This used to be ignored for <code class="docutils literal notranslate"><span class="pre">Map</span></code>. Now it’s consistent with <code class="docutils literal notranslate"><span class="pre">ProjectTo</span></code>.</p>
</div>
<div class="section" id="the-resolutioncontext-no-longer-has-a-public-constructor">
<h3>The <code class="docutils literal notranslate"><span class="pre">ResolutionContext</span></code> no longer has a public constructor<a class="headerlink" href="#the-resolutioncontext-no-longer-has-a-public-constructor" title="Permalink to this headline">¶</a></h3>
<p>You can test the entire <code class="docutils literal notranslate"><span class="pre">Map</span></code> operation.</p>
</div>
<div class="section" id="mapping-from-dynamic-in-net-4-6-1">
<h3>Mapping from <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> in .NET 4.6.1<a class="headerlink" href="#mapping-from-dynamic-in-net-4-6-1" title="Permalink to this headline">¶</a></h3>
<p>Due to a refactoring of <code class="docutils literal notranslate"><span class="pre">IMapper</span></code>, you might need to add a cast to <code class="docutils literal notranslate"><span class="pre">object</span></code> when mapping from <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.</p>
</div>
<div class="section" id="source-validation">
<h3>Source validation<a class="headerlink" href="#source-validation" title="Permalink to this headline">¶</a></h3>
<p>Only simple source members expressions are considered, <code class="docutils literal notranslate"><span class="pre">MapFrom(d</span> <span class="pre">=&gt;</span> <span class="pre">d.Member,</span> <span class="pre">s</span> <span class="pre">=&gt;</span> <span class="pre">s.SourceMember)</span></code>.</p>
</div>
<div class="section" id="maxdepth">
<h3><code class="docutils literal notranslate"><span class="pre">MaxDepth</span></code><a class="headerlink" href="#maxdepth" title="Permalink to this headline">¶</a></h3>
<p>When reaching <code class="docutils literal notranslate"><span class="pre">MaxDepth</span></code>, destination collections are null/empty, they used to contain <code class="docutils literal notranslate"><span class="pre">null</span></code> values.</p>
</div>
<div class="section" id="string-based-mapfrom-s-are-reversed-now-also-applies-to-attribute-mapping">
<h3>String based <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>-s are reversed now, also applies to attribute mapping<a class="headerlink" href="#string-based-mapfrom-s-are-reversed-now-also-applies-to-attribute-mapping" title="Permalink to this headline">¶</a></h3>
<p>You can always not use it and explicitly create the reverse map. Or ignore the reversed member.</p>
</div>
<div class="section" id="reversemap-will-also-reverse-the-naming-conventions">
<h3><code class="docutils literal notranslate"><span class="pre">ReverseMap</span></code> will also reverse the naming conventions<a class="headerlink" href="#reversemap-will-also-reverse-the-naming-conventions" title="Permalink to this headline">¶</a></h3>
<p>You can always not use it and explicitly create the reverse map.</p>
</div>
</div>
<span id="document-9.0-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>9.0 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-static-api-was-removed">
<h3>The static API was removed<a class="headerlink" href="#the-static-api-was-removed" title="Permalink to this headline">¶</a></h3>
<p>Switch to the instance based API, preferably using dependency injection.
See <a class="reference external" href="Setup.html">here</a> and <a class="reference external" href="Dependency-injection.html">here</a>.</p>
</div>
<div class="section" id="automapper-no-longer-creates-maps-automatically-createmissingtypemaps-and-conventions">
<h3>AutoMapper no longer creates maps automatically (CreateMissingTypeMaps and conventions)<a class="headerlink" href="#automapper-no-longer-creates-maps-automatically-createmissingtypemaps-and-conventions" title="Permalink to this headline">¶</a></h3>
<p>You will need to explicitly configure maps, manually or using reflection. Also consider <a class="reference external" href="Attribute-mapping.html">attribute mapping</a>.</p>
</div>
</div>
<span id="document-8.1.1-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>8.1.1 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this release is to allow you to upgrade to 9.0 gradually.</p>
<div class="section" id="automapper-no-longer-creates-maps-automatically-by-default">
<h3>AutoMapper no longer creates maps automatically by default<a class="headerlink" href="#automapper-no-longer-creates-maps-automatically-by-default" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">CreateMissingTypeMaps</span></code> was deprecated and its default value changed to <code class="docutils literal notranslate"><span class="pre">false</span></code>. If you were relying on this, your app will no longer work by default.</p>
<p>If you’re not interested in upgrading to 9.0, where dynamic mapping was removed, you should stick with 8.1.</p>
<p>Otherwise you can port your app gradually to 9.0 by creating the needed maps. Setting <code class="docutils literal notranslate"><span class="pre">CreateMissingTypeMaps</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code> will get you the 9.0 behavior and setting it to <code class="docutils literal notranslate"><span class="pre">true</span></code> will revert to the 8.1 behavior.</p>
</div>
</div>
<span id="document-8.0-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>8.0 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="projectusing">
<h3>ProjectUsing<a class="headerlink" href="#projectusing" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ProjectUsing</span></code> method consolidated with <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// IMappingExpression</span>

<span class="c1">// Old</span>
<span class="k">void</span> <span class="nf">ConvertUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">ProjectUsing</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">mappingExpression</span><span class="p">);</span>

<span class="c1">// New</span>
<span class="k">void</span> <span class="nf">ConvertUsing</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">mappingExpression</span><span class="p">);</span>
</pre></div>
</div>
<p>To migrate, replace all usages of <code class="docutils literal notranslate"><span class="pre">ProjectUsing</span></code> with <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code> expression-based method will be used for both in-memory mapping and LINQ projections. You cannot have separate configuration for in-memory vs. LINQ projections.</p>
<div class="section" id="existing-convertusing-usages">
<h4>Existing <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code> usages<a class="headerlink" href="#existing-convertusing-usages" title="Permalink to this headline">¶</a></h4>
<p>The change from <code class="docutils literal notranslate"><span class="pre">Func</span></code> to <code class="docutils literal notranslate"><span class="pre">Expression</span></code> may break some existing usages. Namely:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code> using lambda statements, method groups, or delegates</li>
<li>Dual configuration of <code class="docutils literal notranslate"><span class="pre">ProjectUsing</span></code> and <code class="docutils literal notranslate"><span class="pre">ConvertUsing</span></code></li>
</ul>
<p>For the first case, you may either:</p>
<ul class="simple">
<li>Convert to a lambda expression</li>
<li>Move to the <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overloads</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overloads accept more parameters, so you may have to add the parameters to your delegates.</p>
</div>
<div class="section" id="motivation">
<h4>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h4>
<p>Simplify overloads, and to make it clear that you cannot have separate configuration for LINQ projections vs. in-memory mapping.</p>
</div>
</div>
<div class="section" id="constructprojectionusing">
<h3>ConstructProjectionUsing<a class="headerlink" href="#constructprojectionusing" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ConstructProjectionUsing</span></code> method consolidated with <code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// IMappingExpression&lt;TSource, TDestination&gt;</span>

<span class="c1">// Old</span>
<span class="n">IMappingExpression</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">ResolutionContext</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ConstructProjectionUsing</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">ctorExpression</span><span class="p">);</span>

<span class="c1">// New</span>
<span class="n">IMappingExpression</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ConstructUsing</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">ResolutionContext</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>

<span class="c1">// IMappingExpression</span>

<span class="c1">// Old</span>
<span class="n">IMappingExpression</span> <span class="nf">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span> <span class="nf">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">ResolutionContext</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span> <span class="nf">ConstructProjectionUsing</span><span class="p">(</span><span class="n">LambdaExpression</span> <span class="n">ctorExpression</span><span class="p">);</span>

<span class="c1">// New</span>
<span class="n">IMappingExpression</span> <span class="nf">ConstructUsing</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">ctor</span><span class="p">);</span>
<span class="n">IMappingExpression</span> <span class="nf">ConstructUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">ResolutionContext</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">ctor</span><span class="p">);</span>
</pre></div>
</div>
<p>To migrate, replace all usages of <code class="docutils literal notranslate"><span class="pre">ConstructProjectionUsing</span></code> with <code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code> expression-based method will be used for both in-memory mapping and LINQ projections. You cannot have separate configuration for in-memory vs. LINQ projections.</p>
<div class="section" id="existing-constructusing-usages">
<h4>Existing <code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code> usages<a class="headerlink" href="#existing-constructusing-usages" title="Permalink to this headline">¶</a></h4>
<p>The change from <code class="docutils literal notranslate"><span class="pre">Func</span></code> to <code class="docutils literal notranslate"><span class="pre">Expression</span></code> may break some existing usages. Namely:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code> using lambda statements, method groups, or delegates</li>
<li>Dual configuration of <code class="docutils literal notranslate"><span class="pre">ConstructProjectionUsing</span></code> and <code class="docutils literal notranslate"><span class="pre">ConstructUsing</span></code></li>
</ul>
<p>For the first case, you may either:</p>
<ul class="simple">
<li>Convert to a lambda expression</li>
<li>Move to the <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overload</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overload accepts more parameters, so you may have to add the parameters to your delegates.</p>
</div>
<div class="section" id="id1">
<h4>Motivation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Simplify overloads, and to make it clear that you cannot have separate configuration for LINQ projections vs. in-memory mapping.</p>
</div>
</div>
<div class="section" id="resolveusing">
<h3>ResolveUsing<a class="headerlink" href="#resolveusing" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ResolveUsing</span></code> method consolidated with <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// IMappingExpression</span>

<span class="c1">// Old</span>
<span class="k">void</span> <span class="nf">ResolveUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">ResolveUsing</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="k">void</span> <span class="n">ResolveUsing</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TMember</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="c1">// Many, many overloads</span>
<span class="k">void</span> <span class="nf">MapFrom</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">mapExpression</span><span class="p">);</span>

<span class="c1">// New</span>
<span class="k">void</span> <span class="nf">MapFrom</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;&gt;</span> <span class="n">mappingExpression</span><span class="p">);</span>
<span class="k">void</span> <span class="n">MapFrom</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
<span class="k">void</span> <span class="n">MapFrom</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TMember</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">mappingFunction</span><span class="p">);</span>
</pre></div>
</div>
<p>To migrate, replace all usages of <code class="docutils literal notranslate"><span class="pre">ResolveUsing</span></code> with <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> expression-based method will be used for both in-memory mapping and LINQ projections. You cannot have separate configuration for in-memory vs. LINQ projections.</p>
<div class="section" id="existing-resolveusing-usages">
<h4>Existing <code class="docutils literal notranslate"><span class="pre">ResolveUsing</span></code> usages<a class="headerlink" href="#existing-resolveusing-usages" title="Permalink to this headline">¶</a></h4>
<p>The change from <code class="docutils literal notranslate"><span class="pre">Func</span></code> to <code class="docutils literal notranslate"><span class="pre">Expression</span></code> may break some existing usages. Namely:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ResolveUsing</span></code> using lambda statements, method groups, or delegates</li>
<li>Dual configuration of <code class="docutils literal notranslate"><span class="pre">ResolveUsing</span></code> and <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code></li>
</ul>
<p>For the first case, you may either:</p>
<ul class="simple">
<li>Convert to a lambda expression</li>
<li>Move to the <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overloads</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Func</span></code>-based overloads accept more parameters, so you may have to add the parameters to your delegates.</p>
</div>
<div class="section" id="id2">
<h4>Motivation<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Simplify overloads, and to make it clear that you cannot have separate configuration for LINQ projections vs. in-memory mapping.</p>
</div>
</div>
<div class="section" id="usevalue">
<h3>UseValue<a class="headerlink" href="#usevalue" title="Permalink to this headline">¶</a></h3>
<p>Underneath the covers, <code class="docutils literal notranslate"><span class="pre">UseValue</span></code> called <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>. <code class="docutils literal notranslate"><span class="pre">UseValue</span></code> consolidated with <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>.</p>
<p>To migrate, replace all usages of <code class="docutils literal notranslate"><span class="pre">UseValue</span></code> with <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Old</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Date</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">UseValue</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">));</span>

<span class="c1">// New</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">dest</span> <span class="p">=&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">Date</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">MapFrom</span><span class="p">(</span><span class="n">src</span> <span class="p">=&gt;</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">));</span>
</pre></div>
</div>
<p>This can be simplified to a global find and replace of <code class="docutils literal notranslate"><span class="pre">UseValue(</span></code> with <code class="docutils literal notranslate"><span class="pre">MapFrom(src</span> <span class="pre">=&gt;</span></code>.</p>
<div class="section" id="id3">
<h4>Motivation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>To make the underlying configuration more explicit. Historically, <code class="docutils literal notranslate"><span class="pre">MapFrom</span></code> only allowed mapping from an individual source member. This restriction went away with 5.0, so there is no longer a need for additional redundant configuration options originally meant to work around this restriction.</p>
</div>
</div>
<div class="section" id="forsourcemember-ignore">
<h3>ForSourceMember Ignore<a class="headerlink" href="#forsourcemember-ignore" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ISourceMemberConfigurationExpression.Ignore</span></code> was renamed to <code class="docutils literal notranslate"><span class="pre">DoNotValidate</span></code> to avoid confusion. It only applies when validating source members, with <code class="docutils literal notranslate"><span class="pre">MemberList.Source</span></code>. It does not affect the mapping itself or validation for the default case, <code class="docutils literal notranslate"><span class="pre">MemberList.Destination</span></code>.
To migrate, replace all usages of <code class="docutils literal notranslate"><span class="pre">Ignore</span></code> with <code class="docutils literal notranslate"><span class="pre">DoNotValidate</span></code>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Old</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForSourceMember</span><span class="p">(</span><span class="n">source</span> <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">Date</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">Ignore</span><span class="p">());</span>

<span class="c1">// New</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Dest</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="n">ForSourceMember</span><span class="p">(</span><span class="n">source</span> <span class="p">=&gt;</span> <span class="n">source</span><span class="p">.</span><span class="n">Date</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">DoNotValidate</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="generic-maps-validation">
<h3>Generic maps validation<a class="headerlink" href="#generic-maps-validation" title="Permalink to this headline">¶</a></h3>
<p>Generic maps are now validated. The generic map itself is validated at configuration time for the non generic members, so AssertConfigurationIsValid should catch errors for those. And the closed generic map will be validated when it’s used, possibly at runtime. If you don’t care about those errors, you need to <a class="reference external" href="Configuration-validation.html#overriding-configuration-errors">override them</a>.</p>
</div>
</div>
<span id="document-5.0-Upgrade-Guide"></span><div class="section" id="upgrade-guide">
<h2>5.0 Upgrade Guide<a class="headerlink" href="#upgrade-guide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p>You now must use <code class="docutils literal notranslate"><span class="pre">MapperConfiguration</span></code> to initialize AutoMapper.</p>
<p>If you have a lot of <code class="docutils literal notranslate"><span class="pre">Mapper.CreateMap</span></code> calls everywhere, move those to a Profile.</p>
<p>For examples see <a class="reference external" href="Setup.html">here</a>.</p>
</div>
<div class="section" id="profiles">
<h3>Profiles<a class="headerlink" href="#profiles" title="Permalink to this headline">¶</a></h3>
<p>Instead of overriding a Configure method, you configure directly via the constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MappingProfile</span> <span class="p">:</span> <span class="n">Profile</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">MappingProfile</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">&gt;();</span>
        <span class="n">RecognizePrefix</span><span class="p">(</span><span class="s">&quot;m_&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ignoreallnonexisting-extension">
<h3>IgnoreAllNonExisting extension<a class="headerlink" href="#ignoreallnonexisting-extension" title="Permalink to this headline">¶</a></h3>
<p>A popular Stack Overflow post introduced the idea of ignoring all non-existing members on the destination type. It used things that don’t exist anymore in the configuration API. This functionality is really only intended for configuration validation.</p>
<p>In 5.0, you can use ReverseMap or CreateMap passing in the MemberList enum to validate against the source members (or no members). Any place you have this IgnoreAllNonExisting extension, use the CreateMap overload that validates against the source or no members:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">ProductDto</span><span class="p">,</span> <span class="n">Product</span><span class="p">&gt;(</span><span class="n">MemberList</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="resolution-context-things">
<h3>Resolution Context things<a class="headerlink" href="#resolution-context-things" title="Permalink to this headline">¶</a></h3>
<p>ResolutionContext used to capture a lot of information, source and destination values, along with a hierarchical parent model. For source/destination values, all of the interfaces (value resolvers and type converters) along with config options now include the source/destination values, and if applicable, source/destination members.</p>
<p>If you’re trying to access some parent object in your model, you will need to add those relationships to your models and access them through those relationships, and not through AutoMapper’s hierarchy. The ResolutionContext was pared down for both performance and sanity reasons.</p>
</div>
<div class="section" id="value-resolvers">
<h3>Value resolvers<a class="headerlink" href="#value-resolvers" title="Permalink to this headline">¶</a></h3>
<p>The signature of a value resolver has changed to allow access to the source/destination models. Additionally, the base class is gone in favor of interfaces. For value resolvers that do not have a member redirection, the interface is now:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IValueResolver</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TSource</span><span class="p">,</span> <span class="k">in</span> <span class="n">TDestination</span><span class="p">,</span> <span class="n">TDestMember</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">TDestMember</span> <span class="nf">Resolve</span><span class="p">(</span><span class="n">TSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">TDestination</span> <span class="n">destination</span><span class="p">,</span> <span class="n">TDestMember</span> <span class="n">destMember</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You have access now to the source model, destination model, and destination member this resolver is configured against.</p>
<p>If you are using a ResolveUsing and passing in the <code class="docutils literal notranslate"><span class="pre">FromMember</span></code> configuration, this is now a new resolver interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IMemberValueResolver</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TSource</span><span class="p">,</span> <span class="k">in</span> <span class="n">TDestination</span><span class="p">,</span> <span class="k">in</span> <span class="n">TSourceMember</span><span class="p">,</span> <span class="n">TDestMember</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">TDestMember</span> <span class="nf">Resolve</span><span class="p">(</span><span class="n">TSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">TDestination</span> <span class="n">destination</span><span class="p">,</span> <span class="n">TSourceMember</span> <span class="n">sourceMember</span><span class="p">,</span> <span class="n">TDestMember</span> <span class="n">destMember</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is now configured directly as <code class="docutils literal notranslate"><span class="pre">ForMember(dest</span> <span class="pre">=&gt;</span> <span class="pre">dest.Foo,</span> <span class="pre">opt</span> <span class="pre">=&gt;</span> <span class="pre">opt.ResolveUsing&lt;MyCustomResolver,</span> <span class="pre">string&gt;(src</span> <span class="pre">=&gt;</span> <span class="pre">src.Bar)</span></code></p>
</div>
<div class="section" id="type-converters">
<h3>Type converters<a class="headerlink" href="#type-converters" title="Permalink to this headline">¶</a></h3>
<p>The base class for a type converter is now gone in favor of a single interface that accepts the source and destination objects and returns the destination object:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">ITypeConverter</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TSource</span><span class="p">,</span> <span class="n">TDestination</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">TDestination</span> <span class="nf">Convert</span><span class="p">(</span><span class="n">TSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">TDestination</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ResolutionContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="circular-references">
<h3>Circular references<a class="headerlink" href="#circular-references" title="Permalink to this headline">¶</a></h3>
<p>Previously, AutoMapper could handle circular references by keeping track of what was mapped, and on every mapping, check a local hashtable of source/destination objects to see if the item was already mapped. It turns out this tracking is very expensive, and you need to opt-in using PreserveReferences for circular maps to work. Alternatively, you can configure MaxDepth:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">// Self-referential mapping</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Category</span><span class="p">,</span> <span class="n">CategoryDto</span><span class="p">&gt;().</span><span class="n">MaxDepth</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>

<span class="c1">// Circular references between users and groups</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">User</span><span class="p">,</span> <span class="n">UserDto</span><span class="p">&gt;().</span><span class="n">PreserveReferences</span><span class="p">();</span>
</pre></div>
</div>
<p>Starting from 6.1.0 PreserveReferences is set automatically at config time whenever the recursion can be detected statically. If you’re still getting <code class="docutils literal notranslate"><span class="pre">StackOverflowException</span></code>, open an issue with a full repro and we’ll look into it.</p>
</div>
<div class="section" id="usedestinationvalue">
<h3>UseDestinationValue<a class="headerlink" href="#usedestinationvalue" title="Permalink to this headline">¶</a></h3>
<p>UseDestinationValue tells AutoMapper not to create a new object for some member, but to use the existing property of the destination object. It used to be true by default. Consider whether this applies to your case. Check <a class="reference external" href="https://github.com/AutoMapper/AutoMapper/search?o=desc&amp;q=UseDestinationValue&amp;s=created&amp;type=Issues&amp;utf8=%E2%9C%93">recent issues</a>.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">cfg</span><span class="p">.</span><span class="n">CreateMap</span><span class="p">&lt;</span><span class="n">Source</span><span class="p">,</span> <span class="n">Destination</span><span class="p">&gt;()</span>
   <span class="p">.</span><span class="n">ForMember</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">Child</span><span class="p">,</span> <span class="n">opt</span> <span class="p">=&gt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">UseDestinationValue</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>The source code contains unit tests for all of the features listed above. Use the GitHub search to find relevant examples.</p>
</div>
<div class="section" id="housekeeping">
<h1>Housekeeping<a class="headerlink" href="#housekeeping" title="Permalink to this headline">¶</a></h1>
<p>The latest builds can be found at <a class="reference external" href="http://www.nuget.org/packages/automapper">NuGet</a></p>
<p>The dev builds can be found at <a class="reference external" href="https://myget.org/feed/automapperdev/package/nuget/AutoMapper">MyGet</a></p>
<p>The discussion group is hosted on <a class="reference external" href="http://groups.google.com/group/automapper-users">Google Groups</a></p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Jimmy Bogard
      
        <span class="commit">
          Revision <code>aa71782d</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
          <dd><a href="/en/stable/">stable</a></dd>
        
          <dd><a href="/en/v11.0.1/">v11.0.1</a></dd>
        
          <dd><a href="/en/v11.0.0/">v11.0.0</a></dd>
        
          <dd><a href="/en/v10.1.1/">v10.1.1</a></dd>
        
          <dd><a href="/en/v10.1.0/">v10.1.0</a></dd>
        
          <dd><a href="/en/v10.0.0/">v10.0.0</a></dd>
        
          <dd><a href="/en/v9.0.0/">v9.0.0</a></dd>
        
          <dd><a href="/en/v8.1.1/">v8.1.1</a></dd>
        
          <dd><a href="/en/v8.1.0/">v8.1.0</a></dd>
        
          <dd><a href="/en/v8.0.0/">v8.0.0</a></dd>
        
          <dd><a href="/en/v7.0.1/">v7.0.1</a></dd>
        
          <dd><a href="/en/v7.0.0/">v7.0.0</a></dd>
        
          <dd><a href="/en/v6.2.2/">v6.2.2</a></dd>
        
          <dd><a href="/en/v6.2.1/">v6.2.1</a></dd>
        
          <dd><a href="/en/v6.2.0/">v6.2.0</a></dd>
        
          <dd><a href="/en/v6.1.1/">v6.1.1</a></dd>
        
          <dd><a href="/en/v6.1.0/">v6.1.0</a></dd>
        
          <dd><a href="/en/v6.0.2/">v6.0.2</a></dd>
        
          <dd><a href="/en/v6.0.1/">v6.0.1</a></dd>
        
          <dd><a href="/en/v6.0.0/">v6.0.0</a></dd>
        
          <dd><a href="/en/v5.2.0/">v5.2.0</a></dd>
        
          <dd><a href="/en/v5.1.1/">v5.1.1</a></dd>
        
          <dd><a href="/en/v5.1.0/">v5.1.0</a></dd>
        
          <dd><a href="/en/v5.0.2/">v5.0.2</a></dd>
        
          <dd><a href="/en/v5.0.1/">v5.0.1</a></dd>
        
          <dd><a href="/en/v5.0.0/">v5.0.0</a></dd>
        
          <dd><a href="/en/v4.2.1/">v4.2.1</a></dd>
        
          <dd><a href="/en/v4.2.0/">v4.2.0</a></dd>
        
          <dd><a href="/en/v4.1.1/">v4.1.1</a></dd>
        
          <dd><a href="/en/v4.1.0/">v4.1.0</a></dd>
        
          <dd><a href="/en/v4.0.4/">v4.0.4</a></dd>
        
          <dd><a href="/en/v3.3.1/">v3.3.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//docs.automapper.org/_/downloads/en/latest/pdf/">pdf</a></dd>
        
          <dd><a href="//docs.automapper.org/_/downloads/en/latest/htmlzip/">html</a></dd>
        
          <dd><a href="//docs.automapper.org/_/downloads/en/latest/epub/">epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/automapper/?fromdocs=automapper">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/automapper/?fromdocs=automapper">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>