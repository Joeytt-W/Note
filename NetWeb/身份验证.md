# JWT算法

## JWT构成

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature)。

### header

jwt的头部承载两部分信息：

- 申明类型：JWT
- 申明加密的算法，通常直接使用 HMAC   HS256

```json
{
    "typ":"JWT",
    "alg":"HS256"
}
```

然后将头部进行base64编码（该编码是可以对称解密的),构成了第一部分.

### payload

载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：

-  标准中注册的声明
- 公共的声明
- 私有的声明

#### **标准中注册的声明** (建议但不强制使用) 

- **iss**: jwt签发者
- **sub**: jwt所面向的用户
- **aud**: 接收jwt的一方
- **exp**: jwt的过期时间，这个过期时间必须要大于签发时间
- **nbf**: 定义在什么时间之前，该jwt都是不可用的.
- **iat**: jwt的签发时间
- **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击

#### **公共的声明**

公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.

#### **私有的声明**

私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

```json
{
  "iss":"toptal.com",
  "exp":142642800 ,
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```



### 	Signature

jwt的第三部分是一个签证信息，这个部分需要base64加密后的header和base64加密后的payload使用`.`连接组成的字符串，然后通过header中声明的加密方式进行`secret`组合加密，然后就构成了jwt的第三部分。

- header (base64后的)
- payload (base64后的)
- secretKey

```c#
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secretKey');
```

## 如何应用

### c#加密

Nuget 按装 JWT包

```c#
 //要加密的数据
var payload = new Dictionary<string, object>
{
    {"UserId",123 },
    {"UserName","admin"}
};

string secretKey = "GqOSFaJDOsNOAFJwJETNErGUDF234lcOhstOIUHIu";//秘钥

//进行加密
IJwtAlgorithm jwtAlgorithm = new HMACSHA256Algorithm();//加密算法

IJsonSerializer jsonSerializer = new JsonNetSerializer();//序列化

IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//Base64加密

IJwtEncoder jwtEncoder = new JwtEncoder(jwtAlgorithm, jsonSerializer, urlEncoder);

string token = jwtEncoder.Encode(payload, secretKey);
```

得出加密串：

``eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJVc2VySWQiOjEyMywiVXNlck5hbWUiOiJhZG1pbiJ9.Yn39rWis5kgKLBhLeBYeqoQdjnplmlZJrU0lUlJuUJI``

### 解密

```c#
string token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJVc2VySWQiOjEyMywiVXNlck5hbWUiOiJhZG1pbiJ9.Yn39rWis5kgKLBhLeBYeqoQdjnplmlZJrU0lUlJuUJI";
string secretKey = "GqOSFaJDOsNOAFJwJETNErGUDF234lcOhstOIUHIu";//秘钥
string encodeStr = string.Empty;
try
{
    IJwtAlgorithm jwtAlgorithm = new HMACSHA256Algorithm();//加密算法

    IJsonSerializer jsonSerializer = new JsonNetSerializer();//序列化 

    IDateTimeProvider dateTimeProvider = new UtcDateTimeProvider();

    IJwtValidator jwtValidator = new JwtValidator(jsonSerializer, dateTimeProvider);

    IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//Base64加密

    IJwtDecoder jwtDecoder = new JwtDecoder(jsonSerializer, jwtValidator, urlEncoder, jwtAlgorithm);

    encodeStr = jwtDecoder.Decode(token,secretKey,true);//encodeStr:{"UserId":123,"UserName":"admin"}
}
catch
{
	encodeStr = "数据被篡改了";
}
```



一般是在请求头里加入`Authorization`，并加上`Bearer`标注,后台读取header验证：

```bash
fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

## 

## JWT封装成特性

JWT工具类

```c#
public class JWTTools
    {
        /// <summary>
        /// 加密
        /// </summary>
        private static readonly string _key = "GqOSFaJDOsNOAFJwJETNErGUDF234lcOhstOIUHIu";
        public static string Encode(Dictionary<string,object> payload,string key = null)
        {
            if (string.IsNullOrWhiteSpace(key))
                key = _key;
            IJwtAlgorithm jwtAlgorithm = new HMACSHA256Algorithm();//加密算法

            IJsonSerializer jsonSerializer = new JsonNetSerializer();//序列化

            IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//Base64加密

            IJwtEncoder jwtEncoder = new JwtEncoder(jwtAlgorithm, jsonSerializer, urlEncoder);

            payload.Add("timeout", DateTime.Now.AddDays(1));//设置超时时间

            string token = jwtEncoder.Encode(payload, key);

            return token;
        }

        /// <summary>
        /// 解析
        /// </summary>
        /// <param name="token"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Dictionary<string, object> Decode(string token,string key = null)
        {
            if (string.IsNullOrWhiteSpace(key))
                key = _key;
            string encodeStr = string.Empty;
            if (string.IsNullOrWhiteSpace(key))
                key = _key;
            try
            {
                IJwtAlgorithm jwtAlgorithm = new HMACSHA256Algorithm();//加密算法

                IJsonSerializer jsonSerializer = new JsonNetSerializer();//序列化

                IDateTimeProvider dateTimeProvider = new UtcDateTimeProvider();

                IJwtValidator jwtValidator = new JwtValidator(jsonSerializer, dateTimeProvider);

                IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//Base64加密

                IJwtDecoder jwtDecoder = new JwtDecoder(jsonSerializer, jwtValidator, urlEncoder, jwtAlgorithm);

                string encodeStr = jwtDecoder.Decode(token, key, true);

                var result = JsonConvert.DeserializeObject<Dictionary<string, object>>(encodeStr);

                if ((DateTime)result["timeout"] < DateTime.Now)
                    throw new Exception("超时，请重新登录");
                result.Remove("timeout");

                return result;
            }
            catch
            {
                throw new TokenExpiredException("解析失败");
            }
        }
    }
```

存到User方便对比

```c#
public class UserIdentity:IIdentity
    {
        public UserIdentity(string name,string UserPwd)
        {
            Name = name;
            Loginpwd = UserPwd;
        }
        public string Name { get; }
        public string Loginpwd { get; }
        public string AuthenticationType { get; }
        public bool IsAuthenticated { get; }
    }

    public class ApplicationUSer:IPrincipal
    {
        public ApplicationUSer(string name,string UserPwd)
        {
            Identity = new UserIdentity(name, UserPwd);
        }
        public bool IsInRole(string role)
        {
            throw new NotImplementedException();
        }

        public IIdentity Identity { get; }
    }
```

特性：

```c#
 public class MyAuthAttribute :Attribute, IAuthorizationFilter
    {
        public bool AllowMultiple => throw new NotImplementedException();

        public async Task<HttpResponseMessage> ExecuteAuthorizationFilterAsync(HttpActionContext actionContext, CancellationToken cancellationToken,
            Func<Task<HttpResponseMessage>> continuation)
        {
            //当某个特定的action添加了AllowAnonymous特性时，跳过校验
            if (actionContext.ActionDescriptor.GetCustomAttributes<AllowAnonymousAttribute>(true).Count > 0)
                return await continuation();
            
            IEnumerable<string> headers;
            if (actionContext.Request.Headers.TryGetValues("token", out headers))
            {
                var loginName = JWTTools.Decode(headers.First())["LoginName"].ToString();
                var loginpwd = JWTTools.Decode(headers.First())["UserPwd"].ToString();
                ((ApiController) actionContext.ControllerContext.Controller).User = new ApplicationUSer(loginName, loginpwd);
                return await continuation();
            }

            return new HttpResponseMessage(HttpStatusCode.Unauthorized);
        }

    }
```

使用

```c#
        // GET api/<controller>/5
        [MyAuth]
        public IHttpActionResult Get(int id)
        {
            return Ok(((UserIdentity)User.Identity).Loginpwd);
        }

        // POST api/<controller>
        [MyAuth]
        public void Post([FromBody] string value)
        {
        }

        [Route("Login")]
        [HttpPost]
        public IHttpActionResult Login(LoginViewModel model)
        {
            if (ModelState.IsValid)
            {
                return Ok(JWTTools.Encode(new Dictionary<string, object>(){
                        {
                            "LoginName",model.UserName
                        }
                    }
                ));
            }
            else
            {
                return BadRequest("登录验证失败");
            }
            

        }

```



