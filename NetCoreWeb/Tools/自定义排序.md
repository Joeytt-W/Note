# 第一种

```c#
	public static class IQueryableExtensions
    {
        /// <summary>
        /// 这是一个 IQueryable<T> 的拓展方法，接收排序字符串与属性映射字典，返回排序后的 IQueryable<T>
        /// </summary>
        /// <typeparam name="T">资源类型</typeparam>
        /// <param name="source">IQueryable 资源集合</param>
        /// <param name="orderBy">Uri Query 中的 orderBy 字符串，用于声明资源集合的排序规则；如果无需排序传入 null 即可</param>
        /// <param name="mappingDictionary">资源类型的映射关系字典</param>
        /// <returns>排好序的 IQueryable 资源集合</returns>
        public static IQueryable<T> ApplySort<T>(
            this IQueryable<T> source,
            string orderBy,
            Dictionary<string, PropertyMappingValue> mappingDictionary)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            if (mappingDictionary == null)
            {
                throw new ArgumentNullException(nameof(mappingDictionary));
            }

            if (string.IsNullOrWhiteSpace(orderBy))
            {
                return source;
            }
            //将 orderBy 字符串按 ',' 划分为数组
            var orderByAfterSplit = orderBy.Split(",");
            //依次处理数组中的每个排序依据
            foreach (var orderByClause in orderByAfterSplit.Reverse())
            {
                var trimmedOrderByClause = orderByClause.Trim();
                //是否 DESC
                var orderDescending = trimmedOrderByClause.EndsWith(" desc");
                //第一个空格的 index
                var indexOfFirstSpace = trimmedOrderByClause.IndexOf(" ", StringComparison.Ordinal);
                //属性名
                //如果存在空格，移除空格后面的内容（用来移除" desc"）
                var propertyName = indexOfFirstSpace == -1
                    ? trimmedOrderByClause
                    : trimmedOrderByClause.Remove(indexOfFirstSpace);
                //在属性映射字典中查找
                //属性映射字典的 Key 大小写不敏感，不用担心大小写问题
                if (!mappingDictionary.ContainsKey(propertyName))
                {
                    throw new ArgumentNullException($"没有找到Key为{propertyName}的映射");
                }

                var propertyMappingValue = mappingDictionary[propertyName];
                if (propertyMappingValue == null)
                {
                    throw new ArgumentNullException(nameof(propertyMappingValue));
                }

                foreach (var destinationProperty in propertyMappingValue.DestinationProperties.Reverse())
                {
                    if (propertyMappingValue.Revert)
                    {
                        orderDescending = !orderDescending;
                    }

                    source = source.OrderBy(destinationProperty +
                                            (orderDescending ? " descending" : " ascending"));
                }
            }

            return source;
        }
    }
```

```c#
	 public class PropertyMappingValue
    {
        public IEnumerable<string> DestinationProperties { get; set; }

        public bool Revert { get; set; }

        public PropertyMappingValue(IEnumerable<string> destinationProperties, bool revert = false)
        {
            DestinationProperties = destinationProperties 
                                    ?? throw new ArgumentNullException(nameof(destinationProperties));
            Revert = revert;
        }
    }
```

```c#
	public interface IPropertyMapping
    {
    }
```

```c#
	/// <summary>
    /// 指明 TSource 与 TDestination 的属性映射关系字典，用于集合资源的排序（视频P37）
    /// </summary>
    /// <typeparam name="TSource">源类型</typeparam>
    /// <typeparam name="TDestination">目标类型</typeparam>
    public class PropertyMapping<TSource, TDestination> : IPropertyMapping
    {
        /// <summary>
        /// 属性映射关系字典
        /// </summary>
        public Dictionary<string, PropertyMappingValue> MappingDictionary { get; private set; }
        public PropertyMapping(Dictionary<string, PropertyMappingValue> mappingDictionary)
        {
            MappingDictionary = mappingDictionary ?? throw new ArgumentNullException(nameof(mappingDictionary));
        }
    }
```

```c#
	/// <summary>
    /// 对集合资源进行排序时的属性映射服务	
    /// </summary>
    public class PropertyMappingService : IPropertyMappingService
    {
        //定义属性映射关系字典

        //Company Friendly Dto 的属性映射关系字典
        //GetCompanies 时，无论请求的是 Full Dto 还是 Friendly Dto，都允许按照 Full Dto 中的属性进行排序，所以这个字典用不上了
        //private readonly Dictionary<string, PropertyMappingValue> _companyPropertyMapping
        //    = new Dictionary<string, PropertyMappingValue>(StringComparer.OrdinalIgnoreCase) //Key 大小写不敏感
        //    {
        //        {"Id",new PropertyMappingValue(new List<string>{"Id"}) },
        //        {"Name",new PropertyMappingValue(new List<string>{"Name"}) }
        //    };

        //Company Full Dto 的属性映射关系字典
        private readonly Dictionary<string, PropertyMappingValue> _companyFullPropertyMapping
            = new Dictionary<string, PropertyMappingValue>(StringComparer.OrdinalIgnoreCase) //Key 大小写不敏感
            {
                {"Id",new PropertyMappingValue(new List<string>{"Id"}) },
                {"Name",new PropertyMappingValue(new List<string>{"Name"}) },
                {"Country",new PropertyMappingValue(new List<string>{"Country"}) },
                {"Industry",new PropertyMappingValue(new List<string>{"Industry"}) },
                {"Product",new PropertyMappingValue(new List<string>{"Product"}) },
                {"Introduction",new PropertyMappingValue(new List<string>{"Introduction"}) },
                {"BankruptTime",new PropertyMappingValue(new List<string>{"BankruptTime"}) },
            };

        //Employee Dto 的属性映射关系字典
        private readonly Dictionary<string, PropertyMappingValue> _employeeDtoPropertyMapping
            = new Dictionary<string, PropertyMappingValue>(StringComparer.OrdinalIgnoreCase) //Key 大小写不敏感
            {
                {"Id",new PropertyMappingValue(new List<string>{"Id"}) },
                {"CompanyId",new PropertyMappingValue(new List<string>{"CompanyId"}) },
                {"EmployeeNo",new PropertyMappingValue(new List<string>{"EmployeeNo"}) },
                {"Name",new PropertyMappingValue(new List<string>{"FirstName","LastName"}) },//"Name" 对应 FirstName 与 LastName 两个属性
                {"GenderDisplay",new PropertyMappingValue(new List<string>{"Gender"}) },
                {"Age",new PropertyMappingValue(new List<string>{"DateOfBirth"}, true) }     //"Age" 对应 DateOfBirth 属性，并且要翻转顺序
            };


        //因为不能在 IList<T> 中直接使用泛型了，无法解析 IList<PropertyMapping<TSource, TDestination>>
        //所有需要定义一个接口 IPropertyMapping，让 PropertyMapping 实现这个接口
        //然后使用 IList<IPropertyMapping> 来实现
        /// <summary>
        /// “指明 TSource 与 TDestination 的属性映射关系字典”的列表
        /// </summary>
        private IList<IPropertyMapping> _propertyMappings = new List<IPropertyMapping>();

        public PropertyMappingService()
        {
            //向列表中添加属性映射关系字典，同时指明该字典对应的源类型与目标类型
            //即向列表中添加“指明 TSource 与 TDestination 的属性映射关系字典”
            //_propertyMappings.Add(new PropertyMapping<CompanyFriendlyDto, Company>(_companyPropertyMapping));
            _propertyMappings.Add(new PropertyMapping<CompanyFullDto, Company>(_companyFullPropertyMapping));
            _propertyMappings.Add(new PropertyMapping<EmployeeDto, Employee>(_employeeDtoPropertyMapping));
        }

        /// <summary>
        /// 如果 TSource 与 TDestination 存在映射关系，返回属性映射关系字典
        /// </summary>
        /// <typeparam name="TSource">源类型</typeparam>
        /// <typeparam name="TDestination">目标类型</typeparam>
        /// <returns>从源类型到目标类型的属性映射关系</returns>
        public Dictionary<string, PropertyMappingValue> GetPropertyMapping<TSource, TDestination>()
        {
            var matchingMapping = _propertyMappings.OfType<PropertyMapping<TSource, TDestination>>();
            var propertyMapping = matchingMapping.ToList();
            if (propertyMapping.Count == 1)
            {
                //如果 TSource 与 TDestination 存在映射关系，返回对应的属性映射关系字典
                return propertyMapping.First().MappingDictionary;
            }
            throw new Exception($"无法找到唯一的映射关系：{typeof(TSource)},{typeof(TDestination)}");
        }

        /// <summary>
        /// 判断 Uri query parameters 中的 orderBy 是否合法
        /// </summary>
        /// <typeparam name="TSource">源类型</typeparam>
        /// <typeparam name="TDestination">目标类型</typeparam>
        /// <param name="orderBy">Uri Query 中的 orderBy 字符串，大小写不敏感</param>
        /// <returns>orderBy 字符串是否合法</returns>
        public bool ValidMappingExistsFor<TSource,TDestination>(string orderBy)
        {
            var propertyMapping = GetPropertyMapping<TSource, TDestination>();
            if (string.IsNullOrWhiteSpace(orderBy))
            {
                return true;
            }
            var fieldAfterSplit = orderBy.Split(",");
            foreach(var field in fieldAfterSplit)
            {
                var trimedField = field.Trim();
                var indexOfFirstSpace = trimedField.IndexOf(" ");
                var propertyName = indexOfFirstSpace == -1 ? trimedField : trimedField.Remove(indexOfFirstSpace);
                if (!propertyMapping.ContainsKey(propertyName))
                {
                    return false;
                }
            }
            return true;
        }
    }
```

```c#
	/// <summary>
    /// PropertyMappingService 的接口
    /// </summary>
    public interface IPropertyMappingService
    {
        Dictionary<string, PropertyMappingValue> GetPropertyMapping<TSource, TDestination>();
        bool ValidMappingExistsFor<TSource, TDestination>(string fields);
    }
```

# 第二种

```c#
 public static class EFSortUtil
    {
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="query"></param>
        /// <param name="field">属性名</param>
        /// <param name="desc"></param>
        /// <returns></returns>
        public static IQueryable<T> OrderBy<T>(this IQueryable<T> query, string field, bool desc = false)
        {
            if (!string.IsNullOrWhiteSpace(field))
            {
                ParameterExpression p = Expression.Parameter(typeof(T));
                Expression key = Expression.Property(p, field);
                var propInfo = GetPropertyInfo(typeof(T), field);
                var expr = GetOrderExpression(typeof(T), propInfo);
                if (desc)
                {
                    var method = typeof(Queryable).GetMethods().FirstOrDefault(m => m.Name == "OrderByDescending" && m.GetParameters().Length == 2);
                    var genericMethod = method.MakeGenericMethod(typeof(T), propInfo.PropertyType);
                    return (IQueryable<T>)genericMethod.Invoke(null, new object[] { query, expr });
                }
                else
                {
                    var method = typeof(Queryable).GetMethods().FirstOrDefault(m => m.Name == "OrderBy" && m.GetParameters().Length == 2);
                    var genericMethod = method.MakeGenericMethod(typeof(T), propInfo.PropertyType);
                    return (IQueryable<T>)genericMethod.Invoke(null, new object[] { query, expr });
                }
            }
            return query;
        }
        /// <summary>
        /// 获取反射
        /// </summary>
        /// <param name="objType"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        private static PropertyInfo GetPropertyInfo(Type objType, string name)
        {
            var properties = objType.GetProperties();
            var matchedProperty = properties.FirstOrDefault(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
            if (matchedProperty == null)
                throw new ArgumentException("对象不包含指定属性名");

            return matchedProperty;
        }
        /// <summary>
        /// 获取生成表达式
        /// </summary>
        /// <param name="objType"></param>
        /// <param name="pi"></param>
        /// <returns></returns>
        private static LambdaExpression GetOrderExpression(Type objType, PropertyInfo pi)
        {
            var paramExpr = Expression.Parameter(objType);
            var propAccess = Expression.PropertyOrField(paramExpr, pi.Name);
            var expr = Expression.Lambda(propAccess, paramExpr);
            return expr;
        }
    }
```

